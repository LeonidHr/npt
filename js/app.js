(() => {
    var __webpack_modules__ = {
        7757: function(module, __unused_webpack_exports, __webpack_require__) {
            /*!
 * Chart.js v2.9.4
 * https://www.chartjs.org
 * (c) 2020 Chart.js Contributors
 * Released under the MIT License
 */
            (function(global, factory) {
                true ? module.exports = factory(function() {
                    try {
                        return __webpack_require__(381);
                    } catch (e) {}
                }()) : 0;
            })(0, (function(moment) {
                "use strict";
                moment = moment && moment.hasOwnProperty("default") ? moment["default"] : moment;
                function createCommonjsModule(fn, module) {
                    return module = {
                        exports: {}
                    }, fn(module, module.exports), module.exports;
                }
                function getCjsExportFromNamespace(n) {
                    return n && n["default"] || n;
                }
                var colorName = {
                    aliceblue: [ 240, 248, 255 ],
                    antiquewhite: [ 250, 235, 215 ],
                    aqua: [ 0, 255, 255 ],
                    aquamarine: [ 127, 255, 212 ],
                    azure: [ 240, 255, 255 ],
                    beige: [ 245, 245, 220 ],
                    bisque: [ 255, 228, 196 ],
                    black: [ 0, 0, 0 ],
                    blanchedalmond: [ 255, 235, 205 ],
                    blue: [ 0, 0, 255 ],
                    blueviolet: [ 138, 43, 226 ],
                    brown: [ 165, 42, 42 ],
                    burlywood: [ 222, 184, 135 ],
                    cadetblue: [ 95, 158, 160 ],
                    chartreuse: [ 127, 255, 0 ],
                    chocolate: [ 210, 105, 30 ],
                    coral: [ 255, 127, 80 ],
                    cornflowerblue: [ 100, 149, 237 ],
                    cornsilk: [ 255, 248, 220 ],
                    crimson: [ 220, 20, 60 ],
                    cyan: [ 0, 255, 255 ],
                    darkblue: [ 0, 0, 139 ],
                    darkcyan: [ 0, 139, 139 ],
                    darkgoldenrod: [ 184, 134, 11 ],
                    darkgray: [ 169, 169, 169 ],
                    darkgreen: [ 0, 100, 0 ],
                    darkgrey: [ 169, 169, 169 ],
                    darkkhaki: [ 189, 183, 107 ],
                    darkmagenta: [ 139, 0, 139 ],
                    darkolivegreen: [ 85, 107, 47 ],
                    darkorange: [ 255, 140, 0 ],
                    darkorchid: [ 153, 50, 204 ],
                    darkred: [ 139, 0, 0 ],
                    darksalmon: [ 233, 150, 122 ],
                    darkseagreen: [ 143, 188, 143 ],
                    darkslateblue: [ 72, 61, 139 ],
                    darkslategray: [ 47, 79, 79 ],
                    darkslategrey: [ 47, 79, 79 ],
                    darkturquoise: [ 0, 206, 209 ],
                    darkviolet: [ 148, 0, 211 ],
                    deeppink: [ 255, 20, 147 ],
                    deepskyblue: [ 0, 191, 255 ],
                    dimgray: [ 105, 105, 105 ],
                    dimgrey: [ 105, 105, 105 ],
                    dodgerblue: [ 30, 144, 255 ],
                    firebrick: [ 178, 34, 34 ],
                    floralwhite: [ 255, 250, 240 ],
                    forestgreen: [ 34, 139, 34 ],
                    fuchsia: [ 255, 0, 255 ],
                    gainsboro: [ 220, 220, 220 ],
                    ghostwhite: [ 248, 248, 255 ],
                    gold: [ 255, 215, 0 ],
                    goldenrod: [ 218, 165, 32 ],
                    gray: [ 128, 128, 128 ],
                    green: [ 0, 128, 0 ],
                    greenyellow: [ 173, 255, 47 ],
                    grey: [ 128, 128, 128 ],
                    honeydew: [ 240, 255, 240 ],
                    hotpink: [ 255, 105, 180 ],
                    indianred: [ 205, 92, 92 ],
                    indigo: [ 75, 0, 130 ],
                    ivory: [ 255, 255, 240 ],
                    khaki: [ 240, 230, 140 ],
                    lavender: [ 230, 230, 250 ],
                    lavenderblush: [ 255, 240, 245 ],
                    lawngreen: [ 124, 252, 0 ],
                    lemonchiffon: [ 255, 250, 205 ],
                    lightblue: [ 173, 216, 230 ],
                    lightcoral: [ 240, 128, 128 ],
                    lightcyan: [ 224, 255, 255 ],
                    lightgoldenrodyellow: [ 250, 250, 210 ],
                    lightgray: [ 211, 211, 211 ],
                    lightgreen: [ 144, 238, 144 ],
                    lightgrey: [ 211, 211, 211 ],
                    lightpink: [ 255, 182, 193 ],
                    lightsalmon: [ 255, 160, 122 ],
                    lightseagreen: [ 32, 178, 170 ],
                    lightskyblue: [ 135, 206, 250 ],
                    lightslategray: [ 119, 136, 153 ],
                    lightslategrey: [ 119, 136, 153 ],
                    lightsteelblue: [ 176, 196, 222 ],
                    lightyellow: [ 255, 255, 224 ],
                    lime: [ 0, 255, 0 ],
                    limegreen: [ 50, 205, 50 ],
                    linen: [ 250, 240, 230 ],
                    magenta: [ 255, 0, 255 ],
                    maroon: [ 128, 0, 0 ],
                    mediumaquamarine: [ 102, 205, 170 ],
                    mediumblue: [ 0, 0, 205 ],
                    mediumorchid: [ 186, 85, 211 ],
                    mediumpurple: [ 147, 112, 219 ],
                    mediumseagreen: [ 60, 179, 113 ],
                    mediumslateblue: [ 123, 104, 238 ],
                    mediumspringgreen: [ 0, 250, 154 ],
                    mediumturquoise: [ 72, 209, 204 ],
                    mediumvioletred: [ 199, 21, 133 ],
                    midnightblue: [ 25, 25, 112 ],
                    mintcream: [ 245, 255, 250 ],
                    mistyrose: [ 255, 228, 225 ],
                    moccasin: [ 255, 228, 181 ],
                    navajowhite: [ 255, 222, 173 ],
                    navy: [ 0, 0, 128 ],
                    oldlace: [ 253, 245, 230 ],
                    olive: [ 128, 128, 0 ],
                    olivedrab: [ 107, 142, 35 ],
                    orange: [ 255, 165, 0 ],
                    orangered: [ 255, 69, 0 ],
                    orchid: [ 218, 112, 214 ],
                    palegoldenrod: [ 238, 232, 170 ],
                    palegreen: [ 152, 251, 152 ],
                    paleturquoise: [ 175, 238, 238 ],
                    palevioletred: [ 219, 112, 147 ],
                    papayawhip: [ 255, 239, 213 ],
                    peachpuff: [ 255, 218, 185 ],
                    peru: [ 205, 133, 63 ],
                    pink: [ 255, 192, 203 ],
                    plum: [ 221, 160, 221 ],
                    powderblue: [ 176, 224, 230 ],
                    purple: [ 128, 0, 128 ],
                    rebeccapurple: [ 102, 51, 153 ],
                    red: [ 255, 0, 0 ],
                    rosybrown: [ 188, 143, 143 ],
                    royalblue: [ 65, 105, 225 ],
                    saddlebrown: [ 139, 69, 19 ],
                    salmon: [ 250, 128, 114 ],
                    sandybrown: [ 244, 164, 96 ],
                    seagreen: [ 46, 139, 87 ],
                    seashell: [ 255, 245, 238 ],
                    sienna: [ 160, 82, 45 ],
                    silver: [ 192, 192, 192 ],
                    skyblue: [ 135, 206, 235 ],
                    slateblue: [ 106, 90, 205 ],
                    slategray: [ 112, 128, 144 ],
                    slategrey: [ 112, 128, 144 ],
                    snow: [ 255, 250, 250 ],
                    springgreen: [ 0, 255, 127 ],
                    steelblue: [ 70, 130, 180 ],
                    tan: [ 210, 180, 140 ],
                    teal: [ 0, 128, 128 ],
                    thistle: [ 216, 191, 216 ],
                    tomato: [ 255, 99, 71 ],
                    turquoise: [ 64, 224, 208 ],
                    violet: [ 238, 130, 238 ],
                    wheat: [ 245, 222, 179 ],
                    white: [ 255, 255, 255 ],
                    whitesmoke: [ 245, 245, 245 ],
                    yellow: [ 255, 255, 0 ],
                    yellowgreen: [ 154, 205, 50 ]
                };
                var conversions = createCommonjsModule((function(module) {
                    var reverseKeywords = {};
                    for (var key in colorName) if (colorName.hasOwnProperty(key)) reverseKeywords[colorName[key]] = key;
                    var convert = module.exports = {
                        rgb: {
                            channels: 3,
                            labels: "rgb"
                        },
                        hsl: {
                            channels: 3,
                            labels: "hsl"
                        },
                        hsv: {
                            channels: 3,
                            labels: "hsv"
                        },
                        hwb: {
                            channels: 3,
                            labels: "hwb"
                        },
                        cmyk: {
                            channels: 4,
                            labels: "cmyk"
                        },
                        xyz: {
                            channels: 3,
                            labels: "xyz"
                        },
                        lab: {
                            channels: 3,
                            labels: "lab"
                        },
                        lch: {
                            channels: 3,
                            labels: "lch"
                        },
                        hex: {
                            channels: 1,
                            labels: [ "hex" ]
                        },
                        keyword: {
                            channels: 1,
                            labels: [ "keyword" ]
                        },
                        ansi16: {
                            channels: 1,
                            labels: [ "ansi16" ]
                        },
                        ansi256: {
                            channels: 1,
                            labels: [ "ansi256" ]
                        },
                        hcg: {
                            channels: 3,
                            labels: [ "h", "c", "g" ]
                        },
                        apple: {
                            channels: 3,
                            labels: [ "r16", "g16", "b16" ]
                        },
                        gray: {
                            channels: 1,
                            labels: [ "gray" ]
                        }
                    };
                    for (var model in convert) if (convert.hasOwnProperty(model)) {
                        if (!("channels" in convert[model])) throw new Error("missing channels property: " + model);
                        if (!("labels" in convert[model])) throw new Error("missing channel labels property: " + model);
                        if (convert[model].labels.length !== convert[model].channels) throw new Error("channel and label counts mismatch: " + model);
                        var channels = convert[model].channels;
                        var labels = convert[model].labels;
                        delete convert[model].channels;
                        delete convert[model].labels;
                        Object.defineProperty(convert[model], "channels", {
                            value: channels
                        });
                        Object.defineProperty(convert[model], "labels", {
                            value: labels
                        });
                    }
                    convert.rgb.hsl = function(rgb) {
                        var r = rgb[0] / 255;
                        var g = rgb[1] / 255;
                        var b = rgb[2] / 255;
                        var min = Math.min(r, g, b);
                        var max = Math.max(r, g, b);
                        var delta = max - min;
                        var h;
                        var s;
                        var l;
                        if (max === min) h = 0; else if (r === max) h = (g - b) / delta; else if (g === max) h = 2 + (b - r) / delta; else if (b === max) h = 4 + (r - g) / delta;
                        h = Math.min(60 * h, 360);
                        if (h < 0) h += 360;
                        l = (min + max) / 2;
                        if (max === min) s = 0; else if (l <= .5) s = delta / (max + min); else s = delta / (2 - max - min);
                        return [ h, 100 * s, 100 * l ];
                    };
                    convert.rgb.hsv = function(rgb) {
                        var rdif;
                        var gdif;
                        var bdif;
                        var h;
                        var s;
                        var r = rgb[0] / 255;
                        var g = rgb[1] / 255;
                        var b = rgb[2] / 255;
                        var v = Math.max(r, g, b);
                        var diff = v - Math.min(r, g, b);
                        var diffc = function(c) {
                            return (v - c) / 6 / diff + 1 / 2;
                        };
                        if (0 === diff) h = s = 0; else {
                            s = diff / v;
                            rdif = diffc(r);
                            gdif = diffc(g);
                            bdif = diffc(b);
                            if (r === v) h = bdif - gdif; else if (g === v) h = 1 / 3 + rdif - bdif; else if (b === v) h = 2 / 3 + gdif - rdif;
                            if (h < 0) h += 1; else if (h > 1) h -= 1;
                        }
                        return [ 360 * h, 100 * s, 100 * v ];
                    };
                    convert.rgb.hwb = function(rgb) {
                        var r = rgb[0];
                        var g = rgb[1];
                        var b = rgb[2];
                        var h = convert.rgb.hsl(rgb)[0];
                        var w = 1 / 255 * Math.min(r, Math.min(g, b));
                        b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
                        return [ h, 100 * w, 100 * b ];
                    };
                    convert.rgb.cmyk = function(rgb) {
                        var r = rgb[0] / 255;
                        var g = rgb[1] / 255;
                        var b = rgb[2] / 255;
                        var c;
                        var m;
                        var y;
                        var k;
                        k = Math.min(1 - r, 1 - g, 1 - b);
                        c = (1 - r - k) / (1 - k) || 0;
                        m = (1 - g - k) / (1 - k) || 0;
                        y = (1 - b - k) / (1 - k) || 0;
                        return [ 100 * c, 100 * m, 100 * y, 100 * k ];
                    };
                    function comparativeDistance(x, y) {
                        return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
                    }
                    convert.rgb.keyword = function(rgb) {
                        var reversed = reverseKeywords[rgb];
                        if (reversed) return reversed;
                        var currentClosestDistance = 1 / 0;
                        var currentClosestKeyword;
                        for (var keyword in colorName) if (colorName.hasOwnProperty(keyword)) {
                            var value = colorName[keyword];
                            var distance = comparativeDistance(rgb, value);
                            if (distance < currentClosestDistance) {
                                currentClosestDistance = distance;
                                currentClosestKeyword = keyword;
                            }
                        }
                        return currentClosestKeyword;
                    };
                    convert.keyword.rgb = function(keyword) {
                        return colorName[keyword];
                    };
                    convert.rgb.xyz = function(rgb) {
                        var r = rgb[0] / 255;
                        var g = rgb[1] / 255;
                        var b = rgb[2] / 255;
                        r = r > .04045 ? Math.pow((r + .055) / 1.055, 2.4) : r / 12.92;
                        g = g > .04045 ? Math.pow((g + .055) / 1.055, 2.4) : g / 12.92;
                        b = b > .04045 ? Math.pow((b + .055) / 1.055, 2.4) : b / 12.92;
                        var x = .4124 * r + .3576 * g + .1805 * b;
                        var y = .2126 * r + .7152 * g + .0722 * b;
                        var z = .0193 * r + .1192 * g + .9505 * b;
                        return [ 100 * x, 100 * y, 100 * z ];
                    };
                    convert.rgb.lab = function(rgb) {
                        var xyz = convert.rgb.xyz(rgb);
                        var x = xyz[0];
                        var y = xyz[1];
                        var z = xyz[2];
                        var l;
                        var a;
                        var b;
                        x /= 95.047;
                        y /= 100;
                        z /= 108.883;
                        x = x > .008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
                        y = y > .008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
                        z = z > .008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
                        l = 116 * y - 16;
                        a = 500 * (x - y);
                        b = 200 * (y - z);
                        return [ l, a, b ];
                    };
                    convert.hsl.rgb = function(hsl) {
                        var h = hsl[0] / 360;
                        var s = hsl[1] / 100;
                        var l = hsl[2] / 100;
                        var t1;
                        var t2;
                        var t3;
                        var rgb;
                        var val;
                        if (0 === s) {
                            val = 255 * l;
                            return [ val, val, val ];
                        }
                        if (l < .5) t2 = l * (1 + s); else t2 = l + s - l * s;
                        t1 = 2 * l - t2;
                        rgb = [ 0, 0, 0 ];
                        for (var i = 0; i < 3; i++) {
                            t3 = h + 1 / 3 * -(i - 1);
                            if (t3 < 0) t3++;
                            if (t3 > 1) t3--;
                            if (6 * t3 < 1) val = t1 + 6 * (t2 - t1) * t3; else if (2 * t3 < 1) val = t2; else if (3 * t3 < 2) val = t1 + (t2 - t1) * (2 / 3 - t3) * 6; else val = t1;
                            rgb[i] = 255 * val;
                        }
                        return rgb;
                    };
                    convert.hsl.hsv = function(hsl) {
                        var h = hsl[0];
                        var s = hsl[1] / 100;
                        var l = hsl[2] / 100;
                        var smin = s;
                        var lmin = Math.max(l, .01);
                        var sv;
                        var v;
                        l *= 2;
                        s *= l <= 1 ? l : 2 - l;
                        smin *= lmin <= 1 ? lmin : 2 - lmin;
                        v = (l + s) / 2;
                        sv = 0 === l ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
                        return [ h, 100 * sv, 100 * v ];
                    };
                    convert.hsv.rgb = function(hsv) {
                        var h = hsv[0] / 60;
                        var s = hsv[1] / 100;
                        var v = hsv[2] / 100;
                        var hi = Math.floor(h) % 6;
                        var f = h - Math.floor(h);
                        var p = 255 * v * (1 - s);
                        var q = 255 * v * (1 - s * f);
                        var t = 255 * v * (1 - s * (1 - f));
                        v *= 255;
                        switch (hi) {
                          case 0:
                            return [ v, t, p ];

                          case 1:
                            return [ q, v, p ];

                          case 2:
                            return [ p, v, t ];

                          case 3:
                            return [ p, q, v ];

                          case 4:
                            return [ t, p, v ];

                          case 5:
                            return [ v, p, q ];
                        }
                    };
                    convert.hsv.hsl = function(hsv) {
                        var h = hsv[0];
                        var s = hsv[1] / 100;
                        var v = hsv[2] / 100;
                        var vmin = Math.max(v, .01);
                        var lmin;
                        var sl;
                        var l;
                        l = (2 - s) * v;
                        lmin = (2 - s) * vmin;
                        sl = s * vmin;
                        sl /= lmin <= 1 ? lmin : 2 - lmin;
                        sl = sl || 0;
                        l /= 2;
                        return [ h, 100 * sl, 100 * l ];
                    };
                    convert.hwb.rgb = function(hwb) {
                        var h = hwb[0] / 360;
                        var wh = hwb[1] / 100;
                        var bl = hwb[2] / 100;
                        var ratio = wh + bl;
                        var i;
                        var v;
                        var f;
                        var n;
                        if (ratio > 1) {
                            wh /= ratio;
                            bl /= ratio;
                        }
                        i = Math.floor(6 * h);
                        v = 1 - bl;
                        f = 6 * h - i;
                        if (0 !== (1 & i)) f = 1 - f;
                        n = wh + f * (v - wh);
                        var r;
                        var g;
                        var b;
                        switch (i) {
                          default:
                          case 6:
                          case 0:
                            r = v;
                            g = n;
                            b = wh;
                            break;

                          case 1:
                            r = n;
                            g = v;
                            b = wh;
                            break;

                          case 2:
                            r = wh;
                            g = v;
                            b = n;
                            break;

                          case 3:
                            r = wh;
                            g = n;
                            b = v;
                            break;

                          case 4:
                            r = n;
                            g = wh;
                            b = v;
                            break;

                          case 5:
                            r = v;
                            g = wh;
                            b = n;
                            break;
                        }
                        return [ 255 * r, 255 * g, 255 * b ];
                    };
                    convert.cmyk.rgb = function(cmyk) {
                        var c = cmyk[0] / 100;
                        var m = cmyk[1] / 100;
                        var y = cmyk[2] / 100;
                        var k = cmyk[3] / 100;
                        var r;
                        var g;
                        var b;
                        r = 1 - Math.min(1, c * (1 - k) + k);
                        g = 1 - Math.min(1, m * (1 - k) + k);
                        b = 1 - Math.min(1, y * (1 - k) + k);
                        return [ 255 * r, 255 * g, 255 * b ];
                    };
                    convert.xyz.rgb = function(xyz) {
                        var x = xyz[0] / 100;
                        var y = xyz[1] / 100;
                        var z = xyz[2] / 100;
                        var r;
                        var g;
                        var b;
                        r = 3.2406 * x + -1.5372 * y + -.4986 * z;
                        g = -.9689 * x + 1.8758 * y + .0415 * z;
                        b = .0557 * x + -.204 * y + 1.057 * z;
                        r = r > .0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - .055 : 12.92 * r;
                        g = g > .0031308 ? 1.055 * Math.pow(g, 1 / 2.4) - .055 : 12.92 * g;
                        b = b > .0031308 ? 1.055 * Math.pow(b, 1 / 2.4) - .055 : 12.92 * b;
                        r = Math.min(Math.max(0, r), 1);
                        g = Math.min(Math.max(0, g), 1);
                        b = Math.min(Math.max(0, b), 1);
                        return [ 255 * r, 255 * g, 255 * b ];
                    };
                    convert.xyz.lab = function(xyz) {
                        var x = xyz[0];
                        var y = xyz[1];
                        var z = xyz[2];
                        var l;
                        var a;
                        var b;
                        x /= 95.047;
                        y /= 100;
                        z /= 108.883;
                        x = x > .008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
                        y = y > .008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
                        z = z > .008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
                        l = 116 * y - 16;
                        a = 500 * (x - y);
                        b = 200 * (y - z);
                        return [ l, a, b ];
                    };
                    convert.lab.xyz = function(lab) {
                        var l = lab[0];
                        var a = lab[1];
                        var b = lab[2];
                        var x;
                        var y;
                        var z;
                        y = (l + 16) / 116;
                        x = a / 500 + y;
                        z = y - b / 200;
                        var y2 = Math.pow(y, 3);
                        var x2 = Math.pow(x, 3);
                        var z2 = Math.pow(z, 3);
                        y = y2 > .008856 ? y2 : (y - 16 / 116) / 7.787;
                        x = x2 > .008856 ? x2 : (x - 16 / 116) / 7.787;
                        z = z2 > .008856 ? z2 : (z - 16 / 116) / 7.787;
                        x *= 95.047;
                        y *= 100;
                        z *= 108.883;
                        return [ x, y, z ];
                    };
                    convert.lab.lch = function(lab) {
                        var l = lab[0];
                        var a = lab[1];
                        var b = lab[2];
                        var hr;
                        var h;
                        var c;
                        hr = Math.atan2(b, a);
                        h = 360 * hr / 2 / Math.PI;
                        if (h < 0) h += 360;
                        c = Math.sqrt(a * a + b * b);
                        return [ l, c, h ];
                    };
                    convert.lch.lab = function(lch) {
                        var l = lch[0];
                        var c = lch[1];
                        var h = lch[2];
                        var a;
                        var b;
                        var hr;
                        hr = h / 360 * 2 * Math.PI;
                        a = c * Math.cos(hr);
                        b = c * Math.sin(hr);
                        return [ l, a, b ];
                    };
                    convert.rgb.ansi16 = function(args) {
                        var r = args[0];
                        var g = args[1];
                        var b = args[2];
                        var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
                        value = Math.round(value / 50);
                        if (0 === value) return 30;
                        var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
                        if (2 === value) ansi += 60;
                        return ansi;
                    };
                    convert.hsv.ansi16 = function(args) {
                        return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
                    };
                    convert.rgb.ansi256 = function(args) {
                        var r = args[0];
                        var g = args[1];
                        var b = args[2];
                        if (r === g && g === b) {
                            if (r < 8) return 16;
                            if (r > 248) return 231;
                            return Math.round((r - 8) / 247 * 24) + 232;
                        }
                        var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
                        return ansi;
                    };
                    convert.ansi16.rgb = function(args) {
                        var color = args % 10;
                        if (0 === color || 7 === color) {
                            if (args > 50) color += 3.5;
                            color = color / 10.5 * 255;
                            return [ color, color, color ];
                        }
                        var mult = .5 * (~~(args > 50) + 1);
                        var r = (1 & color) * mult * 255;
                        var g = (color >> 1 & 1) * mult * 255;
                        var b = (color >> 2 & 1) * mult * 255;
                        return [ r, g, b ];
                    };
                    convert.ansi256.rgb = function(args) {
                        if (args >= 232) {
                            var c = 10 * (args - 232) + 8;
                            return [ c, c, c ];
                        }
                        args -= 16;
                        var rem;
                        var r = Math.floor(args / 36) / 5 * 255;
                        var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
                        var b = rem % 6 / 5 * 255;
                        return [ r, g, b ];
                    };
                    convert.rgb.hex = function(args) {
                        var integer = ((255 & Math.round(args[0])) << 16) + ((255 & Math.round(args[1])) << 8) + (255 & Math.round(args[2]));
                        var string = integer.toString(16).toUpperCase();
                        return "000000".substring(string.length) + string;
                    };
                    convert.hex.rgb = function(args) {
                        var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
                        if (!match) return [ 0, 0, 0 ];
                        var colorString = match[0];
                        if (3 === match[0].length) colorString = colorString.split("").map((function(char) {
                            return char + char;
                        })).join("");
                        var integer = parseInt(colorString, 16);
                        var r = integer >> 16 & 255;
                        var g = integer >> 8 & 255;
                        var b = 255 & integer;
                        return [ r, g, b ];
                    };
                    convert.rgb.hcg = function(rgb) {
                        var r = rgb[0] / 255;
                        var g = rgb[1] / 255;
                        var b = rgb[2] / 255;
                        var max = Math.max(Math.max(r, g), b);
                        var min = Math.min(Math.min(r, g), b);
                        var chroma = max - min;
                        var grayscale;
                        var hue;
                        if (chroma < 1) grayscale = min / (1 - chroma); else grayscale = 0;
                        if (chroma <= 0) hue = 0; else if (max === r) hue = (g - b) / chroma % 6; else if (max === g) hue = 2 + (b - r) / chroma; else hue = 4 + (r - g) / chroma + 4;
                        hue /= 6;
                        hue %= 1;
                        return [ 360 * hue, 100 * chroma, 100 * grayscale ];
                    };
                    convert.hsl.hcg = function(hsl) {
                        var s = hsl[1] / 100;
                        var l = hsl[2] / 100;
                        var c = 1;
                        var f = 0;
                        if (l < .5) c = 2 * s * l; else c = 2 * s * (1 - l);
                        if (c < 1) f = (l - .5 * c) / (1 - c);
                        return [ hsl[0], 100 * c, 100 * f ];
                    };
                    convert.hsv.hcg = function(hsv) {
                        var s = hsv[1] / 100;
                        var v = hsv[2] / 100;
                        var c = s * v;
                        var f = 0;
                        if (c < 1) f = (v - c) / (1 - c);
                        return [ hsv[0], 100 * c, 100 * f ];
                    };
                    convert.hcg.rgb = function(hcg) {
                        var h = hcg[0] / 360;
                        var c = hcg[1] / 100;
                        var g = hcg[2] / 100;
                        if (0 === c) return [ 255 * g, 255 * g, 255 * g ];
                        var pure = [ 0, 0, 0 ];
                        var hi = h % 1 * 6;
                        var v = hi % 1;
                        var w = 1 - v;
                        var mg = 0;
                        switch (Math.floor(hi)) {
                          case 0:
                            pure[0] = 1;
                            pure[1] = v;
                            pure[2] = 0;
                            break;

                          case 1:
                            pure[0] = w;
                            pure[1] = 1;
                            pure[2] = 0;
                            break;

                          case 2:
                            pure[0] = 0;
                            pure[1] = 1;
                            pure[2] = v;
                            break;

                          case 3:
                            pure[0] = 0;
                            pure[1] = w;
                            pure[2] = 1;
                            break;

                          case 4:
                            pure[0] = v;
                            pure[1] = 0;
                            pure[2] = 1;
                            break;

                          default:
                            pure[0] = 1;
                            pure[1] = 0;
                            pure[2] = w;
                        }
                        mg = (1 - c) * g;
                        return [ 255 * (c * pure[0] + mg), 255 * (c * pure[1] + mg), 255 * (c * pure[2] + mg) ];
                    };
                    convert.hcg.hsv = function(hcg) {
                        var c = hcg[1] / 100;
                        var g = hcg[2] / 100;
                        var v = c + g * (1 - c);
                        var f = 0;
                        if (v > 0) f = c / v;
                        return [ hcg[0], 100 * f, 100 * v ];
                    };
                    convert.hcg.hsl = function(hcg) {
                        var c = hcg[1] / 100;
                        var g = hcg[2] / 100;
                        var l = g * (1 - c) + .5 * c;
                        var s = 0;
                        if (l > 0 && l < .5) s = c / (2 * l); else if (l >= .5 && l < 1) s = c / (2 * (1 - l));
                        return [ hcg[0], 100 * s, 100 * l ];
                    };
                    convert.hcg.hwb = function(hcg) {
                        var c = hcg[1] / 100;
                        var g = hcg[2] / 100;
                        var v = c + g * (1 - c);
                        return [ hcg[0], 100 * (v - c), 100 * (1 - v) ];
                    };
                    convert.hwb.hcg = function(hwb) {
                        var w = hwb[1] / 100;
                        var b = hwb[2] / 100;
                        var v = 1 - b;
                        var c = v - w;
                        var g = 0;
                        if (c < 1) g = (v - c) / (1 - c);
                        return [ hwb[0], 100 * c, 100 * g ];
                    };
                    convert.apple.rgb = function(apple) {
                        return [ apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255 ];
                    };
                    convert.rgb.apple = function(rgb) {
                        return [ rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535 ];
                    };
                    convert.gray.rgb = function(args) {
                        return [ args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255 ];
                    };
                    convert.gray.hsl = convert.gray.hsv = function(args) {
                        return [ 0, 0, args[0] ];
                    };
                    convert.gray.hwb = function(gray) {
                        return [ 0, 100, gray[0] ];
                    };
                    convert.gray.cmyk = function(gray) {
                        return [ 0, 0, 0, gray[0] ];
                    };
                    convert.gray.lab = function(gray) {
                        return [ gray[0], 0, 0 ];
                    };
                    convert.gray.hex = function(gray) {
                        var val = 255 & Math.round(gray[0] / 100 * 255);
                        var integer = (val << 16) + (val << 8) + val;
                        var string = integer.toString(16).toUpperCase();
                        return "000000".substring(string.length) + string;
                    };
                    convert.rgb.gray = function(rgb) {
                        var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
                        return [ val / 255 * 100 ];
                    };
                }));
                conversions.rgb;
                conversions.hsl;
                conversions.hsv;
                conversions.hwb;
                conversions.cmyk;
                conversions.xyz;
                conversions.lab;
                conversions.lch;
                conversions.hex;
                conversions.keyword;
                conversions.ansi16;
                conversions.ansi256;
                conversions.hcg;
                conversions.apple;
                conversions.gray;
                function buildGraph() {
                    var graph = {};
                    var models = Object.keys(conversions);
                    for (var len = models.length, i = 0; i < len; i++) graph[models[i]] = {
                        distance: -1,
                        parent: null
                    };
                    return graph;
                }
                function deriveBFS(fromModel) {
                    var graph = buildGraph();
                    var queue = [ fromModel ];
                    graph[fromModel].distance = 0;
                    while (queue.length) {
                        var current = queue.pop();
                        var adjacents = Object.keys(conversions[current]);
                        for (var len = adjacents.length, i = 0; i < len; i++) {
                            var adjacent = adjacents[i];
                            var node = graph[adjacent];
                            if (-1 === node.distance) {
                                node.distance = graph[current].distance + 1;
                                node.parent = current;
                                queue.unshift(adjacent);
                            }
                        }
                    }
                    return graph;
                }
                function link(from, to) {
                    return function(args) {
                        return to(from(args));
                    };
                }
                function wrapConversion(toModel, graph) {
                    var path = [ graph[toModel].parent, toModel ];
                    var fn = conversions[graph[toModel].parent][toModel];
                    var cur = graph[toModel].parent;
                    while (graph[cur].parent) {
                        path.unshift(graph[cur].parent);
                        fn = link(conversions[graph[cur].parent][cur], fn);
                        cur = graph[cur].parent;
                    }
                    fn.conversion = path;
                    return fn;
                }
                var route = function(fromModel) {
                    var graph = deriveBFS(fromModel);
                    var conversion = {};
                    var models = Object.keys(graph);
                    for (var len = models.length, i = 0; i < len; i++) {
                        var toModel = models[i];
                        var node = graph[toModel];
                        if (null === node.parent) continue;
                        conversion[toModel] = wrapConversion(toModel, graph);
                    }
                    return conversion;
                };
                var convert = {};
                var models = Object.keys(conversions);
                function wrapRaw(fn) {
                    var wrappedFn = function(args) {
                        if (void 0 === args || null === args) return args;
                        if (arguments.length > 1) args = Array.prototype.slice.call(arguments);
                        return fn(args);
                    };
                    if ("conversion" in fn) wrappedFn.conversion = fn.conversion;
                    return wrappedFn;
                }
                function wrapRounded(fn) {
                    var wrappedFn = function(args) {
                        if (void 0 === args || null === args) return args;
                        if (arguments.length > 1) args = Array.prototype.slice.call(arguments);
                        var result = fn(args);
                        if ("object" === typeof result) for (var len = result.length, i = 0; i < len; i++) result[i] = Math.round(result[i]);
                        return result;
                    };
                    if ("conversion" in fn) wrappedFn.conversion = fn.conversion;
                    return wrappedFn;
                }
                models.forEach((function(fromModel) {
                    convert[fromModel] = {};
                    Object.defineProperty(convert[fromModel], "channels", {
                        value: conversions[fromModel].channels
                    });
                    Object.defineProperty(convert[fromModel], "labels", {
                        value: conversions[fromModel].labels
                    });
                    var routes = route(fromModel);
                    var routeModels = Object.keys(routes);
                    routeModels.forEach((function(toModel) {
                        var fn = routes[toModel];
                        convert[fromModel][toModel] = wrapRounded(fn);
                        convert[fromModel][toModel].raw = wrapRaw(fn);
                    }));
                }));
                var colorConvert = convert;
                var colorName$1 = {
                    aliceblue: [ 240, 248, 255 ],
                    antiquewhite: [ 250, 235, 215 ],
                    aqua: [ 0, 255, 255 ],
                    aquamarine: [ 127, 255, 212 ],
                    azure: [ 240, 255, 255 ],
                    beige: [ 245, 245, 220 ],
                    bisque: [ 255, 228, 196 ],
                    black: [ 0, 0, 0 ],
                    blanchedalmond: [ 255, 235, 205 ],
                    blue: [ 0, 0, 255 ],
                    blueviolet: [ 138, 43, 226 ],
                    brown: [ 165, 42, 42 ],
                    burlywood: [ 222, 184, 135 ],
                    cadetblue: [ 95, 158, 160 ],
                    chartreuse: [ 127, 255, 0 ],
                    chocolate: [ 210, 105, 30 ],
                    coral: [ 255, 127, 80 ],
                    cornflowerblue: [ 100, 149, 237 ],
                    cornsilk: [ 255, 248, 220 ],
                    crimson: [ 220, 20, 60 ],
                    cyan: [ 0, 255, 255 ],
                    darkblue: [ 0, 0, 139 ],
                    darkcyan: [ 0, 139, 139 ],
                    darkgoldenrod: [ 184, 134, 11 ],
                    darkgray: [ 169, 169, 169 ],
                    darkgreen: [ 0, 100, 0 ],
                    darkgrey: [ 169, 169, 169 ],
                    darkkhaki: [ 189, 183, 107 ],
                    darkmagenta: [ 139, 0, 139 ],
                    darkolivegreen: [ 85, 107, 47 ],
                    darkorange: [ 255, 140, 0 ],
                    darkorchid: [ 153, 50, 204 ],
                    darkred: [ 139, 0, 0 ],
                    darksalmon: [ 233, 150, 122 ],
                    darkseagreen: [ 143, 188, 143 ],
                    darkslateblue: [ 72, 61, 139 ],
                    darkslategray: [ 47, 79, 79 ],
                    darkslategrey: [ 47, 79, 79 ],
                    darkturquoise: [ 0, 206, 209 ],
                    darkviolet: [ 148, 0, 211 ],
                    deeppink: [ 255, 20, 147 ],
                    deepskyblue: [ 0, 191, 255 ],
                    dimgray: [ 105, 105, 105 ],
                    dimgrey: [ 105, 105, 105 ],
                    dodgerblue: [ 30, 144, 255 ],
                    firebrick: [ 178, 34, 34 ],
                    floralwhite: [ 255, 250, 240 ],
                    forestgreen: [ 34, 139, 34 ],
                    fuchsia: [ 255, 0, 255 ],
                    gainsboro: [ 220, 220, 220 ],
                    ghostwhite: [ 248, 248, 255 ],
                    gold: [ 255, 215, 0 ],
                    goldenrod: [ 218, 165, 32 ],
                    gray: [ 128, 128, 128 ],
                    green: [ 0, 128, 0 ],
                    greenyellow: [ 173, 255, 47 ],
                    grey: [ 128, 128, 128 ],
                    honeydew: [ 240, 255, 240 ],
                    hotpink: [ 255, 105, 180 ],
                    indianred: [ 205, 92, 92 ],
                    indigo: [ 75, 0, 130 ],
                    ivory: [ 255, 255, 240 ],
                    khaki: [ 240, 230, 140 ],
                    lavender: [ 230, 230, 250 ],
                    lavenderblush: [ 255, 240, 245 ],
                    lawngreen: [ 124, 252, 0 ],
                    lemonchiffon: [ 255, 250, 205 ],
                    lightblue: [ 173, 216, 230 ],
                    lightcoral: [ 240, 128, 128 ],
                    lightcyan: [ 224, 255, 255 ],
                    lightgoldenrodyellow: [ 250, 250, 210 ],
                    lightgray: [ 211, 211, 211 ],
                    lightgreen: [ 144, 238, 144 ],
                    lightgrey: [ 211, 211, 211 ],
                    lightpink: [ 255, 182, 193 ],
                    lightsalmon: [ 255, 160, 122 ],
                    lightseagreen: [ 32, 178, 170 ],
                    lightskyblue: [ 135, 206, 250 ],
                    lightslategray: [ 119, 136, 153 ],
                    lightslategrey: [ 119, 136, 153 ],
                    lightsteelblue: [ 176, 196, 222 ],
                    lightyellow: [ 255, 255, 224 ],
                    lime: [ 0, 255, 0 ],
                    limegreen: [ 50, 205, 50 ],
                    linen: [ 250, 240, 230 ],
                    magenta: [ 255, 0, 255 ],
                    maroon: [ 128, 0, 0 ],
                    mediumaquamarine: [ 102, 205, 170 ],
                    mediumblue: [ 0, 0, 205 ],
                    mediumorchid: [ 186, 85, 211 ],
                    mediumpurple: [ 147, 112, 219 ],
                    mediumseagreen: [ 60, 179, 113 ],
                    mediumslateblue: [ 123, 104, 238 ],
                    mediumspringgreen: [ 0, 250, 154 ],
                    mediumturquoise: [ 72, 209, 204 ],
                    mediumvioletred: [ 199, 21, 133 ],
                    midnightblue: [ 25, 25, 112 ],
                    mintcream: [ 245, 255, 250 ],
                    mistyrose: [ 255, 228, 225 ],
                    moccasin: [ 255, 228, 181 ],
                    navajowhite: [ 255, 222, 173 ],
                    navy: [ 0, 0, 128 ],
                    oldlace: [ 253, 245, 230 ],
                    olive: [ 128, 128, 0 ],
                    olivedrab: [ 107, 142, 35 ],
                    orange: [ 255, 165, 0 ],
                    orangered: [ 255, 69, 0 ],
                    orchid: [ 218, 112, 214 ],
                    palegoldenrod: [ 238, 232, 170 ],
                    palegreen: [ 152, 251, 152 ],
                    paleturquoise: [ 175, 238, 238 ],
                    palevioletred: [ 219, 112, 147 ],
                    papayawhip: [ 255, 239, 213 ],
                    peachpuff: [ 255, 218, 185 ],
                    peru: [ 205, 133, 63 ],
                    pink: [ 255, 192, 203 ],
                    plum: [ 221, 160, 221 ],
                    powderblue: [ 176, 224, 230 ],
                    purple: [ 128, 0, 128 ],
                    rebeccapurple: [ 102, 51, 153 ],
                    red: [ 255, 0, 0 ],
                    rosybrown: [ 188, 143, 143 ],
                    royalblue: [ 65, 105, 225 ],
                    saddlebrown: [ 139, 69, 19 ],
                    salmon: [ 250, 128, 114 ],
                    sandybrown: [ 244, 164, 96 ],
                    seagreen: [ 46, 139, 87 ],
                    seashell: [ 255, 245, 238 ],
                    sienna: [ 160, 82, 45 ],
                    silver: [ 192, 192, 192 ],
                    skyblue: [ 135, 206, 235 ],
                    slateblue: [ 106, 90, 205 ],
                    slategray: [ 112, 128, 144 ],
                    slategrey: [ 112, 128, 144 ],
                    snow: [ 255, 250, 250 ],
                    springgreen: [ 0, 255, 127 ],
                    steelblue: [ 70, 130, 180 ],
                    tan: [ 210, 180, 140 ],
                    teal: [ 0, 128, 128 ],
                    thistle: [ 216, 191, 216 ],
                    tomato: [ 255, 99, 71 ],
                    turquoise: [ 64, 224, 208 ],
                    violet: [ 238, 130, 238 ],
                    wheat: [ 245, 222, 179 ],
                    white: [ 255, 255, 255 ],
                    whitesmoke: [ 245, 245, 245 ],
                    yellow: [ 255, 255, 0 ],
                    yellowgreen: [ 154, 205, 50 ]
                };
                var colorString = {
                    getRgba,
                    getHsla,
                    getRgb,
                    getHsl,
                    getHwb,
                    getAlpha,
                    hexString,
                    rgbString,
                    rgbaString,
                    percentString,
                    percentaString,
                    hslString,
                    hslaString,
                    hwbString,
                    keyword
                };
                function getRgba(string) {
                    if (!string) return;
                    var abbr = /^#([a-fA-F0-9]{3,4})$/i, hex = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i, rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i, per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i, keyword = /(\w+)/;
                    var rgb = [ 0, 0, 0 ], a = 1, match = string.match(abbr), hexAlpha = "";
                    if (match) {
                        match = match[1];
                        hexAlpha = match[3];
                        for (var i = 0; i < rgb.length; i++) rgb[i] = parseInt(match[i] + match[i], 16);
                        if (hexAlpha) a = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100;
                    } else if (match = string.match(hex)) {
                        hexAlpha = match[2];
                        match = match[1];
                        for (i = 0; i < rgb.length; i++) rgb[i] = parseInt(match.slice(2 * i, 2 * i + 2), 16);
                        if (hexAlpha) a = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100;
                    } else if (match = string.match(rgba)) {
                        for (i = 0; i < rgb.length; i++) rgb[i] = parseInt(match[i + 1]);
                        a = parseFloat(match[4]);
                    } else if (match = string.match(per)) {
                        for (i = 0; i < rgb.length; i++) rgb[i] = Math.round(2.55 * parseFloat(match[i + 1]));
                        a = parseFloat(match[4]);
                    } else if (match = string.match(keyword)) {
                        if ("transparent" == match[1]) return [ 0, 0, 0, 0 ];
                        rgb = colorName$1[match[1]];
                        if (!rgb) return;
                    }
                    for (i = 0; i < rgb.length; i++) rgb[i] = scale(rgb[i], 0, 255);
                    if (!a && 0 != a) a = 1; else a = scale(a, 0, 1);
                    rgb[3] = a;
                    return rgb;
                }
                function getHsla(string) {
                    if (!string) return;
                    var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
                    var match = string.match(hsl);
                    if (match) {
                        var alpha = parseFloat(match[4]);
                        var h = scale(parseInt(match[1]), 0, 360), s = scale(parseFloat(match[2]), 0, 100), l = scale(parseFloat(match[3]), 0, 100), a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
                        return [ h, s, l, a ];
                    }
                }
                function getHwb(string) {
                    if (!string) return;
                    var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
                    var match = string.match(hwb);
                    if (match) {
                        var alpha = parseFloat(match[4]);
                        var h = scale(parseInt(match[1]), 0, 360), w = scale(parseFloat(match[2]), 0, 100), b = scale(parseFloat(match[3]), 0, 100), a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
                        return [ h, w, b, a ];
                    }
                }
                function getRgb(string) {
                    var rgba = getRgba(string);
                    return rgba && rgba.slice(0, 3);
                }
                function getHsl(string) {
                    var hsla = getHsla(string);
                    return hsla && hsla.slice(0, 3);
                }
                function getAlpha(string) {
                    var vals = getRgba(string);
                    if (vals) return vals[3]; else if (vals = getHsla(string)) return vals[3]; else if (vals = getHwb(string)) return vals[3];
                }
                function hexString(rgba, a) {
                    a = void 0 !== a && 3 === rgba.length ? a : rgba[3];
                    return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (a >= 0 && a < 1 ? hexDouble(Math.round(255 * a)) : "");
                }
                function rgbString(rgba, alpha) {
                    if (alpha < 1 || rgba[3] && rgba[3] < 1) return rgbaString(rgba, alpha);
                    return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
                }
                function rgbaString(rgba, alpha) {
                    if (void 0 === alpha) alpha = void 0 !== rgba[3] ? rgba[3] : 1;
                    return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
                }
                function percentString(rgba, alpha) {
                    if (alpha < 1 || rgba[3] && rgba[3] < 1) return percentaString(rgba, alpha);
                    var r = Math.round(rgba[0] / 255 * 100), g = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
                    return "rgb(" + r + "%, " + g + "%, " + b + "%)";
                }
                function percentaString(rgba, alpha) {
                    var r = Math.round(rgba[0] / 255 * 100), g = Math.round(rgba[1] / 255 * 100), b = Math.round(rgba[2] / 255 * 100);
                    return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
                }
                function hslString(hsla, alpha) {
                    if (alpha < 1 || hsla[3] && hsla[3] < 1) return hslaString(hsla, alpha);
                    return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
                }
                function hslaString(hsla, alpha) {
                    if (void 0 === alpha) alpha = void 0 !== hsla[3] ? hsla[3] : 1;
                    return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
                }
                function hwbString(hwb, alpha) {
                    if (void 0 === alpha) alpha = void 0 !== hwb[3] ? hwb[3] : 1;
                    return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (void 0 !== alpha && 1 !== alpha ? ", " + alpha : "") + ")";
                }
                function keyword(rgb) {
                    return reverseNames[rgb.slice(0, 3)];
                }
                function scale(num, min, max) {
                    return Math.min(Math.max(min, num), max);
                }
                function hexDouble(num) {
                    var str = num.toString(16).toUpperCase();
                    return str.length < 2 ? "0" + str : str;
                }
                var reverseNames = {};
                for (var name in colorName$1) reverseNames[colorName$1[name]] = name;
                var Color = function(obj) {
                    if (obj instanceof Color) return obj;
                    if (!(this instanceof Color)) return new Color(obj);
                    this.valid = false;
                    this.values = {
                        rgb: [ 0, 0, 0 ],
                        hsl: [ 0, 0, 0 ],
                        hsv: [ 0, 0, 0 ],
                        hwb: [ 0, 0, 0 ],
                        cmyk: [ 0, 0, 0, 0 ],
                        alpha: 1
                    };
                    var vals;
                    if ("string" === typeof obj) {
                        vals = colorString.getRgba(obj);
                        if (vals) this.setValues("rgb", vals); else if (vals = colorString.getHsla(obj)) this.setValues("hsl", vals); else if (vals = colorString.getHwb(obj)) this.setValues("hwb", vals);
                    } else if ("object" === typeof obj) {
                        vals = obj;
                        if (void 0 !== vals.r || void 0 !== vals.red) this.setValues("rgb", vals); else if (void 0 !== vals.l || void 0 !== vals.lightness) this.setValues("hsl", vals); else if (void 0 !== vals.v || void 0 !== vals.value) this.setValues("hsv", vals); else if (void 0 !== vals.w || void 0 !== vals.whiteness) this.setValues("hwb", vals); else if (void 0 !== vals.c || void 0 !== vals.cyan) this.setValues("cmyk", vals);
                    }
                };
                Color.prototype = {
                    isValid: function() {
                        return this.valid;
                    },
                    rgb: function() {
                        return this.setSpace("rgb", arguments);
                    },
                    hsl: function() {
                        return this.setSpace("hsl", arguments);
                    },
                    hsv: function() {
                        return this.setSpace("hsv", arguments);
                    },
                    hwb: function() {
                        return this.setSpace("hwb", arguments);
                    },
                    cmyk: function() {
                        return this.setSpace("cmyk", arguments);
                    },
                    rgbArray: function() {
                        return this.values.rgb;
                    },
                    hslArray: function() {
                        return this.values.hsl;
                    },
                    hsvArray: function() {
                        return this.values.hsv;
                    },
                    hwbArray: function() {
                        var values = this.values;
                        if (1 !== values.alpha) return values.hwb.concat([ values.alpha ]);
                        return values.hwb;
                    },
                    cmykArray: function() {
                        return this.values.cmyk;
                    },
                    rgbaArray: function() {
                        var values = this.values;
                        return values.rgb.concat([ values.alpha ]);
                    },
                    hslaArray: function() {
                        var values = this.values;
                        return values.hsl.concat([ values.alpha ]);
                    },
                    alpha: function(val) {
                        if (void 0 === val) return this.values.alpha;
                        this.setValues("alpha", val);
                        return this;
                    },
                    red: function(val) {
                        return this.setChannel("rgb", 0, val);
                    },
                    green: function(val) {
                        return this.setChannel("rgb", 1, val);
                    },
                    blue: function(val) {
                        return this.setChannel("rgb", 2, val);
                    },
                    hue: function(val) {
                        if (val) {
                            val %= 360;
                            val = val < 0 ? 360 + val : val;
                        }
                        return this.setChannel("hsl", 0, val);
                    },
                    saturation: function(val) {
                        return this.setChannel("hsl", 1, val);
                    },
                    lightness: function(val) {
                        return this.setChannel("hsl", 2, val);
                    },
                    saturationv: function(val) {
                        return this.setChannel("hsv", 1, val);
                    },
                    whiteness: function(val) {
                        return this.setChannel("hwb", 1, val);
                    },
                    blackness: function(val) {
                        return this.setChannel("hwb", 2, val);
                    },
                    value: function(val) {
                        return this.setChannel("hsv", 2, val);
                    },
                    cyan: function(val) {
                        return this.setChannel("cmyk", 0, val);
                    },
                    magenta: function(val) {
                        return this.setChannel("cmyk", 1, val);
                    },
                    yellow: function(val) {
                        return this.setChannel("cmyk", 2, val);
                    },
                    black: function(val) {
                        return this.setChannel("cmyk", 3, val);
                    },
                    hexString: function() {
                        return colorString.hexString(this.values.rgb);
                    },
                    rgbString: function() {
                        return colorString.rgbString(this.values.rgb, this.values.alpha);
                    },
                    rgbaString: function() {
                        return colorString.rgbaString(this.values.rgb, this.values.alpha);
                    },
                    percentString: function() {
                        return colorString.percentString(this.values.rgb, this.values.alpha);
                    },
                    hslString: function() {
                        return colorString.hslString(this.values.hsl, this.values.alpha);
                    },
                    hslaString: function() {
                        return colorString.hslaString(this.values.hsl, this.values.alpha);
                    },
                    hwbString: function() {
                        return colorString.hwbString(this.values.hwb, this.values.alpha);
                    },
                    keyword: function() {
                        return colorString.keyword(this.values.rgb, this.values.alpha);
                    },
                    rgbNumber: function() {
                        var rgb = this.values.rgb;
                        return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
                    },
                    luminosity: function() {
                        var rgb = this.values.rgb;
                        var lum = [];
                        for (var i = 0; i < rgb.length; i++) {
                            var chan = rgb[i] / 255;
                            lum[i] = chan <= .03928 ? chan / 12.92 : Math.pow((chan + .055) / 1.055, 2.4);
                        }
                        return .2126 * lum[0] + .7152 * lum[1] + .0722 * lum[2];
                    },
                    contrast: function(color2) {
                        var lum1 = this.luminosity();
                        var lum2 = color2.luminosity();
                        if (lum1 > lum2) return (lum1 + .05) / (lum2 + .05);
                        return (lum2 + .05) / (lum1 + .05);
                    },
                    level: function(color2) {
                        var contrastRatio = this.contrast(color2);
                        if (contrastRatio >= 7.1) return "AAA";
                        return contrastRatio >= 4.5 ? "AA" : "";
                    },
                    dark: function() {
                        var rgb = this.values.rgb;
                        var yiq = (299 * rgb[0] + 587 * rgb[1] + 114 * rgb[2]) / 1e3;
                        return yiq < 128;
                    },
                    light: function() {
                        return !this.dark();
                    },
                    negate: function() {
                        var rgb = [];
                        for (var i = 0; i < 3; i++) rgb[i] = 255 - this.values.rgb[i];
                        this.setValues("rgb", rgb);
                        return this;
                    },
                    lighten: function(ratio) {
                        var hsl = this.values.hsl;
                        hsl[2] += hsl[2] * ratio;
                        this.setValues("hsl", hsl);
                        return this;
                    },
                    darken: function(ratio) {
                        var hsl = this.values.hsl;
                        hsl[2] -= hsl[2] * ratio;
                        this.setValues("hsl", hsl);
                        return this;
                    },
                    saturate: function(ratio) {
                        var hsl = this.values.hsl;
                        hsl[1] += hsl[1] * ratio;
                        this.setValues("hsl", hsl);
                        return this;
                    },
                    desaturate: function(ratio) {
                        var hsl = this.values.hsl;
                        hsl[1] -= hsl[1] * ratio;
                        this.setValues("hsl", hsl);
                        return this;
                    },
                    whiten: function(ratio) {
                        var hwb = this.values.hwb;
                        hwb[1] += hwb[1] * ratio;
                        this.setValues("hwb", hwb);
                        return this;
                    },
                    blacken: function(ratio) {
                        var hwb = this.values.hwb;
                        hwb[2] += hwb[2] * ratio;
                        this.setValues("hwb", hwb);
                        return this;
                    },
                    greyscale: function() {
                        var rgb = this.values.rgb;
                        var val = .3 * rgb[0] + .59 * rgb[1] + .11 * rgb[2];
                        this.setValues("rgb", [ val, val, val ]);
                        return this;
                    },
                    clearer: function(ratio) {
                        var alpha = this.values.alpha;
                        this.setValues("alpha", alpha - alpha * ratio);
                        return this;
                    },
                    opaquer: function(ratio) {
                        var alpha = this.values.alpha;
                        this.setValues("alpha", alpha + alpha * ratio);
                        return this;
                    },
                    rotate: function(degrees) {
                        var hsl = this.values.hsl;
                        var hue = (hsl[0] + degrees) % 360;
                        hsl[0] = hue < 0 ? 360 + hue : hue;
                        this.setValues("hsl", hsl);
                        return this;
                    },
                    mix: function(mixinColor, weight) {
                        var color1 = this;
                        var color2 = mixinColor;
                        var p = void 0 === weight ? .5 : weight;
                        var w = 2 * p - 1;
                        var a = color1.alpha() - color2.alpha();
                        var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
                        var w2 = 1 - w1;
                        return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
                    },
                    toJSON: function() {
                        return this.rgb();
                    },
                    clone: function() {
                        var result = new Color;
                        var source = this.values;
                        var target = result.values;
                        var value, type;
                        for (var prop in source) if (source.hasOwnProperty(prop)) {
                            value = source[prop];
                            type = {}.toString.call(value);
                            if ("[object Array]" === type) target[prop] = value.slice(0); else if ("[object Number]" === type) target[prop] = value; else console.error("unexpected color value:", value);
                        }
                        return result;
                    }
                };
                Color.prototype.spaces = {
                    rgb: [ "red", "green", "blue" ],
                    hsl: [ "hue", "saturation", "lightness" ],
                    hsv: [ "hue", "saturation", "value" ],
                    hwb: [ "hue", "whiteness", "blackness" ],
                    cmyk: [ "cyan", "magenta", "yellow", "black" ]
                };
                Color.prototype.maxes = {
                    rgb: [ 255, 255, 255 ],
                    hsl: [ 360, 100, 100 ],
                    hsv: [ 360, 100, 100 ],
                    hwb: [ 360, 100, 100 ],
                    cmyk: [ 100, 100, 100, 100 ]
                };
                Color.prototype.getValues = function(space) {
                    var values = this.values;
                    var vals = {};
                    for (var i = 0; i < space.length; i++) vals[space.charAt(i)] = values[space][i];
                    if (1 !== values.alpha) vals.a = values.alpha;
                    return vals;
                };
                Color.prototype.setValues = function(space, vals) {
                    var values = this.values;
                    var spaces = this.spaces;
                    var maxes = this.maxes;
                    var alpha = 1;
                    var i;
                    this.valid = true;
                    if ("alpha" === space) alpha = vals; else if (vals.length) {
                        values[space] = vals.slice(0, space.length);
                        alpha = vals[space.length];
                    } else if (void 0 !== vals[space.charAt(0)]) {
                        for (i = 0; i < space.length; i++) values[space][i] = vals[space.charAt(i)];
                        alpha = vals.a;
                    } else if (void 0 !== vals[spaces[space][0]]) {
                        var chans = spaces[space];
                        for (i = 0; i < space.length; i++) values[space][i] = vals[chans[i]];
                        alpha = vals.alpha;
                    }
                    values.alpha = Math.max(0, Math.min(1, void 0 === alpha ? values.alpha : alpha));
                    if ("alpha" === space) return false;
                    var capped;
                    for (i = 0; i < space.length; i++) {
                        capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
                        values[space][i] = Math.round(capped);
                    }
                    for (var sname in spaces) if (sname !== space) values[sname] = colorConvert[space][sname](values[space]);
                    return true;
                };
                Color.prototype.setSpace = function(space, args) {
                    var vals = args[0];
                    if (void 0 === vals) return this.getValues(space);
                    if ("number" === typeof vals) vals = Array.prototype.slice.call(args);
                    this.setValues(space, vals);
                    return this;
                };
                Color.prototype.setChannel = function(space, index, val) {
                    var svalues = this.values[space];
                    if (void 0 === val) return svalues[index]; else if (val === svalues[index]) return this;
                    svalues[index] = val;
                    this.setValues(space, svalues);
                    return this;
                };
                if ("undefined" !== typeof window) window.Color = Color;
                var chartjsColor = Color;
                function isValidKey(key) {
                    return -1 === [ "__proto__", "prototype", "constructor" ].indexOf(key);
                }
                var helpers = {
                    noop: function() {},
                    uid: function() {
                        var id = 0;
                        return function() {
                            return id++;
                        };
                    }(),
                    isNullOrUndef: function(value) {
                        return null === value || "undefined" === typeof value;
                    },
                    isArray: function(value) {
                        if (Array.isArray && Array.isArray(value)) return true;
                        var type = Object.prototype.toString.call(value);
                        if ("[object" === type.substr(0, 7) && "Array]" === type.substr(-6)) return true;
                        return false;
                    },
                    isObject: function(value) {
                        return null !== value && "[object Object]" === Object.prototype.toString.call(value);
                    },
                    isFinite: function(value) {
                        return ("number" === typeof value || value instanceof Number) && isFinite(value);
                    },
                    valueOrDefault: function(value, defaultValue) {
                        return "undefined" === typeof value ? defaultValue : value;
                    },
                    valueAtIndexOrDefault: function(value, index, defaultValue) {
                        return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
                    },
                    callback: function(fn, args, thisArg) {
                        if (fn && "function" === typeof fn.call) return fn.apply(thisArg, args);
                    },
                    each: function(loopable, fn, thisArg, reverse) {
                        var i, len, keys;
                        if (helpers.isArray(loopable)) {
                            len = loopable.length;
                            if (reverse) for (i = len - 1; i >= 0; i--) fn.call(thisArg, loopable[i], i); else for (i = 0; i < len; i++) fn.call(thisArg, loopable[i], i);
                        } else if (helpers.isObject(loopable)) {
                            keys = Object.keys(loopable);
                            len = keys.length;
                            for (i = 0; i < len; i++) fn.call(thisArg, loopable[keys[i]], keys[i]);
                        }
                    },
                    arrayEquals: function(a0, a1) {
                        var i, ilen, v0, v1;
                        if (!a0 || !a1 || a0.length !== a1.length) return false;
                        for (i = 0, ilen = a0.length; i < ilen; ++i) {
                            v0 = a0[i];
                            v1 = a1[i];
                            if (v0 instanceof Array && v1 instanceof Array) {
                                if (!helpers.arrayEquals(v0, v1)) return false;
                            } else if (v0 !== v1) return false;
                        }
                        return true;
                    },
                    clone: function(source) {
                        if (helpers.isArray(source)) return source.map(helpers.clone);
                        if (helpers.isObject(source)) {
                            var target = Object.create(source);
                            var keys = Object.keys(source);
                            var klen = keys.length;
                            var k = 0;
                            for (;k < klen; ++k) target[keys[k]] = helpers.clone(source[keys[k]]);
                            return target;
                        }
                        return source;
                    },
                    _merger: function(key, target, source, options) {
                        if (!isValidKey(key)) return;
                        var tval = target[key];
                        var sval = source[key];
                        if (helpers.isObject(tval) && helpers.isObject(sval)) helpers.merge(tval, sval, options); else target[key] = helpers.clone(sval);
                    },
                    _mergerIf: function(key, target, source) {
                        if (!isValidKey(key)) return;
                        var tval = target[key];
                        var sval = source[key];
                        if (helpers.isObject(tval) && helpers.isObject(sval)) helpers.mergeIf(tval, sval); else if (!target.hasOwnProperty(key)) target[key] = helpers.clone(sval);
                    },
                    merge: function(target, source, options) {
                        var sources = helpers.isArray(source) ? source : [ source ];
                        var ilen = sources.length;
                        var merge, i, keys, klen, k;
                        if (!helpers.isObject(target)) return target;
                        options = options || {};
                        merge = options.merger || helpers._merger;
                        for (i = 0; i < ilen; ++i) {
                            source = sources[i];
                            if (!helpers.isObject(source)) continue;
                            keys = Object.keys(source);
                            for (k = 0, klen = keys.length; k < klen; ++k) merge(keys[k], target, source, options);
                        }
                        return target;
                    },
                    mergeIf: function(target, source) {
                        return helpers.merge(target, source, {
                            merger: helpers._mergerIf
                        });
                    },
                    extend: Object.assign || function(target) {
                        return helpers.merge(target, [].slice.call(arguments, 1), {
                            merger: function(key, dst, src) {
                                dst[key] = src[key];
                            }
                        });
                    },
                    inherits: function(extensions) {
                        var me = this;
                        var ChartElement = extensions && extensions.hasOwnProperty("constructor") ? extensions.constructor : function() {
                            return me.apply(this, arguments);
                        };
                        var Surrogate = function() {
                            this.constructor = ChartElement;
                        };
                        Surrogate.prototype = me.prototype;
                        ChartElement.prototype = new Surrogate;
                        ChartElement.extend = helpers.inherits;
                        if (extensions) helpers.extend(ChartElement.prototype, extensions);
                        ChartElement.__super__ = me.prototype;
                        return ChartElement;
                    },
                    _deprecated: function(scope, value, previous, current) {
                        if (void 0 !== value) console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
                    }
                };
                var helpers_core = helpers;
                helpers.callCallback = helpers.callback;
                helpers.indexOf = function(array, item, fromIndex) {
                    return Array.prototype.indexOf.call(array, item, fromIndex);
                };
                helpers.getValueOrDefault = helpers.valueOrDefault;
                helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
                var effects = {
                    linear: function(t) {
                        return t;
                    },
                    easeInQuad: function(t) {
                        return t * t;
                    },
                    easeOutQuad: function(t) {
                        return -t * (t - 2);
                    },
                    easeInOutQuad: function(t) {
                        if ((t /= .5) < 1) return .5 * t * t;
                        return -.5 * (--t * (t - 2) - 1);
                    },
                    easeInCubic: function(t) {
                        return t * t * t;
                    },
                    easeOutCubic: function(t) {
                        return (t -= 1) * t * t + 1;
                    },
                    easeInOutCubic: function(t) {
                        if ((t /= .5) < 1) return .5 * t * t * t;
                        return .5 * ((t -= 2) * t * t + 2);
                    },
                    easeInQuart: function(t) {
                        return t * t * t * t;
                    },
                    easeOutQuart: function(t) {
                        return -((t -= 1) * t * t * t - 1);
                    },
                    easeInOutQuart: function(t) {
                        if ((t /= .5) < 1) return .5 * t * t * t * t;
                        return -.5 * ((t -= 2) * t * t * t - 2);
                    },
                    easeInQuint: function(t) {
                        return t * t * t * t * t;
                    },
                    easeOutQuint: function(t) {
                        return (t -= 1) * t * t * t * t + 1;
                    },
                    easeInOutQuint: function(t) {
                        if ((t /= .5) < 1) return .5 * t * t * t * t * t;
                        return .5 * ((t -= 2) * t * t * t * t + 2);
                    },
                    easeInSine: function(t) {
                        return -Math.cos(t * (Math.PI / 2)) + 1;
                    },
                    easeOutSine: function(t) {
                        return Math.sin(t * (Math.PI / 2));
                    },
                    easeInOutSine: function(t) {
                        return -.5 * (Math.cos(Math.PI * t) - 1);
                    },
                    easeInExpo: function(t) {
                        return 0 === t ? 0 : Math.pow(2, 10 * (t - 1));
                    },
                    easeOutExpo: function(t) {
                        return 1 === t ? 1 : -Math.pow(2, -10 * t) + 1;
                    },
                    easeInOutExpo: function(t) {
                        if (0 === t) return 0;
                        if (1 === t) return 1;
                        if ((t /= .5) < 1) return .5 * Math.pow(2, 10 * (t - 1));
                        return .5 * (-Math.pow(2, -10 * --t) + 2);
                    },
                    easeInCirc: function(t) {
                        if (t >= 1) return t;
                        return -(Math.sqrt(1 - t * t) - 1);
                    },
                    easeOutCirc: function(t) {
                        return Math.sqrt(1 - (t -= 1) * t);
                    },
                    easeInOutCirc: function(t) {
                        if ((t /= .5) < 1) return -.5 * (Math.sqrt(1 - t * t) - 1);
                        return .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
                    },
                    easeInElastic: function(t) {
                        var s = 1.70158;
                        var p = 0;
                        var a = 1;
                        if (0 === t) return 0;
                        if (1 === t) return 1;
                        if (!p) p = .3;
                        if (a < 1) {
                            a = 1;
                            s = p / 4;
                        } else s = p / (2 * Math.PI) * Math.asin(1 / a);
                        return -a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p);
                    },
                    easeOutElastic: function(t) {
                        var s = 1.70158;
                        var p = 0;
                        var a = 1;
                        if (0 === t) return 0;
                        if (1 === t) return 1;
                        if (!p) p = .3;
                        if (a < 1) {
                            a = 1;
                            s = p / 4;
                        } else s = p / (2 * Math.PI) * Math.asin(1 / a);
                        return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
                    },
                    easeInOutElastic: function(t) {
                        var s = 1.70158;
                        var p = 0;
                        var a = 1;
                        if (0 === t) return 0;
                        if (2 === (t /= .5)) return 1;
                        if (!p) p = .45;
                        if (a < 1) {
                            a = 1;
                            s = p / 4;
                        } else s = p / (2 * Math.PI) * Math.asin(1 / a);
                        if (t < 1) return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
                        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * .5 + 1;
                    },
                    easeInBack: function(t) {
                        var s = 1.70158;
                        return t * t * ((s + 1) * t - s);
                    },
                    easeOutBack: function(t) {
                        var s = 1.70158;
                        return (t -= 1) * t * ((s + 1) * t + s) + 1;
                    },
                    easeInOutBack: function(t) {
                        var s = 1.70158;
                        if ((t /= .5) < 1) return .5 * (t * t * (((s *= 1.525) + 1) * t - s));
                        return .5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
                    },
                    easeInBounce: function(t) {
                        return 1 - effects.easeOutBounce(1 - t);
                    },
                    easeOutBounce: function(t) {
                        if (t < 1 / 2.75) return 7.5625 * t * t;
                        if (t < 2 / 2.75) return 7.5625 * (t -= 1.5 / 2.75) * t + .75;
                        if (t < 2.5 / 2.75) return 7.5625 * (t -= 2.25 / 2.75) * t + .9375;
                        return 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
                    },
                    easeInOutBounce: function(t) {
                        if (t < .5) return .5 * effects.easeInBounce(2 * t);
                        return .5 * effects.easeOutBounce(2 * t - 1) + .5;
                    }
                };
                var helpers_easing = {
                    effects
                };
                helpers_core.easingEffects = effects;
                var PI = Math.PI;
                var RAD_PER_DEG = PI / 180;
                var DOUBLE_PI = 2 * PI;
                var HALF_PI = PI / 2;
                var QUARTER_PI = PI / 4;
                var TWO_THIRDS_PI = 2 * PI / 3;
                var exports$1 = {
                    clear: function(chart) {
                        chart.ctx.clearRect(0, 0, chart.width, chart.height);
                    },
                    roundedRect: function(ctx, x, y, width, height, radius) {
                        if (radius) {
                            var r = Math.min(radius, height / 2, width / 2);
                            var left = x + r;
                            var top = y + r;
                            var right = x + width - r;
                            var bottom = y + height - r;
                            ctx.moveTo(x, top);
                            if (left < right && top < bottom) {
                                ctx.arc(left, top, r, -PI, -HALF_PI);
                                ctx.arc(right, top, r, -HALF_PI, 0);
                                ctx.arc(right, bottom, r, 0, HALF_PI);
                                ctx.arc(left, bottom, r, HALF_PI, PI);
                            } else if (left < right) {
                                ctx.moveTo(left, y);
                                ctx.arc(right, top, r, -HALF_PI, HALF_PI);
                                ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);
                            } else if (top < bottom) {
                                ctx.arc(left, top, r, -PI, 0);
                                ctx.arc(left, bottom, r, 0, PI);
                            } else ctx.arc(left, top, r, -PI, PI);
                            ctx.closePath();
                            ctx.moveTo(x, y);
                        } else ctx.rect(x, y, width, height);
                    },
                    drawPoint: function(ctx, style, radius, x, y, rotation) {
                        var type, xOffset, yOffset, size, cornerRadius;
                        var rad = (rotation || 0) * RAD_PER_DEG;
                        if (style && "object" === typeof style) {
                            type = style.toString();
                            if ("[object HTMLImageElement]" === type || "[object HTMLCanvasElement]" === type) {
                                ctx.save();
                                ctx.translate(x, y);
                                ctx.rotate(rad);
                                ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
                                ctx.restore();
                                return;
                            }
                        }
                        if (isNaN(radius) || radius <= 0) return;
                        ctx.beginPath();
                        switch (style) {
                          default:
                            ctx.arc(x, y, radius, 0, DOUBLE_PI);
                            ctx.closePath();
                            break;

                          case "triangle":
                            ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
                            rad += TWO_THIRDS_PI;
                            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
                            rad += TWO_THIRDS_PI;
                            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
                            ctx.closePath();
                            break;

                          case "rectRounded":
                            cornerRadius = .516 * radius;
                            size = radius - cornerRadius;
                            xOffset = Math.cos(rad + QUARTER_PI) * size;
                            yOffset = Math.sin(rad + QUARTER_PI) * size;
                            ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
                            ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
                            ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
                            ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
                            ctx.closePath();
                            break;

                          case "rect":
                            if (!rotation) {
                                size = Math.SQRT1_2 * radius;
                                ctx.rect(x - size, y - size, 2 * size, 2 * size);
                                break;
                            }
                            rad += QUARTER_PI;

                          case "rectRot":
                            xOffset = Math.cos(rad) * radius;
                            yOffset = Math.sin(rad) * radius;
                            ctx.moveTo(x - xOffset, y - yOffset);
                            ctx.lineTo(x + yOffset, y - xOffset);
                            ctx.lineTo(x + xOffset, y + yOffset);
                            ctx.lineTo(x - yOffset, y + xOffset);
                            ctx.closePath();
                            break;

                          case "crossRot":
                            rad += QUARTER_PI;

                          case "cross":
                            xOffset = Math.cos(rad) * radius;
                            yOffset = Math.sin(rad) * radius;
                            ctx.moveTo(x - xOffset, y - yOffset);
                            ctx.lineTo(x + xOffset, y + yOffset);
                            ctx.moveTo(x + yOffset, y - xOffset);
                            ctx.lineTo(x - yOffset, y + xOffset);
                            break;

                          case "star":
                            xOffset = Math.cos(rad) * radius;
                            yOffset = Math.sin(rad) * radius;
                            ctx.moveTo(x - xOffset, y - yOffset);
                            ctx.lineTo(x + xOffset, y + yOffset);
                            ctx.moveTo(x + yOffset, y - xOffset);
                            ctx.lineTo(x - yOffset, y + xOffset);
                            rad += QUARTER_PI;
                            xOffset = Math.cos(rad) * radius;
                            yOffset = Math.sin(rad) * radius;
                            ctx.moveTo(x - xOffset, y - yOffset);
                            ctx.lineTo(x + xOffset, y + yOffset);
                            ctx.moveTo(x + yOffset, y - xOffset);
                            ctx.lineTo(x - yOffset, y + xOffset);
                            break;

                          case "line":
                            xOffset = Math.cos(rad) * radius;
                            yOffset = Math.sin(rad) * radius;
                            ctx.moveTo(x - xOffset, y - yOffset);
                            ctx.lineTo(x + xOffset, y + yOffset);
                            break;

                          case "dash":
                            ctx.moveTo(x, y);
                            ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
                            break;
                        }
                        ctx.fill();
                        ctx.stroke();
                    },
                    _isPointInArea: function(point, area) {
                        var epsilon = 1e-6;
                        return point.x > area.left - epsilon && point.x < area.right + epsilon && point.y > area.top - epsilon && point.y < area.bottom + epsilon;
                    },
                    clipArea: function(ctx, area) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
                        ctx.clip();
                    },
                    unclipArea: function(ctx) {
                        ctx.restore();
                    },
                    lineTo: function(ctx, previous, target, flip) {
                        var stepped = target.steppedLine;
                        if (stepped) {
                            if ("middle" === stepped) {
                                var midpoint = (previous.x + target.x) / 2;
                                ctx.lineTo(midpoint, flip ? target.y : previous.y);
                                ctx.lineTo(midpoint, flip ? previous.y : target.y);
                            } else if ("after" === stepped && !flip || "after" !== stepped && flip) ctx.lineTo(previous.x, target.y); else ctx.lineTo(target.x, previous.y);
                            ctx.lineTo(target.x, target.y);
                            return;
                        }
                        if (!target.tension) {
                            ctx.lineTo(target.x, target.y);
                            return;
                        }
                        ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);
                    }
                };
                var helpers_canvas = exports$1;
                helpers_core.clear = exports$1.clear;
                helpers_core.drawRoundedRectangle = function(ctx) {
                    ctx.beginPath();
                    exports$1.roundedRect.apply(exports$1, arguments);
                };
                var defaults = {
                    _set: function(scope, values) {
                        return helpers_core.merge(this[scope] || (this[scope] = {}), values);
                    }
                };
                defaults._set("global", {
                    defaultColor: "rgba(0,0,0,0.1)",
                    defaultFontColor: "#666",
                    defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                    defaultFontSize: 12,
                    defaultFontStyle: "normal",
                    defaultLineHeight: 1.2,
                    showLines: true
                });
                var core_defaults = defaults;
                var valueOrDefault = helpers_core.valueOrDefault;
                function toFontString(font) {
                    if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) return null;
                    return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
                }
                var helpers_options = {
                    toLineHeight: function(value, size) {
                        var matches = ("" + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
                        if (!matches || "normal" === matches[1]) return 1.2 * size;
                        value = +matches[2];
                        switch (matches[3]) {
                          case "px":
                            return value;

                          case "%":
                            value /= 100;
                            break;
                        }
                        return size * value;
                    },
                    toPadding: function(value) {
                        var t, r, b, l;
                        if (helpers_core.isObject(value)) {
                            t = +value.top || 0;
                            r = +value.right || 0;
                            b = +value.bottom || 0;
                            l = +value.left || 0;
                        } else t = r = b = l = +value || 0;
                        return {
                            top: t,
                            right: r,
                            bottom: b,
                            left: l,
                            height: t + b,
                            width: l + r
                        };
                    },
                    _parseFont: function(options) {
                        var globalDefaults = core_defaults.global;
                        var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
                        var font = {
                            family: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),
                            lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight), size),
                            size,
                            style: valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle),
                            weight: null,
                            string: ""
                        };
                        font.string = toFontString(font);
                        return font;
                    },
                    resolve: function(inputs, context, index, info) {
                        var cacheable = true;
                        var i, ilen, value;
                        for (i = 0, ilen = inputs.length; i < ilen; ++i) {
                            value = inputs[i];
                            if (void 0 === value) continue;
                            if (void 0 !== context && "function" === typeof value) {
                                value = value(context);
                                cacheable = false;
                            }
                            if (void 0 !== index && helpers_core.isArray(value)) {
                                value = value[index];
                                cacheable = false;
                            }
                            if (void 0 !== value) {
                                if (info && !cacheable) info.cacheable = false;
                                return value;
                            }
                        }
                    }
                };
                var exports$2 = {
                    _factorize: function(value) {
                        var result = [];
                        var sqrt = Math.sqrt(value);
                        var i;
                        for (i = 1; i < sqrt; i++) if (value % i === 0) {
                            result.push(i);
                            result.push(value / i);
                        }
                        if (sqrt === (0 | sqrt)) result.push(sqrt);
                        result.sort((function(a, b) {
                            return a - b;
                        })).pop();
                        return result;
                    },
                    log10: Math.log10 || function(x) {
                        var exponent = Math.log(x) * Math.LOG10E;
                        var powerOf10 = Math.round(exponent);
                        var isPowerOf10 = x === Math.pow(10, powerOf10);
                        return isPowerOf10 ? powerOf10 : exponent;
                    }
                };
                var helpers_math = exports$2;
                helpers_core.log10 = exports$2.log10;
                var getRtlAdapter = function(rectX, width) {
                    return {
                        x: function(x) {
                            return rectX + rectX + width - x;
                        },
                        setWidth: function(w) {
                            width = w;
                        },
                        textAlign: function(align) {
                            if ("center" === align) return align;
                            return "right" === align ? "left" : "right";
                        },
                        xPlus: function(x, value) {
                            return x - value;
                        },
                        leftForLtr: function(x, itemWidth) {
                            return x - itemWidth;
                        }
                    };
                };
                var getLtrAdapter = function() {
                    return {
                        x: function(x) {
                            return x;
                        },
                        setWidth: function(w) {},
                        textAlign: function(align) {
                            return align;
                        },
                        xPlus: function(x, value) {
                            return x + value;
                        },
                        leftForLtr: function(x, _itemWidth) {
                            return x;
                        }
                    };
                };
                var getAdapter = function(rtl, rectX, width) {
                    return rtl ? getRtlAdapter(rectX, width) : getLtrAdapter();
                };
                var overrideTextDirection = function(ctx, direction) {
                    var style, original;
                    if ("ltr" === direction || "rtl" === direction) {
                        style = ctx.canvas.style;
                        original = [ style.getPropertyValue("direction"), style.getPropertyPriority("direction") ];
                        style.setProperty("direction", direction, "important");
                        ctx.prevTextDirection = original;
                    }
                };
                var restoreTextDirection = function(ctx) {
                    var original = ctx.prevTextDirection;
                    if (void 0 !== original) {
                        delete ctx.prevTextDirection;
                        ctx.canvas.style.setProperty("direction", original[0], original[1]);
                    }
                };
                var helpers_rtl = {
                    getRtlAdapter: getAdapter,
                    overrideTextDirection,
                    restoreTextDirection
                };
                var helpers$1 = helpers_core;
                var easing = helpers_easing;
                var canvas = helpers_canvas;
                var options = helpers_options;
                var math = helpers_math;
                var rtl = helpers_rtl;
                helpers$1.easing = easing;
                helpers$1.canvas = canvas;
                helpers$1.options = options;
                helpers$1.math = math;
                helpers$1.rtl = rtl;
                function interpolate(start, view, model, ease) {
                    var keys = Object.keys(model);
                    var i, ilen, key, actual, origin, target, type, c0, c1;
                    for (i = 0, ilen = keys.length; i < ilen; ++i) {
                        key = keys[i];
                        target = model[key];
                        if (!view.hasOwnProperty(key)) view[key] = target;
                        actual = view[key];
                        if (actual === target || "_" === key[0]) continue;
                        if (!start.hasOwnProperty(key)) start[key] = actual;
                        origin = start[key];
                        type = typeof target;
                        if (type === typeof origin) if ("string" === type) {
                            c0 = chartjsColor(origin);
                            if (c0.valid) {
                                c1 = chartjsColor(target);
                                if (c1.valid) {
                                    view[key] = c1.mix(c0, ease).rgbString();
                                    continue;
                                }
                            }
                        } else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {
                            view[key] = origin + (target - origin) * ease;
                            continue;
                        }
                        view[key] = target;
                    }
                }
                var Element = function(configuration) {
                    helpers$1.extend(this, configuration);
                    this.initialize.apply(this, arguments);
                };
                helpers$1.extend(Element.prototype, {
                    _type: void 0,
                    initialize: function() {
                        this.hidden = false;
                    },
                    pivot: function() {
                        var me = this;
                        if (!me._view) me._view = helpers$1.extend({}, me._model);
                        me._start = {};
                        return me;
                    },
                    transition: function(ease) {
                        var me = this;
                        var model = me._model;
                        var start = me._start;
                        var view = me._view;
                        if (!model || 1 === ease) {
                            me._view = helpers$1.extend({}, model);
                            me._start = null;
                            return me;
                        }
                        if (!view) view = me._view = {};
                        if (!start) start = me._start = {};
                        interpolate(start, view, model, ease);
                        return me;
                    },
                    tooltipPosition: function() {
                        return {
                            x: this._model.x,
                            y: this._model.y
                        };
                    },
                    hasValue: function() {
                        return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);
                    }
                });
                Element.extend = helpers$1.inherits;
                var core_element = Element;
                var exports$3 = core_element.extend({
                    chart: null,
                    currentStep: 0,
                    numSteps: 60,
                    easing: "",
                    render: null,
                    onAnimationProgress: null,
                    onAnimationComplete: null
                });
                var core_animation = exports$3;
                Object.defineProperty(exports$3.prototype, "animationObject", {
                    get: function() {
                        return this;
                    }
                });
                Object.defineProperty(exports$3.prototype, "chartInstance", {
                    get: function() {
                        return this.chart;
                    },
                    set: function(value) {
                        this.chart = value;
                    }
                });
                core_defaults._set("global", {
                    animation: {
                        duration: 1e3,
                        easing: "easeOutQuart",
                        onProgress: helpers$1.noop,
                        onComplete: helpers$1.noop
                    }
                });
                var core_animations = {
                    animations: [],
                    request: null,
                    addAnimation: function(chart, animation, duration, lazy) {
                        var animations = this.animations;
                        var i, ilen;
                        animation.chart = chart;
                        animation.startTime = Date.now();
                        animation.duration = duration;
                        if (!lazy) chart.animating = true;
                        for (i = 0, ilen = animations.length; i < ilen; ++i) if (animations[i].chart === chart) {
                            animations[i] = animation;
                            return;
                        }
                        animations.push(animation);
                        if (1 === animations.length) this.requestAnimationFrame();
                    },
                    cancelAnimation: function(chart) {
                        var index = helpers$1.findIndex(this.animations, (function(animation) {
                            return animation.chart === chart;
                        }));
                        if (-1 !== index) {
                            this.animations.splice(index, 1);
                            chart.animating = false;
                        }
                    },
                    requestAnimationFrame: function() {
                        var me = this;
                        if (null === me.request) me.request = helpers$1.requestAnimFrame.call(window, (function() {
                            me.request = null;
                            me.startDigest();
                        }));
                    },
                    startDigest: function() {
                        var me = this;
                        me.advance();
                        if (me.animations.length > 0) me.requestAnimationFrame();
                    },
                    advance: function() {
                        var animations = this.animations;
                        var animation, chart, numSteps, nextStep;
                        var i = 0;
                        while (i < animations.length) {
                            animation = animations[i];
                            chart = animation.chart;
                            numSteps = animation.numSteps;
                            nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;
                            animation.currentStep = Math.min(nextStep, numSteps);
                            helpers$1.callback(animation.render, [ chart, animation ], chart);
                            helpers$1.callback(animation.onAnimationProgress, [ animation ], chart);
                            if (animation.currentStep >= numSteps) {
                                helpers$1.callback(animation.onAnimationComplete, [ animation ], chart);
                                chart.animating = false;
                                animations.splice(i, 1);
                            } else ++i;
                        }
                    }
                };
                var resolve = helpers$1.options.resolve;
                var arrayEvents = [ "push", "pop", "shift", "splice", "unshift" ];
                function listenArrayEvents(array, listener) {
                    if (array._chartjs) {
                        array._chartjs.listeners.push(listener);
                        return;
                    }
                    Object.defineProperty(array, "_chartjs", {
                        configurable: true,
                        enumerable: false,
                        value: {
                            listeners: [ listener ]
                        }
                    });
                    arrayEvents.forEach((function(key) {
                        var method = "onData" + key.charAt(0).toUpperCase() + key.slice(1);
                        var base = array[key];
                        Object.defineProperty(array, key, {
                            configurable: true,
                            enumerable: false,
                            value: function() {
                                var args = Array.prototype.slice.call(arguments);
                                var res = base.apply(this, args);
                                helpers$1.each(array._chartjs.listeners, (function(object) {
                                    if ("function" === typeof object[method]) object[method].apply(object, args);
                                }));
                                return res;
                            }
                        });
                    }));
                }
                function unlistenArrayEvents(array, listener) {
                    var stub = array._chartjs;
                    if (!stub) return;
                    var listeners = stub.listeners;
                    var index = listeners.indexOf(listener);
                    if (-1 !== index) listeners.splice(index, 1);
                    if (listeners.length > 0) return;
                    arrayEvents.forEach((function(key) {
                        delete array[key];
                    }));
                    delete array._chartjs;
                }
                var DatasetController = function(chart, datasetIndex) {
                    this.initialize(chart, datasetIndex);
                };
                helpers$1.extend(DatasetController.prototype, {
                    datasetElementType: null,
                    dataElementType: null,
                    _datasetElementOptions: [ "backgroundColor", "borderCapStyle", "borderColor", "borderDash", "borderDashOffset", "borderJoinStyle", "borderWidth" ],
                    _dataElementOptions: [ "backgroundColor", "borderColor", "borderWidth", "pointStyle" ],
                    initialize: function(chart, datasetIndex) {
                        var me = this;
                        me.chart = chart;
                        me.index = datasetIndex;
                        me.linkScales();
                        me.addElements();
                        me._type = me.getMeta().type;
                    },
                    updateIndex: function(datasetIndex) {
                        this.index = datasetIndex;
                    },
                    linkScales: function() {
                        var me = this;
                        var meta = me.getMeta();
                        var chart = me.chart;
                        var scales = chart.scales;
                        var dataset = me.getDataset();
                        var scalesOpts = chart.options.scales;
                        if (null === meta.xAxisID || !(meta.xAxisID in scales) || dataset.xAxisID) meta.xAxisID = dataset.xAxisID || scalesOpts.xAxes[0].id;
                        if (null === meta.yAxisID || !(meta.yAxisID in scales) || dataset.yAxisID) meta.yAxisID = dataset.yAxisID || scalesOpts.yAxes[0].id;
                    },
                    getDataset: function() {
                        return this.chart.data.datasets[this.index];
                    },
                    getMeta: function() {
                        return this.chart.getDatasetMeta(this.index);
                    },
                    getScaleForId: function(scaleID) {
                        return this.chart.scales[scaleID];
                    },
                    _getValueScaleId: function() {
                        return this.getMeta().yAxisID;
                    },
                    _getIndexScaleId: function() {
                        return this.getMeta().xAxisID;
                    },
                    _getValueScale: function() {
                        return this.getScaleForId(this._getValueScaleId());
                    },
                    _getIndexScale: function() {
                        return this.getScaleForId(this._getIndexScaleId());
                    },
                    reset: function() {
                        this._update(true);
                    },
                    destroy: function() {
                        if (this._data) unlistenArrayEvents(this._data, this);
                    },
                    createMetaDataset: function() {
                        var me = this;
                        var type = me.datasetElementType;
                        return type && new type({
                            _chart: me.chart,
                            _datasetIndex: me.index
                        });
                    },
                    createMetaData: function(index) {
                        var me = this;
                        var type = me.dataElementType;
                        return type && new type({
                            _chart: me.chart,
                            _datasetIndex: me.index,
                            _index: index
                        });
                    },
                    addElements: function() {
                        var me = this;
                        var meta = me.getMeta();
                        var data = me.getDataset().data || [];
                        var metaData = meta.data;
                        var i, ilen;
                        for (i = 0, ilen = data.length; i < ilen; ++i) metaData[i] = metaData[i] || me.createMetaData(i);
                        meta.dataset = meta.dataset || me.createMetaDataset();
                    },
                    addElementAndReset: function(index) {
                        var element = this.createMetaData(index);
                        this.getMeta().data.splice(index, 0, element);
                        this.updateElement(element, index, true);
                    },
                    buildOrUpdateElements: function() {
                        var me = this;
                        var dataset = me.getDataset();
                        var data = dataset.data || (dataset.data = []);
                        if (me._data !== data) {
                            if (me._data) unlistenArrayEvents(me._data, me);
                            if (data && Object.isExtensible(data)) listenArrayEvents(data, me);
                            me._data = data;
                        }
                        me.resyncElements();
                    },
                    _configure: function() {
                        var me = this;
                        me._config = helpers$1.merge(Object.create(null), [ me.chart.options.datasets[me._type], me.getDataset() ], {
                            merger: function(key, target, source) {
                                if ("_meta" !== key && "data" !== key) helpers$1._merger(key, target, source);
                            }
                        });
                    },
                    _update: function(reset) {
                        var me = this;
                        me._configure();
                        me._cachedDataOpts = null;
                        me.update(reset);
                    },
                    update: helpers$1.noop,
                    transition: function(easingValue) {
                        var meta = this.getMeta();
                        var elements = meta.data || [];
                        var ilen = elements.length;
                        var i = 0;
                        for (;i < ilen; ++i) elements[i].transition(easingValue);
                        if (meta.dataset) meta.dataset.transition(easingValue);
                    },
                    draw: function() {
                        var meta = this.getMeta();
                        var elements = meta.data || [];
                        var ilen = elements.length;
                        var i = 0;
                        if (meta.dataset) meta.dataset.draw();
                        for (;i < ilen; ++i) elements[i].draw();
                    },
                    getStyle: function(index) {
                        var me = this;
                        var meta = me.getMeta();
                        var dataset = meta.dataset;
                        var style;
                        me._configure();
                        if (dataset && void 0 === index) style = me._resolveDatasetElementOptions(dataset || {}); else {
                            index = index || 0;
                            style = me._resolveDataElementOptions(meta.data[index] || {}, index);
                        }
                        if (false === style.fill || null === style.fill) style.backgroundColor = style.borderColor;
                        return style;
                    },
                    _resolveDatasetElementOptions: function(element, hover) {
                        var me = this;
                        var chart = me.chart;
                        var datasetOpts = me._config;
                        var custom = element.custom || {};
                        var options = chart.options.elements[me.datasetElementType.prototype._type] || {};
                        var elementOptions = me._datasetElementOptions;
                        var values = {};
                        var i, ilen, key, readKey;
                        var context = {
                            chart,
                            dataset: me.getDataset(),
                            datasetIndex: me.index,
                            hover
                        };
                        for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {
                            key = elementOptions[i];
                            readKey = hover ? "hover" + key.charAt(0).toUpperCase() + key.slice(1) : key;
                            values[key] = resolve([ custom[readKey], datasetOpts[readKey], options[readKey] ], context);
                        }
                        return values;
                    },
                    _resolveDataElementOptions: function(element, index) {
                        var me = this;
                        var custom = element && element.custom;
                        var cached = me._cachedDataOpts;
                        if (cached && !custom) return cached;
                        var chart = me.chart;
                        var datasetOpts = me._config;
                        var options = chart.options.elements[me.dataElementType.prototype._type] || {};
                        var elementOptions = me._dataElementOptions;
                        var values = {};
                        var context = {
                            chart,
                            dataIndex: index,
                            dataset: me.getDataset(),
                            datasetIndex: me.index
                        };
                        var info = {
                            cacheable: !custom
                        };
                        var keys, i, ilen, key;
                        custom = custom || {};
                        if (helpers$1.isArray(elementOptions)) for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {
                            key = elementOptions[i];
                            values[key] = resolve([ custom[key], datasetOpts[key], options[key] ], context, index, info);
                        } else {
                            keys = Object.keys(elementOptions);
                            for (i = 0, ilen = keys.length; i < ilen; ++i) {
                                key = keys[i];
                                values[key] = resolve([ custom[key], datasetOpts[elementOptions[key]], datasetOpts[key], options[key] ], context, index, info);
                            }
                        }
                        if (info.cacheable) me._cachedDataOpts = Object.freeze(values);
                        return values;
                    },
                    removeHoverStyle: function(element) {
                        helpers$1.merge(element._model, element.$previousStyle || {});
                        delete element.$previousStyle;
                    },
                    setHoverStyle: function(element) {
                        var dataset = this.chart.data.datasets[element._datasetIndex];
                        var index = element._index;
                        var custom = element.custom || {};
                        var model = element._model;
                        var getHoverColor = helpers$1.getHoverColor;
                        element.$previousStyle = {
                            backgroundColor: model.backgroundColor,
                            borderColor: model.borderColor,
                            borderWidth: model.borderWidth
                        };
                        model.backgroundColor = resolve([ custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor) ], void 0, index);
                        model.borderColor = resolve([ custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor) ], void 0, index);
                        model.borderWidth = resolve([ custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth ], void 0, index);
                    },
                    _removeDatasetHoverStyle: function() {
                        var element = this.getMeta().dataset;
                        if (element) this.removeHoverStyle(element);
                    },
                    _setDatasetHoverStyle: function() {
                        var element = this.getMeta().dataset;
                        var prev = {};
                        var i, ilen, key, keys, hoverOptions, model;
                        if (!element) return;
                        model = element._model;
                        hoverOptions = this._resolveDatasetElementOptions(element, true);
                        keys = Object.keys(hoverOptions);
                        for (i = 0, ilen = keys.length; i < ilen; ++i) {
                            key = keys[i];
                            prev[key] = model[key];
                            model[key] = hoverOptions[key];
                        }
                        element.$previousStyle = prev;
                    },
                    resyncElements: function() {
                        var me = this;
                        var meta = me.getMeta();
                        var data = me.getDataset().data;
                        var numMeta = meta.data.length;
                        var numData = data.length;
                        if (numData < numMeta) meta.data.splice(numData, numMeta - numData); else if (numData > numMeta) me.insertElements(numMeta, numData - numMeta);
                    },
                    insertElements: function(start, count) {
                        for (var i = 0; i < count; ++i) this.addElementAndReset(start + i);
                    },
                    onDataPush: function() {
                        var count = arguments.length;
                        this.insertElements(this.getDataset().data.length - count, count);
                    },
                    onDataPop: function() {
                        this.getMeta().data.pop();
                    },
                    onDataShift: function() {
                        this.getMeta().data.shift();
                    },
                    onDataSplice: function(start, count) {
                        this.getMeta().data.splice(start, count);
                        this.insertElements(start, arguments.length - 2);
                    },
                    onDataUnshift: function() {
                        this.insertElements(0, arguments.length);
                    }
                });
                DatasetController.extend = helpers$1.inherits;
                var core_datasetController = DatasetController;
                var TAU = 2 * Math.PI;
                core_defaults._set("global", {
                    elements: {
                        arc: {
                            backgroundColor: core_defaults.global.defaultColor,
                            borderColor: "#fff",
                            borderWidth: 2,
                            borderAlign: "center"
                        }
                    }
                });
                function clipArc(ctx, arc) {
                    var startAngle = arc.startAngle;
                    var endAngle = arc.endAngle;
                    var pixelMargin = arc.pixelMargin;
                    var angleMargin = pixelMargin / arc.outerRadius;
                    var x = arc.x;
                    var y = arc.y;
                    ctx.beginPath();
                    ctx.arc(x, y, arc.outerRadius, startAngle - angleMargin, endAngle + angleMargin);
                    if (arc.innerRadius > pixelMargin) {
                        angleMargin = pixelMargin / arc.innerRadius;
                        ctx.arc(x, y, arc.innerRadius - pixelMargin, endAngle + angleMargin, startAngle - angleMargin, true);
                    } else ctx.arc(x, y, pixelMargin, endAngle + Math.PI / 2, startAngle - Math.PI / 2);
                    ctx.closePath();
                    ctx.clip();
                }
                function drawFullCircleBorders(ctx, vm, arc, inner) {
                    var endAngle = arc.endAngle;
                    var i;
                    if (inner) {
                        arc.endAngle = arc.startAngle + TAU;
                        clipArc(ctx, arc);
                        arc.endAngle = endAngle;
                        if (arc.endAngle === arc.startAngle && arc.fullCircles) {
                            arc.endAngle += TAU;
                            arc.fullCircles--;
                        }
                    }
                    ctx.beginPath();
                    ctx.arc(arc.x, arc.y, arc.innerRadius, arc.startAngle + TAU, arc.startAngle, true);
                    for (i = 0; i < arc.fullCircles; ++i) ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.startAngle + TAU);
                    for (i = 0; i < arc.fullCircles; ++i) ctx.stroke();
                }
                function drawBorder(ctx, vm, arc) {
                    var inner = "inner" === vm.borderAlign;
                    if (inner) {
                        ctx.lineWidth = 2 * vm.borderWidth;
                        ctx.lineJoin = "round";
                    } else {
                        ctx.lineWidth = vm.borderWidth;
                        ctx.lineJoin = "bevel";
                    }
                    if (arc.fullCircles) drawFullCircleBorders(ctx, vm, arc, inner);
                    if (inner) clipArc(ctx, arc);
                    ctx.beginPath();
                    ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.endAngle);
                    ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
                    ctx.closePath();
                    ctx.stroke();
                }
                var element_arc = core_element.extend({
                    _type: "arc",
                    inLabelRange: function(mouseX) {
                        var vm = this._view;
                        if (vm) return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
                        return false;
                    },
                    inRange: function(chartX, chartY) {
                        var vm = this._view;
                        if (vm) {
                            var pointRelativePosition = helpers$1.getAngleFromPoint(vm, {
                                x: chartX,
                                y: chartY
                            });
                            var angle = pointRelativePosition.angle;
                            var distance = pointRelativePosition.distance;
                            var startAngle = vm.startAngle;
                            var endAngle = vm.endAngle;
                            while (endAngle < startAngle) endAngle += TAU;
                            while (angle > endAngle) angle -= TAU;
                            while (angle < startAngle) angle += TAU;
                            var betweenAngles = angle >= startAngle && angle <= endAngle;
                            var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
                            return betweenAngles && withinRadius;
                        }
                        return false;
                    },
                    getCenterPoint: function() {
                        var vm = this._view;
                        var halfAngle = (vm.startAngle + vm.endAngle) / 2;
                        var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
                        return {
                            x: vm.x + Math.cos(halfAngle) * halfRadius,
                            y: vm.y + Math.sin(halfAngle) * halfRadius
                        };
                    },
                    getArea: function() {
                        var vm = this._view;
                        return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
                    },
                    tooltipPosition: function() {
                        var vm = this._view;
                        var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
                        var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
                        return {
                            x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
                            y: vm.y + Math.sin(centreAngle) * rangeFromCentre
                        };
                    },
                    draw: function() {
                        var ctx = this._chart.ctx;
                        var vm = this._view;
                        var pixelMargin = "inner" === vm.borderAlign ? .33 : 0;
                        var arc = {
                            x: vm.x,
                            y: vm.y,
                            innerRadius: vm.innerRadius,
                            outerRadius: Math.max(vm.outerRadius - pixelMargin, 0),
                            pixelMargin,
                            startAngle: vm.startAngle,
                            endAngle: vm.endAngle,
                            fullCircles: Math.floor(vm.circumference / TAU)
                        };
                        var i;
                        ctx.save();
                        ctx.fillStyle = vm.backgroundColor;
                        ctx.strokeStyle = vm.borderColor;
                        if (arc.fullCircles) {
                            arc.endAngle = arc.startAngle + TAU;
                            ctx.beginPath();
                            ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);
                            ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
                            ctx.closePath();
                            for (i = 0; i < arc.fullCircles; ++i) ctx.fill();
                            arc.endAngle = arc.startAngle + vm.circumference % TAU;
                        }
                        ctx.beginPath();
                        ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);
                        ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
                        ctx.closePath();
                        ctx.fill();
                        if (vm.borderWidth) drawBorder(ctx, vm, arc);
                        ctx.restore();
                    }
                });
                var valueOrDefault$1 = helpers$1.valueOrDefault;
                var defaultColor = core_defaults.global.defaultColor;
                core_defaults._set("global", {
                    elements: {
                        line: {
                            tension: .4,
                            backgroundColor: defaultColor,
                            borderWidth: 3,
                            borderColor: defaultColor,
                            borderCapStyle: "butt",
                            borderDash: [],
                            borderDashOffset: 0,
                            borderJoinStyle: "miter",
                            capBezierPoints: true,
                            fill: true
                        }
                    }
                });
                var element_line = core_element.extend({
                    _type: "line",
                    draw: function() {
                        var me = this;
                        var vm = me._view;
                        var ctx = me._chart.ctx;
                        var spanGaps = vm.spanGaps;
                        var points = me._children.slice();
                        var globalDefaults = core_defaults.global;
                        var globalOptionLineElements = globalDefaults.elements.line;
                        var lastDrawnIndex = -1;
                        var closePath = me._loop;
                        var index, previous, currentVM;
                        if (!points.length) return;
                        if (me._loop) {
                            for (index = 0; index < points.length; ++index) {
                                previous = helpers$1.previousItem(points, index);
                                if (!points[index]._view.skip && previous._view.skip) {
                                    points = points.slice(index).concat(points.slice(0, index));
                                    closePath = spanGaps;
                                    break;
                                }
                            }
                            if (closePath) points.push(points[0]);
                        }
                        ctx.save();
                        ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;
                        if (ctx.setLineDash) ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
                        ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);
                        ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
                        ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);
                        ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;
                        ctx.beginPath();
                        currentVM = points[0]._view;
                        if (!currentVM.skip) {
                            ctx.moveTo(currentVM.x, currentVM.y);
                            lastDrawnIndex = 0;
                        }
                        for (index = 1; index < points.length; ++index) {
                            currentVM = points[index]._view;
                            previous = -1 === lastDrawnIndex ? helpers$1.previousItem(points, index) : points[lastDrawnIndex];
                            if (!currentVM.skip) {
                                if (lastDrawnIndex !== index - 1 && !spanGaps || -1 === lastDrawnIndex) ctx.moveTo(currentVM.x, currentVM.y); else helpers$1.canvas.lineTo(ctx, previous._view, currentVM);
                                lastDrawnIndex = index;
                            }
                        }
                        if (closePath) ctx.closePath();
                        ctx.stroke();
                        ctx.restore();
                    }
                });
                var valueOrDefault$2 = helpers$1.valueOrDefault;
                var defaultColor$1 = core_defaults.global.defaultColor;
                core_defaults._set("global", {
                    elements: {
                        point: {
                            radius: 3,
                            pointStyle: "circle",
                            backgroundColor: defaultColor$1,
                            borderColor: defaultColor$1,
                            borderWidth: 1,
                            hitRadius: 1,
                            hoverRadius: 4,
                            hoverBorderWidth: 1
                        }
                    }
                });
                function xRange(mouseX) {
                    var vm = this._view;
                    return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;
                }
                function yRange(mouseY) {
                    var vm = this._view;
                    return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;
                }
                var element_point = core_element.extend({
                    _type: "point",
                    inRange: function(mouseX, mouseY) {
                        var vm = this._view;
                        return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
                    },
                    inLabelRange: xRange,
                    inXRange: xRange,
                    inYRange: yRange,
                    getCenterPoint: function() {
                        var vm = this._view;
                        return {
                            x: vm.x,
                            y: vm.y
                        };
                    },
                    getArea: function() {
                        return Math.PI * Math.pow(this._view.radius, 2);
                    },
                    tooltipPosition: function() {
                        var vm = this._view;
                        return {
                            x: vm.x,
                            y: vm.y,
                            padding: vm.radius + vm.borderWidth
                        };
                    },
                    draw: function(chartArea) {
                        var vm = this._view;
                        var ctx = this._chart.ctx;
                        var pointStyle = vm.pointStyle;
                        var rotation = vm.rotation;
                        var radius = vm.radius;
                        var x = vm.x;
                        var y = vm.y;
                        var globalDefaults = core_defaults.global;
                        var defaultColor = globalDefaults.defaultColor;
                        if (vm.skip) return;
                        if (void 0 === chartArea || helpers$1.canvas._isPointInArea(vm, chartArea)) {
                            ctx.strokeStyle = vm.borderColor || defaultColor;
                            ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);
                            ctx.fillStyle = vm.backgroundColor || defaultColor;
                            helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
                        }
                    }
                });
                var defaultColor$2 = core_defaults.global.defaultColor;
                core_defaults._set("global", {
                    elements: {
                        rectangle: {
                            backgroundColor: defaultColor$2,
                            borderColor: defaultColor$2,
                            borderSkipped: "bottom",
                            borderWidth: 0
                        }
                    }
                });
                function isVertical(vm) {
                    return vm && void 0 !== vm.width;
                }
                function getBarBounds(vm) {
                    var x1, x2, y1, y2, half;
                    if (isVertical(vm)) {
                        half = vm.width / 2;
                        x1 = vm.x - half;
                        x2 = vm.x + half;
                        y1 = Math.min(vm.y, vm.base);
                        y2 = Math.max(vm.y, vm.base);
                    } else {
                        half = vm.height / 2;
                        x1 = Math.min(vm.x, vm.base);
                        x2 = Math.max(vm.x, vm.base);
                        y1 = vm.y - half;
                        y2 = vm.y + half;
                    }
                    return {
                        left: x1,
                        top: y1,
                        right: x2,
                        bottom: y2
                    };
                }
                function swap(orig, v1, v2) {
                    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
                }
                function parseBorderSkipped(vm) {
                    var edge = vm.borderSkipped;
                    var res = {};
                    if (!edge) return res;
                    if (vm.horizontal) {
                        if (vm.base > vm.x) edge = swap(edge, "left", "right");
                    } else if (vm.base < vm.y) edge = swap(edge, "bottom", "top");
                    res[edge] = true;
                    return res;
                }
                function parseBorderWidth(vm, maxW, maxH) {
                    var value = vm.borderWidth;
                    var skip = parseBorderSkipped(vm);
                    var t, r, b, l;
                    if (helpers$1.isObject(value)) {
                        t = +value.top || 0;
                        r = +value.right || 0;
                        b = +value.bottom || 0;
                        l = +value.left || 0;
                    } else t = r = b = l = +value || 0;
                    return {
                        t: skip.top || t < 0 ? 0 : t > maxH ? maxH : t,
                        r: skip.right || r < 0 ? 0 : r > maxW ? maxW : r,
                        b: skip.bottom || b < 0 ? 0 : b > maxH ? maxH : b,
                        l: skip.left || l < 0 ? 0 : l > maxW ? maxW : l
                    };
                }
                function boundingRects(vm) {
                    var bounds = getBarBounds(vm);
                    var width = bounds.right - bounds.left;
                    var height = bounds.bottom - bounds.top;
                    var border = parseBorderWidth(vm, width / 2, height / 2);
                    return {
                        outer: {
                            x: bounds.left,
                            y: bounds.top,
                            w: width,
                            h: height
                        },
                        inner: {
                            x: bounds.left + border.l,
                            y: bounds.top + border.t,
                            w: width - border.l - border.r,
                            h: height - border.t - border.b
                        }
                    };
                }
                function inRange(vm, x, y) {
                    var skipX = null === x;
                    var skipY = null === y;
                    var bounds = !vm || skipX && skipY ? false : getBarBounds(vm);
                    return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);
                }
                var element_rectangle = core_element.extend({
                    _type: "rectangle",
                    draw: function() {
                        var ctx = this._chart.ctx;
                        var vm = this._view;
                        var rects = boundingRects(vm);
                        var outer = rects.outer;
                        var inner = rects.inner;
                        ctx.fillStyle = vm.backgroundColor;
                        ctx.fillRect(outer.x, outer.y, outer.w, outer.h);
                        if (outer.w === inner.w && outer.h === inner.h) return;
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(outer.x, outer.y, outer.w, outer.h);
                        ctx.clip();
                        ctx.fillStyle = vm.borderColor;
                        ctx.rect(inner.x, inner.y, inner.w, inner.h);
                        ctx.fill("evenodd");
                        ctx.restore();
                    },
                    height: function() {
                        var vm = this._view;
                        return vm.base - vm.y;
                    },
                    inRange: function(mouseX, mouseY) {
                        return inRange(this._view, mouseX, mouseY);
                    },
                    inLabelRange: function(mouseX, mouseY) {
                        var vm = this._view;
                        return isVertical(vm) ? inRange(vm, mouseX, null) : inRange(vm, null, mouseY);
                    },
                    inXRange: function(mouseX) {
                        return inRange(this._view, mouseX, null);
                    },
                    inYRange: function(mouseY) {
                        return inRange(this._view, null, mouseY);
                    },
                    getCenterPoint: function() {
                        var vm = this._view;
                        var x, y;
                        if (isVertical(vm)) {
                            x = vm.x;
                            y = (vm.y + vm.base) / 2;
                        } else {
                            x = (vm.x + vm.base) / 2;
                            y = vm.y;
                        }
                        return {
                            x,
                            y
                        };
                    },
                    getArea: function() {
                        var vm = this._view;
                        return isVertical(vm) ? vm.width * Math.abs(vm.y - vm.base) : vm.height * Math.abs(vm.x - vm.base);
                    },
                    tooltipPosition: function() {
                        var vm = this._view;
                        return {
                            x: vm.x,
                            y: vm.y
                        };
                    }
                });
                var elements = {};
                var Arc = element_arc;
                var Line = element_line;
                var Point = element_point;
                var Rectangle = element_rectangle;
                elements.Arc = Arc;
                elements.Line = Line;
                elements.Point = Point;
                elements.Rectangle = Rectangle;
                var deprecated = helpers$1._deprecated;
                var valueOrDefault$3 = helpers$1.valueOrDefault;
                core_defaults._set("bar", {
                    hover: {
                        mode: "label"
                    },
                    scales: {
                        xAxes: [ {
                            type: "category",
                            offset: true,
                            gridLines: {
                                offsetGridLines: true
                            }
                        } ],
                        yAxes: [ {
                            type: "linear"
                        } ]
                    }
                });
                core_defaults._set("global", {
                    datasets: {
                        bar: {
                            categoryPercentage: .8,
                            barPercentage: .9
                        }
                    }
                });
                function computeMinSampleSize(scale, pixels) {
                    var min = scale._length;
                    var prev, curr, i, ilen;
                    for (i = 1, ilen = pixels.length; i < ilen; ++i) min = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));
                    for (i = 0, ilen = scale.getTicks().length; i < ilen; ++i) {
                        curr = scale.getPixelForTick(i);
                        min = i > 0 ? Math.min(min, Math.abs(curr - prev)) : min;
                        prev = curr;
                    }
                    return min;
                }
                function computeFitCategoryTraits(index, ruler, options) {
                    var thickness = options.barThickness;
                    var count = ruler.stackCount;
                    var curr = ruler.pixels[index];
                    var min = helpers$1.isNullOrUndef(thickness) ? computeMinSampleSize(ruler.scale, ruler.pixels) : -1;
                    var size, ratio;
                    if (helpers$1.isNullOrUndef(thickness)) {
                        size = min * options.categoryPercentage;
                        ratio = options.barPercentage;
                    } else {
                        size = thickness * count;
                        ratio = 1;
                    }
                    return {
                        chunk: size / count,
                        ratio,
                        start: curr - size / 2
                    };
                }
                function computeFlexCategoryTraits(index, ruler, options) {
                    var pixels = ruler.pixels;
                    var curr = pixels[index];
                    var prev = index > 0 ? pixels[index - 1] : null;
                    var next = index < pixels.length - 1 ? pixels[index + 1] : null;
                    var percent = options.categoryPercentage;
                    var start, size;
                    if (null === prev) prev = curr - (null === next ? ruler.end - ruler.start : next - curr);
                    if (null === next) next = curr + curr - prev;
                    start = curr - (curr - Math.min(prev, next)) / 2 * percent;
                    size = Math.abs(next - prev) / 2 * percent;
                    return {
                        chunk: size / ruler.stackCount,
                        ratio: options.barPercentage,
                        start
                    };
                }
                var controller_bar = core_datasetController.extend({
                    dataElementType: elements.Rectangle,
                    _dataElementOptions: [ "backgroundColor", "borderColor", "borderSkipped", "borderWidth", "barPercentage", "barThickness", "categoryPercentage", "maxBarThickness", "minBarLength" ],
                    initialize: function() {
                        var me = this;
                        var meta, scaleOpts;
                        core_datasetController.prototype.initialize.apply(me, arguments);
                        meta = me.getMeta();
                        meta.stack = me.getDataset().stack;
                        meta.bar = true;
                        scaleOpts = me._getIndexScale().options;
                        deprecated("bar chart", scaleOpts.barPercentage, "scales.[x/y]Axes.barPercentage", "dataset.barPercentage");
                        deprecated("bar chart", scaleOpts.barThickness, "scales.[x/y]Axes.barThickness", "dataset.barThickness");
                        deprecated("bar chart", scaleOpts.categoryPercentage, "scales.[x/y]Axes.categoryPercentage", "dataset.categoryPercentage");
                        deprecated("bar chart", me._getValueScale().options.minBarLength, "scales.[x/y]Axes.minBarLength", "dataset.minBarLength");
                        deprecated("bar chart", scaleOpts.maxBarThickness, "scales.[x/y]Axes.maxBarThickness", "dataset.maxBarThickness");
                    },
                    update: function(reset) {
                        var me = this;
                        var rects = me.getMeta().data;
                        var i, ilen;
                        me._ruler = me.getRuler();
                        for (i = 0, ilen = rects.length; i < ilen; ++i) me.updateElement(rects[i], i, reset);
                    },
                    updateElement: function(rectangle, index, reset) {
                        var me = this;
                        var meta = me.getMeta();
                        var dataset = me.getDataset();
                        var options = me._resolveDataElementOptions(rectangle, index);
                        rectangle._xScale = me.getScaleForId(meta.xAxisID);
                        rectangle._yScale = me.getScaleForId(meta.yAxisID);
                        rectangle._datasetIndex = me.index;
                        rectangle._index = index;
                        rectangle._model = {
                            backgroundColor: options.backgroundColor,
                            borderColor: options.borderColor,
                            borderSkipped: options.borderSkipped,
                            borderWidth: options.borderWidth,
                            datasetLabel: dataset.label,
                            label: me.chart.data.labels[index]
                        };
                        if (helpers$1.isArray(dataset.data[index])) rectangle._model.borderSkipped = null;
                        me._updateElementGeometry(rectangle, index, reset, options);
                        rectangle.pivot();
                    },
                    _updateElementGeometry: function(rectangle, index, reset, options) {
                        var me = this;
                        var model = rectangle._model;
                        var vscale = me._getValueScale();
                        var base = vscale.getBasePixel();
                        var horizontal = vscale.isHorizontal();
                        var ruler = me._ruler || me.getRuler();
                        var vpixels = me.calculateBarValuePixels(me.index, index, options);
                        var ipixels = me.calculateBarIndexPixels(me.index, index, ruler, options);
                        model.horizontal = horizontal;
                        model.base = reset ? base : vpixels.base;
                        model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
                        model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
                        model.height = horizontal ? ipixels.size : void 0;
                        model.width = horizontal ? void 0 : ipixels.size;
                    },
                    _getStacks: function(last) {
                        var me = this;
                        var scale = me._getIndexScale();
                        var metasets = scale._getMatchingVisibleMetas(me._type);
                        var stacked = scale.options.stacked;
                        var ilen = metasets.length;
                        var stacks = [];
                        var i, meta;
                        for (i = 0; i < ilen; ++i) {
                            meta = metasets[i];
                            if (false === stacked || -1 === stacks.indexOf(meta.stack) || void 0 === stacked && void 0 === meta.stack) stacks.push(meta.stack);
                            if (meta.index === last) break;
                        }
                        return stacks;
                    },
                    getStackCount: function() {
                        return this._getStacks().length;
                    },
                    getStackIndex: function(datasetIndex, name) {
                        var stacks = this._getStacks(datasetIndex);
                        var index = void 0 !== name ? stacks.indexOf(name) : -1;
                        return -1 === index ? stacks.length - 1 : index;
                    },
                    getRuler: function() {
                        var me = this;
                        var scale = me._getIndexScale();
                        var pixels = [];
                        var i, ilen;
                        for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) pixels.push(scale.getPixelForValue(null, i, me.index));
                        return {
                            pixels,
                            start: scale._startPixel,
                            end: scale._endPixel,
                            stackCount: me.getStackCount(),
                            scale
                        };
                    },
                    calculateBarValuePixels: function(datasetIndex, index, options) {
                        var me = this;
                        var chart = me.chart;
                        var scale = me._getValueScale();
                        var isHorizontal = scale.isHorizontal();
                        var datasets = chart.data.datasets;
                        var metasets = scale._getMatchingVisibleMetas(me._type);
                        var value = scale._parseValue(datasets[datasetIndex].data[index]);
                        var minBarLength = options.minBarLength;
                        var stacked = scale.options.stacked;
                        var stack = me.getMeta().stack;
                        var start = void 0 === value.start ? 0 : value.max >= 0 && value.min >= 0 ? value.min : value.max;
                        var length = void 0 === value.start ? value.end : value.max >= 0 && value.min >= 0 ? value.max - value.min : value.min - value.max;
                        var ilen = metasets.length;
                        var i, imeta, ivalue, base, head, size, stackLength;
                        if (stacked || void 0 === stacked && void 0 !== stack) for (i = 0; i < ilen; ++i) {
                            imeta = metasets[i];
                            if (imeta.index === datasetIndex) break;
                            if (imeta.stack === stack) {
                                stackLength = scale._parseValue(datasets[imeta.index].data[index]);
                                ivalue = void 0 === stackLength.start ? stackLength.end : stackLength.min >= 0 && stackLength.max >= 0 ? stackLength.max : stackLength.min;
                                if (value.min < 0 && ivalue < 0 || value.max >= 0 && ivalue > 0) start += ivalue;
                            }
                        }
                        base = scale.getPixelForValue(start);
                        head = scale.getPixelForValue(start + length);
                        size = head - base;
                        if (void 0 !== minBarLength && Math.abs(size) < minBarLength) {
                            size = minBarLength;
                            if (length >= 0 && !isHorizontal || length < 0 && isHorizontal) head = base - minBarLength; else head = base + minBarLength;
                        }
                        return {
                            size,
                            base,
                            head,
                            center: head + size / 2
                        };
                    },
                    calculateBarIndexPixels: function(datasetIndex, index, ruler, options) {
                        var me = this;
                        var range = "flex" === options.barThickness ? computeFlexCategoryTraits(index, ruler, options) : computeFitCategoryTraits(index, ruler, options);
                        var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
                        var center = range.start + range.chunk * stackIndex + range.chunk / 2;
                        var size = Math.min(valueOrDefault$3(options.maxBarThickness, 1 / 0), range.chunk * range.ratio);
                        return {
                            base: center - size / 2,
                            head: center + size / 2,
                            center,
                            size
                        };
                    },
                    draw: function() {
                        var me = this;
                        var chart = me.chart;
                        var scale = me._getValueScale();
                        var rects = me.getMeta().data;
                        var dataset = me.getDataset();
                        var ilen = rects.length;
                        var i = 0;
                        helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);
                        for (;i < ilen; ++i) {
                            var val = scale._parseValue(dataset.data[i]);
                            if (!isNaN(val.min) && !isNaN(val.max)) rects[i].draw();
                        }
                        helpers$1.canvas.unclipArea(chart.ctx);
                    },
                    _resolveDataElementOptions: function() {
                        var me = this;
                        var values = helpers$1.extend({}, core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments));
                        var indexOpts = me._getIndexScale().options;
                        var valueOpts = me._getValueScale().options;
                        values.barPercentage = valueOrDefault$3(indexOpts.barPercentage, values.barPercentage);
                        values.barThickness = valueOrDefault$3(indexOpts.barThickness, values.barThickness);
                        values.categoryPercentage = valueOrDefault$3(indexOpts.categoryPercentage, values.categoryPercentage);
                        values.maxBarThickness = valueOrDefault$3(indexOpts.maxBarThickness, values.maxBarThickness);
                        values.minBarLength = valueOrDefault$3(valueOpts.minBarLength, values.minBarLength);
                        return values;
                    }
                });
                var valueOrDefault$4 = helpers$1.valueOrDefault;
                var resolve$1 = helpers$1.options.resolve;
                core_defaults._set("bubble", {
                    hover: {
                        mode: "single"
                    },
                    scales: {
                        xAxes: [ {
                            type: "linear",
                            position: "bottom",
                            id: "x-axis-0"
                        } ],
                        yAxes: [ {
                            type: "linear",
                            position: "left",
                            id: "y-axis-0"
                        } ]
                    },
                    tooltips: {
                        callbacks: {
                            title: function() {
                                return "";
                            },
                            label: function(item, data) {
                                var datasetLabel = data.datasets[item.datasetIndex].label || "";
                                var dataPoint = data.datasets[item.datasetIndex].data[item.index];
                                return datasetLabel + ": (" + item.xLabel + ", " + item.yLabel + ", " + dataPoint.r + ")";
                            }
                        }
                    }
                });
                var controller_bubble = core_datasetController.extend({
                    dataElementType: elements.Point,
                    _dataElementOptions: [ "backgroundColor", "borderColor", "borderWidth", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth", "hoverRadius", "hitRadius", "pointStyle", "rotation" ],
                    update: function(reset) {
                        var me = this;
                        var meta = me.getMeta();
                        var points = meta.data;
                        helpers$1.each(points, (function(point, index) {
                            me.updateElement(point, index, reset);
                        }));
                    },
                    updateElement: function(point, index, reset) {
                        var me = this;
                        var meta = me.getMeta();
                        var custom = point.custom || {};
                        var xScale = me.getScaleForId(meta.xAxisID);
                        var yScale = me.getScaleForId(meta.yAxisID);
                        var options = me._resolveDataElementOptions(point, index);
                        var data = me.getDataset().data[index];
                        var dsIndex = me.index;
                        var x = reset ? xScale.getPixelForDecimal(.5) : xScale.getPixelForValue("object" === typeof data ? data : NaN, index, dsIndex);
                        var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);
                        point._xScale = xScale;
                        point._yScale = yScale;
                        point._options = options;
                        point._datasetIndex = dsIndex;
                        point._index = index;
                        point._model = {
                            backgroundColor: options.backgroundColor,
                            borderColor: options.borderColor,
                            borderWidth: options.borderWidth,
                            hitRadius: options.hitRadius,
                            pointStyle: options.pointStyle,
                            rotation: options.rotation,
                            radius: reset ? 0 : options.radius,
                            skip: custom.skip || isNaN(x) || isNaN(y),
                            x,
                            y
                        };
                        point.pivot();
                    },
                    setHoverStyle: function(point) {
                        var model = point._model;
                        var options = point._options;
                        var getHoverColor = helpers$1.getHoverColor;
                        point.$previousStyle = {
                            backgroundColor: model.backgroundColor,
                            borderColor: model.borderColor,
                            borderWidth: model.borderWidth,
                            radius: model.radius
                        };
                        model.backgroundColor = valueOrDefault$4(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
                        model.borderColor = valueOrDefault$4(options.hoverBorderColor, getHoverColor(options.borderColor));
                        model.borderWidth = valueOrDefault$4(options.hoverBorderWidth, options.borderWidth);
                        model.radius = options.radius + options.hoverRadius;
                    },
                    _resolveDataElementOptions: function(point, index) {
                        var me = this;
                        var chart = me.chart;
                        var dataset = me.getDataset();
                        var custom = point.custom || {};
                        var data = dataset.data[index] || {};
                        var values = core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments);
                        var context = {
                            chart,
                            dataIndex: index,
                            dataset,
                            datasetIndex: me.index
                        };
                        if (me._cachedDataOpts === values) values = helpers$1.extend({}, values);
                        values.radius = resolve$1([ custom.radius, data.r, me._config.radius, chart.options.elements.point.radius ], context, index);
                        return values;
                    }
                });
                var valueOrDefault$5 = helpers$1.valueOrDefault;
                var PI$1 = Math.PI;
                var DOUBLE_PI$1 = 2 * PI$1;
                var HALF_PI$1 = PI$1 / 2;
                core_defaults._set("doughnut", {
                    animation: {
                        animateRotate: true,
                        animateScale: false
                    },
                    hover: {
                        mode: "single"
                    },
                    legendCallback: function(chart) {
                        var list = document.createElement("ul");
                        var data = chart.data;
                        var datasets = data.datasets;
                        var labels = data.labels;
                        var i, ilen, listItem, listItemSpan;
                        list.setAttribute("class", chart.id + "-legend");
                        if (datasets.length) for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {
                            listItem = list.appendChild(document.createElement("li"));
                            listItemSpan = listItem.appendChild(document.createElement("span"));
                            listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];
                            if (labels[i]) listItem.appendChild(document.createTextNode(labels[i]));
                        }
                        return list.outerHTML;
                    },
                    legend: {
                        labels: {
                            generateLabels: function(chart) {
                                var data = chart.data;
                                if (data.labels.length && data.datasets.length) return data.labels.map((function(label, i) {
                                    var meta = chart.getDatasetMeta(0);
                                    var style = meta.controller.getStyle(i);
                                    return {
                                        text: label,
                                        fillStyle: style.backgroundColor,
                                        strokeStyle: style.borderColor,
                                        lineWidth: style.borderWidth,
                                        hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,
                                        index: i
                                    };
                                }));
                                return [];
                            }
                        },
                        onClick: function(e, legendItem) {
                            var index = legendItem.index;
                            var chart = this.chart;
                            var i, ilen, meta;
                            for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
                                meta = chart.getDatasetMeta(i);
                                if (meta.data[index]) meta.data[index].hidden = !meta.data[index].hidden;
                            }
                            chart.update();
                        }
                    },
                    cutoutPercentage: 50,
                    rotation: -HALF_PI$1,
                    circumference: DOUBLE_PI$1,
                    tooltips: {
                        callbacks: {
                            title: function() {
                                return "";
                            },
                            label: function(tooltipItem, data) {
                                var dataLabel = data.labels[tooltipItem.index];
                                var value = ": " + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
                                if (helpers$1.isArray(dataLabel)) {
                                    dataLabel = dataLabel.slice();
                                    dataLabel[0] += value;
                                } else dataLabel += value;
                                return dataLabel;
                            }
                        }
                    }
                });
                var controller_doughnut = core_datasetController.extend({
                    dataElementType: elements.Arc,
                    linkScales: helpers$1.noop,
                    _dataElementOptions: [ "backgroundColor", "borderColor", "borderWidth", "borderAlign", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth" ],
                    getRingIndex: function(datasetIndex) {
                        var ringIndex = 0;
                        for (var j = 0; j < datasetIndex; ++j) if (this.chart.isDatasetVisible(j)) ++ringIndex;
                        return ringIndex;
                    },
                    update: function(reset) {
                        var me = this;
                        var chart = me.chart;
                        var chartArea = chart.chartArea;
                        var opts = chart.options;
                        var ratioX = 1;
                        var ratioY = 1;
                        var offsetX = 0;
                        var offsetY = 0;
                        var meta = me.getMeta();
                        var arcs = meta.data;
                        var cutout = opts.cutoutPercentage / 100 || 0;
                        var circumference = opts.circumference;
                        var chartWeight = me._getRingWeight(me.index);
                        var maxWidth, maxHeight, i, ilen;
                        if (circumference < DOUBLE_PI$1) {
                            var startAngle = opts.rotation % DOUBLE_PI$1;
                            startAngle += startAngle >= PI$1 ? -DOUBLE_PI$1 : startAngle < -PI$1 ? DOUBLE_PI$1 : 0;
                            var endAngle = startAngle + circumference;
                            var startX = Math.cos(startAngle);
                            var startY = Math.sin(startAngle);
                            var endX = Math.cos(endAngle);
                            var endY = Math.sin(endAngle);
                            var contains0 = startAngle <= 0 && endAngle >= 0 || endAngle >= DOUBLE_PI$1;
                            var contains90 = startAngle <= HALF_PI$1 && endAngle >= HALF_PI$1 || endAngle >= DOUBLE_PI$1 + HALF_PI$1;
                            var contains180 = startAngle === -PI$1 || endAngle >= PI$1;
                            var contains270 = startAngle <= -HALF_PI$1 && endAngle >= -HALF_PI$1 || endAngle >= PI$1 + HALF_PI$1;
                            var minX = contains180 ? -1 : Math.min(startX, startX * cutout, endX, endX * cutout);
                            var minY = contains270 ? -1 : Math.min(startY, startY * cutout, endY, endY * cutout);
                            var maxX = contains0 ? 1 : Math.max(startX, startX * cutout, endX, endX * cutout);
                            var maxY = contains90 ? 1 : Math.max(startY, startY * cutout, endY, endY * cutout);
                            ratioX = (maxX - minX) / 2;
                            ratioY = (maxY - minY) / 2;
                            offsetX = -(maxX + minX) / 2;
                            offsetY = -(maxY + minY) / 2;
                        }
                        for (i = 0, ilen = arcs.length; i < ilen; ++i) arcs[i]._options = me._resolveDataElementOptions(arcs[i], i);
                        chart.borderWidth = me.getMaxBorderWidth();
                        maxWidth = (chartArea.right - chartArea.left - chart.borderWidth) / ratioX;
                        maxHeight = (chartArea.bottom - chartArea.top - chart.borderWidth) / ratioY;
                        chart.outerRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
                        chart.innerRadius = Math.max(chart.outerRadius * cutout, 0);
                        chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);
                        chart.offsetX = offsetX * chart.outerRadius;
                        chart.offsetY = offsetY * chart.outerRadius;
                        meta.total = me.calculateTotal();
                        me.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);
                        me.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);
                        for (i = 0, ilen = arcs.length; i < ilen; ++i) me.updateElement(arcs[i], i, reset);
                    },
                    updateElement: function(arc, index, reset) {
                        var me = this;
                        var chart = me.chart;
                        var chartArea = chart.chartArea;
                        var opts = chart.options;
                        var animationOpts = opts.animation;
                        var centerX = (chartArea.left + chartArea.right) / 2;
                        var centerY = (chartArea.top + chartArea.bottom) / 2;
                        var startAngle = opts.rotation;
                        var endAngle = opts.rotation;
                        var dataset = me.getDataset();
                        var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / DOUBLE_PI$1);
                        var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
                        var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
                        var options = arc._options || {};
                        helpers$1.extend(arc, {
                            _datasetIndex: me.index,
                            _index: index,
                            _model: {
                                backgroundColor: options.backgroundColor,
                                borderColor: options.borderColor,
                                borderWidth: options.borderWidth,
                                borderAlign: options.borderAlign,
                                x: centerX + chart.offsetX,
                                y: centerY + chart.offsetY,
                                startAngle,
                                endAngle,
                                circumference,
                                outerRadius,
                                innerRadius,
                                label: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
                            }
                        });
                        var model = arc._model;
                        if (!reset || !animationOpts.animateRotate) {
                            if (0 === index) model.startAngle = opts.rotation; else model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
                            model.endAngle = model.startAngle + model.circumference;
                        }
                        arc.pivot();
                    },
                    calculateTotal: function() {
                        var dataset = this.getDataset();
                        var meta = this.getMeta();
                        var total = 0;
                        var value;
                        helpers$1.each(meta.data, (function(element, index) {
                            value = dataset.data[index];
                            if (!isNaN(value) && !element.hidden) total += Math.abs(value);
                        }));
                        return total;
                    },
                    calculateCircumference: function(value) {
                        var total = this.getMeta().total;
                        if (total > 0 && !isNaN(value)) return DOUBLE_PI$1 * (Math.abs(value) / total);
                        return 0;
                    },
                    getMaxBorderWidth: function(arcs) {
                        var me = this;
                        var max = 0;
                        var chart = me.chart;
                        var i, ilen, meta, arc, controller, options, borderWidth, hoverWidth;
                        if (!arcs) for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) if (chart.isDatasetVisible(i)) {
                            meta = chart.getDatasetMeta(i);
                            arcs = meta.data;
                            if (i !== me.index) controller = meta.controller;
                            break;
                        }
                        if (!arcs) return 0;
                        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
                            arc = arcs[i];
                            if (controller) {
                                controller._configure();
                                options = controller._resolveDataElementOptions(arc, i);
                            } else options = arc._options;
                            if ("inner" !== options.borderAlign) {
                                borderWidth = options.borderWidth;
                                hoverWidth = options.hoverBorderWidth;
                                max = borderWidth > max ? borderWidth : max;
                                max = hoverWidth > max ? hoverWidth : max;
                            }
                        }
                        return max;
                    },
                    setHoverStyle: function(arc) {
                        var model = arc._model;
                        var options = arc._options;
                        var getHoverColor = helpers$1.getHoverColor;
                        arc.$previousStyle = {
                            backgroundColor: model.backgroundColor,
                            borderColor: model.borderColor,
                            borderWidth: model.borderWidth
                        };
                        model.backgroundColor = valueOrDefault$5(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
                        model.borderColor = valueOrDefault$5(options.hoverBorderColor, getHoverColor(options.borderColor));
                        model.borderWidth = valueOrDefault$5(options.hoverBorderWidth, options.borderWidth);
                    },
                    _getRingWeightOffset: function(datasetIndex) {
                        var ringWeightOffset = 0;
                        for (var i = 0; i < datasetIndex; ++i) if (this.chart.isDatasetVisible(i)) ringWeightOffset += this._getRingWeight(i);
                        return ringWeightOffset;
                    },
                    _getRingWeight: function(dataSetIndex) {
                        return Math.max(valueOrDefault$5(this.chart.data.datasets[dataSetIndex].weight, 1), 0);
                    },
                    _getVisibleDatasetWeightTotal: function() {
                        return this._getRingWeightOffset(this.chart.data.datasets.length);
                    }
                });
                core_defaults._set("horizontalBar", {
                    hover: {
                        mode: "index",
                        axis: "y"
                    },
                    scales: {
                        xAxes: [ {
                            type: "linear",
                            position: "bottom"
                        } ],
                        yAxes: [ {
                            type: "category",
                            position: "left",
                            offset: true,
                            gridLines: {
                                offsetGridLines: true
                            }
                        } ]
                    },
                    elements: {
                        rectangle: {
                            borderSkipped: "left"
                        }
                    },
                    tooltips: {
                        mode: "index",
                        axis: "y"
                    }
                });
                core_defaults._set("global", {
                    datasets: {
                        horizontalBar: {
                            categoryPercentage: .8,
                            barPercentage: .9
                        }
                    }
                });
                var controller_horizontalBar = controller_bar.extend({
                    _getValueScaleId: function() {
                        return this.getMeta().xAxisID;
                    },
                    _getIndexScaleId: function() {
                        return this.getMeta().yAxisID;
                    }
                });
                var valueOrDefault$6 = helpers$1.valueOrDefault;
                var resolve$2 = helpers$1.options.resolve;
                var isPointInArea = helpers$1.canvas._isPointInArea;
                core_defaults._set("line", {
                    showLines: true,
                    spanGaps: false,
                    hover: {
                        mode: "label"
                    },
                    scales: {
                        xAxes: [ {
                            type: "category",
                            id: "x-axis-0"
                        } ],
                        yAxes: [ {
                            type: "linear",
                            id: "y-axis-0"
                        } ]
                    }
                });
                function scaleClip(scale, halfBorderWidth) {
                    var tickOpts = scale && scale.options.ticks || {};
                    var reverse = tickOpts.reverse;
                    var min = void 0 === tickOpts.min ? halfBorderWidth : 0;
                    var max = void 0 === tickOpts.max ? halfBorderWidth : 0;
                    return {
                        start: reverse ? max : min,
                        end: reverse ? min : max
                    };
                }
                function defaultClip(xScale, yScale, borderWidth) {
                    var halfBorderWidth = borderWidth / 2;
                    var x = scaleClip(xScale, halfBorderWidth);
                    var y = scaleClip(yScale, halfBorderWidth);
                    return {
                        top: y.end,
                        right: x.end,
                        bottom: y.start,
                        left: x.start
                    };
                }
                function toClip(value) {
                    var t, r, b, l;
                    if (helpers$1.isObject(value)) {
                        t = value.top;
                        r = value.right;
                        b = value.bottom;
                        l = value.left;
                    } else t = r = b = l = value;
                    return {
                        top: t,
                        right: r,
                        bottom: b,
                        left: l
                    };
                }
                var controller_line = core_datasetController.extend({
                    datasetElementType: elements.Line,
                    dataElementType: elements.Point,
                    _datasetElementOptions: [ "backgroundColor", "borderCapStyle", "borderColor", "borderDash", "borderDashOffset", "borderJoinStyle", "borderWidth", "cubicInterpolationMode", "fill" ],
                    _dataElementOptions: {
                        backgroundColor: "pointBackgroundColor",
                        borderColor: "pointBorderColor",
                        borderWidth: "pointBorderWidth",
                        hitRadius: "pointHitRadius",
                        hoverBackgroundColor: "pointHoverBackgroundColor",
                        hoverBorderColor: "pointHoverBorderColor",
                        hoverBorderWidth: "pointHoverBorderWidth",
                        hoverRadius: "pointHoverRadius",
                        pointStyle: "pointStyle",
                        radius: "pointRadius",
                        rotation: "pointRotation"
                    },
                    update: function(reset) {
                        var me = this;
                        var meta = me.getMeta();
                        var line = meta.dataset;
                        var points = meta.data || [];
                        var options = me.chart.options;
                        var config = me._config;
                        var showLine = me._showLine = valueOrDefault$6(config.showLine, options.showLines);
                        var i, ilen;
                        me._xScale = me.getScaleForId(meta.xAxisID);
                        me._yScale = me.getScaleForId(meta.yAxisID);
                        if (showLine) {
                            if (void 0 !== config.tension && void 0 === config.lineTension) config.lineTension = config.tension;
                            line._scale = me._yScale;
                            line._datasetIndex = me.index;
                            line._children = points;
                            line._model = me._resolveDatasetElementOptions(line);
                            line.pivot();
                        }
                        for (i = 0, ilen = points.length; i < ilen; ++i) me.updateElement(points[i], i, reset);
                        if (showLine && 0 !== line._model.tension) me.updateBezierControlPoints();
                        for (i = 0, ilen = points.length; i < ilen; ++i) points[i].pivot();
                    },
                    updateElement: function(point, index, reset) {
                        var me = this;
                        var meta = me.getMeta();
                        var custom = point.custom || {};
                        var dataset = me.getDataset();
                        var datasetIndex = me.index;
                        var value = dataset.data[index];
                        var xScale = me._xScale;
                        var yScale = me._yScale;
                        var lineModel = meta.dataset._model;
                        var x, y;
                        var options = me._resolveDataElementOptions(point, index);
                        x = xScale.getPixelForValue("object" === typeof value ? value : NaN, index, datasetIndex);
                        y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);
                        point._xScale = xScale;
                        point._yScale = yScale;
                        point._options = options;
                        point._datasetIndex = datasetIndex;
                        point._index = index;
                        point._model = {
                            x,
                            y,
                            skip: custom.skip || isNaN(x) || isNaN(y),
                            radius: options.radius,
                            pointStyle: options.pointStyle,
                            rotation: options.rotation,
                            backgroundColor: options.backgroundColor,
                            borderColor: options.borderColor,
                            borderWidth: options.borderWidth,
                            tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),
                            steppedLine: lineModel ? lineModel.steppedLine : false,
                            hitRadius: options.hitRadius
                        };
                    },
                    _resolveDatasetElementOptions: function(element) {
                        var me = this;
                        var config = me._config;
                        var custom = element.custom || {};
                        var options = me.chart.options;
                        var lineOptions = options.elements.line;
                        var values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments);
                        values.spanGaps = valueOrDefault$6(config.spanGaps, options.spanGaps);
                        values.tension = valueOrDefault$6(config.lineTension, lineOptions.tension);
                        values.steppedLine = resolve$2([ custom.steppedLine, config.steppedLine, lineOptions.stepped ]);
                        values.clip = toClip(valueOrDefault$6(config.clip, defaultClip(me._xScale, me._yScale, values.borderWidth)));
                        return values;
                    },
                    calculatePointY: function(value, index, datasetIndex) {
                        var me = this;
                        var chart = me.chart;
                        var yScale = me._yScale;
                        var sumPos = 0;
                        var sumNeg = 0;
                        var i, ds, dsMeta, stackedRightValue, rightValue, metasets, ilen;
                        if (yScale.options.stacked) {
                            rightValue = +yScale.getRightValue(value);
                            metasets = chart._getSortedVisibleDatasetMetas();
                            ilen = metasets.length;
                            for (i = 0; i < ilen; ++i) {
                                dsMeta = metasets[i];
                                if (dsMeta.index === datasetIndex) break;
                                ds = chart.data.datasets[dsMeta.index];
                                if ("line" === dsMeta.type && dsMeta.yAxisID === yScale.id) {
                                    stackedRightValue = +yScale.getRightValue(ds.data[index]);
                                    if (stackedRightValue < 0) sumNeg += stackedRightValue || 0; else sumPos += stackedRightValue || 0;
                                }
                            }
                            if (rightValue < 0) return yScale.getPixelForValue(sumNeg + rightValue);
                            return yScale.getPixelForValue(sumPos + rightValue);
                        }
                        return yScale.getPixelForValue(value);
                    },
                    updateBezierControlPoints: function() {
                        var me = this;
                        var chart = me.chart;
                        var meta = me.getMeta();
                        var lineModel = meta.dataset._model;
                        var area = chart.chartArea;
                        var points = meta.data || [];
                        var i, ilen, model, controlPoints;
                        if (lineModel.spanGaps) points = points.filter((function(pt) {
                            return !pt._model.skip;
                        }));
                        function capControlPoint(pt, min, max) {
                            return Math.max(Math.min(pt, max), min);
                        }
                        if ("monotone" === lineModel.cubicInterpolationMode) helpers$1.splineCurveMonotone(points); else for (i = 0, 
                        ilen = points.length; i < ilen; ++i) {
                            model = points[i]._model;
                            controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i)._model, model, helpers$1.nextItem(points, i)._model, lineModel.tension);
                            model.controlPointPreviousX = controlPoints.previous.x;
                            model.controlPointPreviousY = controlPoints.previous.y;
                            model.controlPointNextX = controlPoints.next.x;
                            model.controlPointNextY = controlPoints.next.y;
                        }
                        if (chart.options.elements.line.capBezierPoints) for (i = 0, ilen = points.length; i < ilen; ++i) {
                            model = points[i]._model;
                            if (isPointInArea(model, area)) {
                                if (i > 0 && isPointInArea(points[i - 1]._model, area)) {
                                    model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
                                    model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
                                }
                                if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {
                                    model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
                                    model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
                                }
                            }
                        }
                    },
                    draw: function() {
                        var me = this;
                        var chart = me.chart;
                        var meta = me.getMeta();
                        var points = meta.data || [];
                        var area = chart.chartArea;
                        var canvas = chart.canvas;
                        var i = 0;
                        var ilen = points.length;
                        var clip;
                        if (me._showLine) {
                            clip = meta.dataset._model.clip;
                            helpers$1.canvas.clipArea(chart.ctx, {
                                left: false === clip.left ? 0 : area.left - clip.left,
                                right: false === clip.right ? canvas.width : area.right + clip.right,
                                top: false === clip.top ? 0 : area.top - clip.top,
                                bottom: false === clip.bottom ? canvas.height : area.bottom + clip.bottom
                            });
                            meta.dataset.draw();
                            helpers$1.canvas.unclipArea(chart.ctx);
                        }
                        for (;i < ilen; ++i) points[i].draw(area);
                    },
                    setHoverStyle: function(point) {
                        var model = point._model;
                        var options = point._options;
                        var getHoverColor = helpers$1.getHoverColor;
                        point.$previousStyle = {
                            backgroundColor: model.backgroundColor,
                            borderColor: model.borderColor,
                            borderWidth: model.borderWidth,
                            radius: model.radius
                        };
                        model.backgroundColor = valueOrDefault$6(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
                        model.borderColor = valueOrDefault$6(options.hoverBorderColor, getHoverColor(options.borderColor));
                        model.borderWidth = valueOrDefault$6(options.hoverBorderWidth, options.borderWidth);
                        model.radius = valueOrDefault$6(options.hoverRadius, options.radius);
                    }
                });
                var resolve$3 = helpers$1.options.resolve;
                core_defaults._set("polarArea", {
                    scale: {
                        type: "radialLinear",
                        angleLines: {
                            display: false
                        },
                        gridLines: {
                            circular: true
                        },
                        pointLabels: {
                            display: false
                        },
                        ticks: {
                            beginAtZero: true
                        }
                    },
                    animation: {
                        animateRotate: true,
                        animateScale: true
                    },
                    startAngle: -.5 * Math.PI,
                    legendCallback: function(chart) {
                        var list = document.createElement("ul");
                        var data = chart.data;
                        var datasets = data.datasets;
                        var labels = data.labels;
                        var i, ilen, listItem, listItemSpan;
                        list.setAttribute("class", chart.id + "-legend");
                        if (datasets.length) for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {
                            listItem = list.appendChild(document.createElement("li"));
                            listItemSpan = listItem.appendChild(document.createElement("span"));
                            listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];
                            if (labels[i]) listItem.appendChild(document.createTextNode(labels[i]));
                        }
                        return list.outerHTML;
                    },
                    legend: {
                        labels: {
                            generateLabels: function(chart) {
                                var data = chart.data;
                                if (data.labels.length && data.datasets.length) return data.labels.map((function(label, i) {
                                    var meta = chart.getDatasetMeta(0);
                                    var style = meta.controller.getStyle(i);
                                    return {
                                        text: label,
                                        fillStyle: style.backgroundColor,
                                        strokeStyle: style.borderColor,
                                        lineWidth: style.borderWidth,
                                        hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,
                                        index: i
                                    };
                                }));
                                return [];
                            }
                        },
                        onClick: function(e, legendItem) {
                            var index = legendItem.index;
                            var chart = this.chart;
                            var i, ilen, meta;
                            for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
                                meta = chart.getDatasetMeta(i);
                                meta.data[index].hidden = !meta.data[index].hidden;
                            }
                            chart.update();
                        }
                    },
                    tooltips: {
                        callbacks: {
                            title: function() {
                                return "";
                            },
                            label: function(item, data) {
                                return data.labels[item.index] + ": " + item.yLabel;
                            }
                        }
                    }
                });
                var controller_polarArea = core_datasetController.extend({
                    dataElementType: elements.Arc,
                    linkScales: helpers$1.noop,
                    _dataElementOptions: [ "backgroundColor", "borderColor", "borderWidth", "borderAlign", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth" ],
                    _getIndexScaleId: function() {
                        return this.chart.scale.id;
                    },
                    _getValueScaleId: function() {
                        return this.chart.scale.id;
                    },
                    update: function(reset) {
                        var me = this;
                        var dataset = me.getDataset();
                        var meta = me.getMeta();
                        var start = me.chart.options.startAngle || 0;
                        var starts = me._starts = [];
                        var angles = me._angles = [];
                        var arcs = meta.data;
                        var i, ilen, angle;
                        me._updateRadius();
                        meta.count = me.countVisibleElements();
                        for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
                            starts[i] = start;
                            angle = me._computeAngle(i);
                            angles[i] = angle;
                            start += angle;
                        }
                        for (i = 0, ilen = arcs.length; i < ilen; ++i) {
                            arcs[i]._options = me._resolveDataElementOptions(arcs[i], i);
                            me.updateElement(arcs[i], i, reset);
                        }
                    },
                    _updateRadius: function() {
                        var me = this;
                        var chart = me.chart;
                        var chartArea = chart.chartArea;
                        var opts = chart.options;
                        var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
                        chart.outerRadius = Math.max(minSize / 2, 0);
                        chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
                        chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
                        me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
                        me.innerRadius = me.outerRadius - chart.radiusLength;
                    },
                    updateElement: function(arc, index, reset) {
                        var me = this;
                        var chart = me.chart;
                        var dataset = me.getDataset();
                        var opts = chart.options;
                        var animationOpts = opts.animation;
                        var scale = chart.scale;
                        var labels = chart.data.labels;
                        var centerX = scale.xCenter;
                        var centerY = scale.yCenter;
                        var datasetStartAngle = opts.startAngle;
                        var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
                        var startAngle = me._starts[index];
                        var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);
                        var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
                        var options = arc._options || {};
                        helpers$1.extend(arc, {
                            _datasetIndex: me.index,
                            _index: index,
                            _scale: scale,
                            _model: {
                                backgroundColor: options.backgroundColor,
                                borderColor: options.borderColor,
                                borderWidth: options.borderWidth,
                                borderAlign: options.borderAlign,
                                x: centerX,
                                y: centerY,
                                innerRadius: 0,
                                outerRadius: reset ? resetRadius : distance,
                                startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
                                endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
                                label: helpers$1.valueAtIndexOrDefault(labels, index, labels[index])
                            }
                        });
                        arc.pivot();
                    },
                    countVisibleElements: function() {
                        var dataset = this.getDataset();
                        var meta = this.getMeta();
                        var count = 0;
                        helpers$1.each(meta.data, (function(element, index) {
                            if (!isNaN(dataset.data[index]) && !element.hidden) count++;
                        }));
                        return count;
                    },
                    setHoverStyle: function(arc) {
                        var model = arc._model;
                        var options = arc._options;
                        var getHoverColor = helpers$1.getHoverColor;
                        var valueOrDefault = helpers$1.valueOrDefault;
                        arc.$previousStyle = {
                            backgroundColor: model.backgroundColor,
                            borderColor: model.borderColor,
                            borderWidth: model.borderWidth
                        };
                        model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
                        model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));
                        model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);
                    },
                    _computeAngle: function(index) {
                        var me = this;
                        var count = this.getMeta().count;
                        var dataset = me.getDataset();
                        var meta = me.getMeta();
                        if (isNaN(dataset.data[index]) || meta.data[index].hidden) return 0;
                        var context = {
                            chart: me.chart,
                            dataIndex: index,
                            dataset,
                            datasetIndex: me.index
                        };
                        return resolve$3([ me.chart.options.elements.arc.angle, 2 * Math.PI / count ], context, index);
                    }
                });
                core_defaults._set("pie", helpers$1.clone(core_defaults.doughnut));
                core_defaults._set("pie", {
                    cutoutPercentage: 0
                });
                var controller_pie = controller_doughnut;
                var valueOrDefault$7 = helpers$1.valueOrDefault;
                core_defaults._set("radar", {
                    spanGaps: false,
                    scale: {
                        type: "radialLinear"
                    },
                    elements: {
                        line: {
                            fill: "start",
                            tension: 0
                        }
                    }
                });
                var controller_radar = core_datasetController.extend({
                    datasetElementType: elements.Line,
                    dataElementType: elements.Point,
                    linkScales: helpers$1.noop,
                    _datasetElementOptions: [ "backgroundColor", "borderWidth", "borderColor", "borderCapStyle", "borderDash", "borderDashOffset", "borderJoinStyle", "fill" ],
                    _dataElementOptions: {
                        backgroundColor: "pointBackgroundColor",
                        borderColor: "pointBorderColor",
                        borderWidth: "pointBorderWidth",
                        hitRadius: "pointHitRadius",
                        hoverBackgroundColor: "pointHoverBackgroundColor",
                        hoverBorderColor: "pointHoverBorderColor",
                        hoverBorderWidth: "pointHoverBorderWidth",
                        hoverRadius: "pointHoverRadius",
                        pointStyle: "pointStyle",
                        radius: "pointRadius",
                        rotation: "pointRotation"
                    },
                    _getIndexScaleId: function() {
                        return this.chart.scale.id;
                    },
                    _getValueScaleId: function() {
                        return this.chart.scale.id;
                    },
                    update: function(reset) {
                        var me = this;
                        var meta = me.getMeta();
                        var line = meta.dataset;
                        var points = meta.data || [];
                        var scale = me.chart.scale;
                        var config = me._config;
                        var i, ilen;
                        if (void 0 !== config.tension && void 0 === config.lineTension) config.lineTension = config.tension;
                        line._scale = scale;
                        line._datasetIndex = me.index;
                        line._children = points;
                        line._loop = true;
                        line._model = me._resolveDatasetElementOptions(line);
                        line.pivot();
                        for (i = 0, ilen = points.length; i < ilen; ++i) me.updateElement(points[i], i, reset);
                        me.updateBezierControlPoints();
                        for (i = 0, ilen = points.length; i < ilen; ++i) points[i].pivot();
                    },
                    updateElement: function(point, index, reset) {
                        var me = this;
                        var custom = point.custom || {};
                        var dataset = me.getDataset();
                        var scale = me.chart.scale;
                        var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);
                        var options = me._resolveDataElementOptions(point, index);
                        var lineModel = me.getMeta().dataset._model;
                        var x = reset ? scale.xCenter : pointPosition.x;
                        var y = reset ? scale.yCenter : pointPosition.y;
                        point._scale = scale;
                        point._options = options;
                        point._datasetIndex = me.index;
                        point._index = index;
                        point._model = {
                            x,
                            y,
                            skip: custom.skip || isNaN(x) || isNaN(y),
                            radius: options.radius,
                            pointStyle: options.pointStyle,
                            rotation: options.rotation,
                            backgroundColor: options.backgroundColor,
                            borderColor: options.borderColor,
                            borderWidth: options.borderWidth,
                            tension: valueOrDefault$7(custom.tension, lineModel ? lineModel.tension : 0),
                            hitRadius: options.hitRadius
                        };
                    },
                    _resolveDatasetElementOptions: function() {
                        var me = this;
                        var config = me._config;
                        var options = me.chart.options;
                        var values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments);
                        values.spanGaps = valueOrDefault$7(config.spanGaps, options.spanGaps);
                        values.tension = valueOrDefault$7(config.lineTension, options.elements.line.tension);
                        return values;
                    },
                    updateBezierControlPoints: function() {
                        var me = this;
                        var meta = me.getMeta();
                        var area = me.chart.chartArea;
                        var points = meta.data || [];
                        var i, ilen, model, controlPoints;
                        if (meta.dataset._model.spanGaps) points = points.filter((function(pt) {
                            return !pt._model.skip;
                        }));
                        function capControlPoint(pt, min, max) {
                            return Math.max(Math.min(pt, max), min);
                        }
                        for (i = 0, ilen = points.length; i < ilen; ++i) {
                            model = points[i]._model;
                            controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i, true)._model, model, helpers$1.nextItem(points, i, true)._model, model.tension);
                            model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);
                            model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);
                            model.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);
                            model.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);
                        }
                    },
                    setHoverStyle: function(point) {
                        var model = point._model;
                        var options = point._options;
                        var getHoverColor = helpers$1.getHoverColor;
                        point.$previousStyle = {
                            backgroundColor: model.backgroundColor,
                            borderColor: model.borderColor,
                            borderWidth: model.borderWidth,
                            radius: model.radius
                        };
                        model.backgroundColor = valueOrDefault$7(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
                        model.borderColor = valueOrDefault$7(options.hoverBorderColor, getHoverColor(options.borderColor));
                        model.borderWidth = valueOrDefault$7(options.hoverBorderWidth, options.borderWidth);
                        model.radius = valueOrDefault$7(options.hoverRadius, options.radius);
                    }
                });
                core_defaults._set("scatter", {
                    hover: {
                        mode: "single"
                    },
                    scales: {
                        xAxes: [ {
                            id: "x-axis-1",
                            type: "linear",
                            position: "bottom"
                        } ],
                        yAxes: [ {
                            id: "y-axis-1",
                            type: "linear",
                            position: "left"
                        } ]
                    },
                    tooltips: {
                        callbacks: {
                            title: function() {
                                return "";
                            },
                            label: function(item) {
                                return "(" + item.xLabel + ", " + item.yLabel + ")";
                            }
                        }
                    }
                });
                core_defaults._set("global", {
                    datasets: {
                        scatter: {
                            showLine: false
                        }
                    }
                });
                var controller_scatter = controller_line;
                var controllers = {
                    bar: controller_bar,
                    bubble: controller_bubble,
                    doughnut: controller_doughnut,
                    horizontalBar: controller_horizontalBar,
                    line: controller_line,
                    polarArea: controller_polarArea,
                    pie: controller_pie,
                    radar: controller_radar,
                    scatter: controller_scatter
                };
                function getRelativePosition(e, chart) {
                    if (e.native) return {
                        x: e.x,
                        y: e.y
                    };
                    return helpers$1.getRelativePosition(e, chart);
                }
                function parseVisibleItems(chart, handler) {
                    var metasets = chart._getSortedVisibleDatasetMetas();
                    var metadata, i, j, ilen, jlen, element;
                    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
                        metadata = metasets[i].data;
                        for (j = 0, jlen = metadata.length; j < jlen; ++j) {
                            element = metadata[j];
                            if (!element._view.skip) handler(element);
                        }
                    }
                }
                function getIntersectItems(chart, position) {
                    var elements = [];
                    parseVisibleItems(chart, (function(element) {
                        if (element.inRange(position.x, position.y)) elements.push(element);
                    }));
                    return elements;
                }
                function getNearestItems(chart, position, intersect, distanceMetric) {
                    var minDistance = Number.POSITIVE_INFINITY;
                    var nearestItems = [];
                    parseVisibleItems(chart, (function(element) {
                        if (intersect && !element.inRange(position.x, position.y)) return;
                        var center = element.getCenterPoint();
                        var distance = distanceMetric(position, center);
                        if (distance < minDistance) {
                            nearestItems = [ element ];
                            minDistance = distance;
                        } else if (distance === minDistance) nearestItems.push(element);
                    }));
                    return nearestItems;
                }
                function getDistanceMetricForAxis(axis) {
                    var useX = -1 !== axis.indexOf("x");
                    var useY = -1 !== axis.indexOf("y");
                    return function(pt1, pt2) {
                        var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
                        var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
                        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
                    };
                }
                function indexMode(chart, e, options) {
                    var position = getRelativePosition(e, chart);
                    options.axis = options.axis || "x";
                    var distanceMetric = getDistanceMetricForAxis(options.axis);
                    var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
                    var elements = [];
                    if (!items.length) return [];
                    chart._getSortedVisibleDatasetMetas().forEach((function(meta) {
                        var element = meta.data[items[0]._index];
                        if (element && !element._view.skip) elements.push(element);
                    }));
                    return elements;
                }
                var core_interaction = {
                    modes: {
                        single: function(chart, e) {
                            var position = getRelativePosition(e, chart);
                            var elements = [];
                            parseVisibleItems(chart, (function(element) {
                                if (element.inRange(position.x, position.y)) {
                                    elements.push(element);
                                    return elements;
                                }
                            }));
                            return elements.slice(0, 1);
                        },
                        label: indexMode,
                        index: indexMode,
                        dataset: function(chart, e, options) {
                            var position = getRelativePosition(e, chart);
                            options.axis = options.axis || "xy";
                            var distanceMetric = getDistanceMetricForAxis(options.axis);
                            var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
                            if (items.length > 0) items = chart.getDatasetMeta(items[0]._datasetIndex).data;
                            return items;
                        },
                        "x-axis": function(chart, e) {
                            return indexMode(chart, e, {
                                intersect: false
                            });
                        },
                        point: function(chart, e) {
                            var position = getRelativePosition(e, chart);
                            return getIntersectItems(chart, position);
                        },
                        nearest: function(chart, e, options) {
                            var position = getRelativePosition(e, chart);
                            options.axis = options.axis || "xy";
                            var distanceMetric = getDistanceMetricForAxis(options.axis);
                            return getNearestItems(chart, position, options.intersect, distanceMetric);
                        },
                        x: function(chart, e, options) {
                            var position = getRelativePosition(e, chart);
                            var items = [];
                            var intersectsItem = false;
                            parseVisibleItems(chart, (function(element) {
                                if (element.inXRange(position.x)) items.push(element);
                                if (element.inRange(position.x, position.y)) intersectsItem = true;
                            }));
                            if (options.intersect && !intersectsItem) items = [];
                            return items;
                        },
                        y: function(chart, e, options) {
                            var position = getRelativePosition(e, chart);
                            var items = [];
                            var intersectsItem = false;
                            parseVisibleItems(chart, (function(element) {
                                if (element.inYRange(position.y)) items.push(element);
                                if (element.inRange(position.x, position.y)) intersectsItem = true;
                            }));
                            if (options.intersect && !intersectsItem) items = [];
                            return items;
                        }
                    }
                };
                var extend = helpers$1.extend;
                function filterByPosition(array, position) {
                    return helpers$1.where(array, (function(v) {
                        return v.pos === position;
                    }));
                }
                function sortByWeight(array, reverse) {
                    return array.sort((function(a, b) {
                        var v0 = reverse ? b : a;
                        var v1 = reverse ? a : b;
                        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
                    }));
                }
                function wrapBoxes(boxes) {
                    var layoutBoxes = [];
                    var i, ilen, box;
                    for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
                        box = boxes[i];
                        layoutBoxes.push({
                            index: i,
                            box,
                            pos: box.position,
                            horizontal: box.isHorizontal(),
                            weight: box.weight
                        });
                    }
                    return layoutBoxes;
                }
                function setLayoutDims(layouts, params) {
                    var i, ilen, layout;
                    for (i = 0, ilen = layouts.length; i < ilen; ++i) {
                        layout = layouts[i];
                        layout.width = layout.horizontal ? layout.box.fullWidth && params.availableWidth : params.vBoxMaxWidth;
                        layout.height = layout.horizontal && params.hBoxMaxHeight;
                    }
                }
                function buildLayoutBoxes(boxes) {
                    var layoutBoxes = wrapBoxes(boxes);
                    var left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
                    var right = sortByWeight(filterByPosition(layoutBoxes, "right"));
                    var top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
                    var bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
                    return {
                        leftAndTop: left.concat(top),
                        rightAndBottom: right.concat(bottom),
                        chartArea: filterByPosition(layoutBoxes, "chartArea"),
                        vertical: left.concat(right),
                        horizontal: top.concat(bottom)
                    };
                }
                function getCombinedMax(maxPadding, chartArea, a, b) {
                    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
                }
                function updateDims(chartArea, params, layout) {
                    var box = layout.box;
                    var maxPadding = chartArea.maxPadding;
                    var newWidth, newHeight;
                    if (layout.size) chartArea[layout.pos] -= layout.size;
                    layout.size = layout.horizontal ? box.height : box.width;
                    chartArea[layout.pos] += layout.size;
                    if (box.getPadding) {
                        var boxPadding = box.getPadding();
                        maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
                        maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
                        maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
                        maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
                    }
                    newWidth = params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right");
                    newHeight = params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom");
                    if (newWidth !== chartArea.w || newHeight !== chartArea.h) {
                        chartArea.w = newWidth;
                        chartArea.h = newHeight;
                        var sizes = layout.horizontal ? [ newWidth, chartArea.w ] : [ newHeight, chartArea.h ];
                        return sizes[0] !== sizes[1] && (!isNaN(sizes[0]) || !isNaN(sizes[1]));
                    }
                }
                function handleMaxPadding(chartArea) {
                    var maxPadding = chartArea.maxPadding;
                    function updatePos(pos) {
                        var change = Math.max(maxPadding[pos] - chartArea[pos], 0);
                        chartArea[pos] += change;
                        return change;
                    }
                    chartArea.y += updatePos("top");
                    chartArea.x += updatePos("left");
                    updatePos("right");
                    updatePos("bottom");
                }
                function getMargins(horizontal, chartArea) {
                    var maxPadding = chartArea.maxPadding;
                    function marginForPositions(positions) {
                        var margin = {
                            left: 0,
                            top: 0,
                            right: 0,
                            bottom: 0
                        };
                        positions.forEach((function(pos) {
                            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
                        }));
                        return margin;
                    }
                    return horizontal ? marginForPositions([ "left", "right" ]) : marginForPositions([ "top", "bottom" ]);
                }
                function fitBoxes(boxes, chartArea, params) {
                    var refitBoxes = [];
                    var i, ilen, layout, box, refit, changed;
                    for (i = 0, ilen = boxes.length; i < ilen; ++i) {
                        layout = boxes[i];
                        box = layout.box;
                        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
                        if (updateDims(chartArea, params, layout)) {
                            changed = true;
                            if (refitBoxes.length) refit = true;
                        }
                        if (!box.fullWidth) refitBoxes.push(layout);
                    }
                    return refit ? fitBoxes(refitBoxes, chartArea, params) || changed : changed;
                }
                function placeBoxes(boxes, chartArea, params) {
                    var userPadding = params.padding;
                    var x = chartArea.x;
                    var y = chartArea.y;
                    var i, ilen, layout, box;
                    for (i = 0, ilen = boxes.length; i < ilen; ++i) {
                        layout = boxes[i];
                        box = layout.box;
                        if (layout.horizontal) {
                            box.left = box.fullWidth ? userPadding.left : chartArea.left;
                            box.right = box.fullWidth ? params.outerWidth - userPadding.right : chartArea.left + chartArea.w;
                            box.top = y;
                            box.bottom = y + box.height;
                            box.width = box.right - box.left;
                            y = box.bottom;
                        } else {
                            box.left = x;
                            box.right = x + box.width;
                            box.top = chartArea.top;
                            box.bottom = chartArea.top + chartArea.h;
                            box.height = box.bottom - box.top;
                            x = box.right;
                        }
                    }
                    chartArea.x = x;
                    chartArea.y = y;
                }
                core_defaults._set("global", {
                    layout: {
                        padding: {
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        }
                    }
                });
                var core_layouts = {
                    defaults: {},
                    addBox: function(chart, item) {
                        if (!chart.boxes) chart.boxes = [];
                        item.fullWidth = item.fullWidth || false;
                        item.position = item.position || "top";
                        item.weight = item.weight || 0;
                        item._layers = item._layers || function() {
                            return [ {
                                z: 0,
                                draw: function() {
                                    item.draw.apply(item, arguments);
                                }
                            } ];
                        };
                        chart.boxes.push(item);
                    },
                    removeBox: function(chart, layoutItem) {
                        var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
                        if (-1 !== index) chart.boxes.splice(index, 1);
                    },
                    configure: function(chart, item, options) {
                        var props = [ "fullWidth", "position", "weight" ];
                        var ilen = props.length;
                        var i = 0;
                        var prop;
                        for (;i < ilen; ++i) {
                            prop = props[i];
                            if (options.hasOwnProperty(prop)) item[prop] = options[prop];
                        }
                    },
                    update: function(chart, width, height) {
                        if (!chart) return;
                        var layoutOptions = chart.options.layout || {};
                        var padding = helpers$1.options.toPadding(layoutOptions.padding);
                        var availableWidth = width - padding.width;
                        var availableHeight = height - padding.height;
                        var boxes = buildLayoutBoxes(chart.boxes);
                        var verticalBoxes = boxes.vertical;
                        var horizontalBoxes = boxes.horizontal;
                        var params = Object.freeze({
                            outerWidth: width,
                            outerHeight: height,
                            padding,
                            availableWidth,
                            vBoxMaxWidth: availableWidth / 2 / verticalBoxes.length,
                            hBoxMaxHeight: availableHeight / 2
                        });
                        var chartArea = extend({
                            maxPadding: extend({}, padding),
                            w: availableWidth,
                            h: availableHeight,
                            x: padding.left,
                            y: padding.top
                        }, padding);
                        setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
                        fitBoxes(verticalBoxes, chartArea, params);
                        if (fitBoxes(horizontalBoxes, chartArea, params)) fitBoxes(verticalBoxes, chartArea, params);
                        handleMaxPadding(chartArea);
                        placeBoxes(boxes.leftAndTop, chartArea, params);
                        chartArea.x += chartArea.w;
                        chartArea.y += chartArea.h;
                        placeBoxes(boxes.rightAndBottom, chartArea, params);
                        chart.chartArea = {
                            left: chartArea.left,
                            top: chartArea.top,
                            right: chartArea.left + chartArea.w,
                            bottom: chartArea.top + chartArea.h
                        };
                        helpers$1.each(boxes.chartArea, (function(layout) {
                            var box = layout.box;
                            extend(box, chart.chartArea);
                            box.update(chartArea.w, chartArea.h);
                        }));
                    }
                };
                var platform_basic = {
                    acquireContext: function(item) {
                        if (item && item.canvas) item = item.canvas;
                        return item && item.getContext("2d") || null;
                    }
                };
                var platform_dom = "/*\r\n * DOM element rendering detection\r\n * https://davidwalsh.name/detect-node-insertion\r\n */\r\n@keyframes chartjs-render-animation {\r\n\tfrom { opacity: 0.99; }\r\n\tto { opacity: 1; }\r\n}\r\n\r\n.chartjs-render-monitor {\r\n\tanimation: chartjs-render-animation 0.001s;\r\n}\r\n\r\n/*\r\n * DOM element resizing detection\r\n * https://github.com/marcj/css-element-queries\r\n */\r\n.chartjs-size-monitor,\r\n.chartjs-size-monitor-expand,\r\n.chartjs-size-monitor-shrink {\r\n\tposition: absolute;\r\n\tdirection: ltr;\r\n\tleft: 0;\r\n\ttop: 0;\r\n\tright: 0;\r\n\tbottom: 0;\r\n\toverflow: hidden;\r\n\tpointer-events: none;\r\n\tvisibility: hidden;\r\n\tz-index: -1;\r\n}\r\n\r\n.chartjs-size-monitor-expand > div {\r\n\tposition: absolute;\r\n\twidth: 1000000px;\r\n\theight: 1000000px;\r\n\tleft: 0;\r\n\ttop: 0;\r\n}\r\n\r\n.chartjs-size-monitor-shrink > div {\r\n\tposition: absolute;\r\n\twidth: 200%;\r\n\theight: 200%;\r\n\tleft: 0;\r\n\ttop: 0;\r\n}\r\n";
                var platform_dom$1 = Object.freeze({
                    __proto__: null,
                    default: platform_dom
                });
                var stylesheet = getCjsExportFromNamespace(platform_dom$1);
                var EXPANDO_KEY = "$chartjs";
                var CSS_PREFIX = "chartjs-";
                var CSS_SIZE_MONITOR = CSS_PREFIX + "size-monitor";
                var CSS_RENDER_MONITOR = CSS_PREFIX + "render-monitor";
                var CSS_RENDER_ANIMATION = CSS_PREFIX + "render-animation";
                var ANIMATION_START_EVENTS = [ "animationstart", "webkitAnimationStart" ];
                var EVENT_TYPES = {
                    touchstart: "mousedown",
                    touchmove: "mousemove",
                    touchend: "mouseup",
                    pointerenter: "mouseenter",
                    pointerdown: "mousedown",
                    pointermove: "mousemove",
                    pointerup: "mouseup",
                    pointerleave: "mouseout",
                    pointerout: "mouseout"
                };
                function readUsedSize(element, property) {
                    var value = helpers$1.getStyle(element, property);
                    var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
                    return matches ? Number(matches[1]) : void 0;
                }
                function initCanvas(canvas, config) {
                    var style = canvas.style;
                    var renderHeight = canvas.getAttribute("height");
                    var renderWidth = canvas.getAttribute("width");
                    canvas[EXPANDO_KEY] = {
                        initial: {
                            height: renderHeight,
                            width: renderWidth,
                            style: {
                                display: style.display,
                                height: style.height,
                                width: style.width
                            }
                        }
                    };
                    style.display = style.display || "block";
                    if (null === renderWidth || "" === renderWidth) {
                        var displayWidth = readUsedSize(canvas, "width");
                        if (void 0 !== displayWidth) canvas.width = displayWidth;
                    }
                    if (null === renderHeight || "" === renderHeight) if ("" === canvas.style.height) canvas.height = canvas.width / (config.options.aspectRatio || 2); else {
                        var displayHeight = readUsedSize(canvas, "height");
                        if (void 0 !== displayWidth) canvas.height = displayHeight;
                    }
                    return canvas;
                }
                var supportsEventListenerOptions = function() {
                    var supports = false;
                    try {
                        var options = Object.defineProperty({}, "passive", {
                            get: function() {
                                supports = true;
                            }
                        });
                        window.addEventListener("e", null, options);
                    } catch (e) {}
                    return supports;
                }();
                var eventListenerOptions = supportsEventListenerOptions ? {
                    passive: true
                } : false;
                function addListener(node, type, listener) {
                    node.addEventListener(type, listener, eventListenerOptions);
                }
                function removeListener(node, type, listener) {
                    node.removeEventListener(type, listener, eventListenerOptions);
                }
                function createEvent(type, chart, x, y, nativeEvent) {
                    return {
                        type,
                        chart,
                        native: nativeEvent || null,
                        x: void 0 !== x ? x : null,
                        y: void 0 !== y ? y : null
                    };
                }
                function fromNativeEvent(event, chart) {
                    var type = EVENT_TYPES[event.type] || event.type;
                    var pos = helpers$1.getRelativePosition(event, chart);
                    return createEvent(type, chart, pos.x, pos.y, event);
                }
                function throttled(fn, thisArg) {
                    var ticking = false;
                    var args = [];
                    return function() {
                        args = Array.prototype.slice.call(arguments);
                        thisArg = thisArg || this;
                        if (!ticking) {
                            ticking = true;
                            helpers$1.requestAnimFrame.call(window, (function() {
                                ticking = false;
                                fn.apply(thisArg, args);
                            }));
                        }
                    };
                }
                function createDiv(cls) {
                    var el = document.createElement("div");
                    el.className = cls || "";
                    return el;
                }
                function createResizer(handler) {
                    var maxSize = 1e6;
                    var resizer = createDiv(CSS_SIZE_MONITOR);
                    var expand = createDiv(CSS_SIZE_MONITOR + "-expand");
                    var shrink = createDiv(CSS_SIZE_MONITOR + "-shrink");
                    expand.appendChild(createDiv());
                    shrink.appendChild(createDiv());
                    resizer.appendChild(expand);
                    resizer.appendChild(shrink);
                    resizer._reset = function() {
                        expand.scrollLeft = maxSize;
                        expand.scrollTop = maxSize;
                        shrink.scrollLeft = maxSize;
                        shrink.scrollTop = maxSize;
                    };
                    var onScroll = function() {
                        resizer._reset();
                        handler();
                    };
                    addListener(expand, "scroll", onScroll.bind(expand, "expand"));
                    addListener(shrink, "scroll", onScroll.bind(shrink, "shrink"));
                    return resizer;
                }
                function watchForRender(node, handler) {
                    var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
                    var proxy = expando.renderProxy = function(e) {
                        if (e.animationName === CSS_RENDER_ANIMATION) handler();
                    };
                    helpers$1.each(ANIMATION_START_EVENTS, (function(type) {
                        addListener(node, type, proxy);
                    }));
                    expando.reflow = !!node.offsetParent;
                    node.classList.add(CSS_RENDER_MONITOR);
                }
                function unwatchForRender(node) {
                    var expando = node[EXPANDO_KEY] || {};
                    var proxy = expando.renderProxy;
                    if (proxy) {
                        helpers$1.each(ANIMATION_START_EVENTS, (function(type) {
                            removeListener(node, type, proxy);
                        }));
                        delete expando.renderProxy;
                    }
                    node.classList.remove(CSS_RENDER_MONITOR);
                }
                function addResizeListener(node, listener, chart) {
                    var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
                    var resizer = expando.resizer = createResizer(throttled((function() {
                        if (expando.resizer) {
                            var container = chart.options.maintainAspectRatio && node.parentNode;
                            var w = container ? container.clientWidth : 0;
                            listener(createEvent("resize", chart));
                            if (container && container.clientWidth < w && chart.canvas) listener(createEvent("resize", chart));
                        }
                    })));
                    watchForRender(node, (function() {
                        if (expando.resizer) {
                            var container = node.parentNode;
                            if (container && container !== resizer.parentNode) container.insertBefore(resizer, container.firstChild);
                            resizer._reset();
                        }
                    }));
                }
                function removeResizeListener(node) {
                    var expando = node[EXPANDO_KEY] || {};
                    var resizer = expando.resizer;
                    delete expando.resizer;
                    unwatchForRender(node);
                    if (resizer && resizer.parentNode) resizer.parentNode.removeChild(resizer);
                }
                function injectCSS(rootNode, css) {
                    var expando = rootNode[EXPANDO_KEY] || (rootNode[EXPANDO_KEY] = {});
                    if (!expando.containsStyles) {
                        expando.containsStyles = true;
                        css = "/* Chart.js */\n" + css;
                        var style = document.createElement("style");
                        style.setAttribute("type", "text/css");
                        style.appendChild(document.createTextNode(css));
                        rootNode.appendChild(style);
                    }
                }
                var platform_dom$2 = {
                    disableCSSInjection: false,
                    _enabled: "undefined" !== typeof window && "undefined" !== typeof document,
                    _ensureLoaded: function(canvas) {
                        if (!this.disableCSSInjection) {
                            var root = canvas.getRootNode ? canvas.getRootNode() : document;
                            var targetNode = root.host ? root : document.head;
                            injectCSS(targetNode, stylesheet);
                        }
                    },
                    acquireContext: function(item, config) {
                        if ("string" === typeof item) item = document.getElementById(item); else if (item.length) item = item[0];
                        if (item && item.canvas) item = item.canvas;
                        var context = item && item.getContext && item.getContext("2d");
                        if (context && context.canvas === item) {
                            this._ensureLoaded(item);
                            initCanvas(item, config);
                            return context;
                        }
                        return null;
                    },
                    releaseContext: function(context) {
                        var canvas = context.canvas;
                        if (!canvas[EXPANDO_KEY]) return;
                        var initial = canvas[EXPANDO_KEY].initial;
                        [ "height", "width" ].forEach((function(prop) {
                            var value = initial[prop];
                            if (helpers$1.isNullOrUndef(value)) canvas.removeAttribute(prop); else canvas.setAttribute(prop, value);
                        }));
                        helpers$1.each(initial.style || {}, (function(value, key) {
                            canvas.style[key] = value;
                        }));
                        canvas.width = canvas.width;
                        delete canvas[EXPANDO_KEY];
                    },
                    addEventListener: function(chart, type, listener) {
                        var canvas = chart.canvas;
                        if ("resize" === type) {
                            addResizeListener(canvas, listener, chart);
                            return;
                        }
                        var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
                        var proxies = expando.proxies || (expando.proxies = {});
                        var proxy = proxies[chart.id + "_" + type] = function(event) {
                            listener(fromNativeEvent(event, chart));
                        };
                        addListener(canvas, type, proxy);
                    },
                    removeEventListener: function(chart, type, listener) {
                        var canvas = chart.canvas;
                        if ("resize" === type) {
                            removeResizeListener(canvas);
                            return;
                        }
                        var expando = listener[EXPANDO_KEY] || {};
                        var proxies = expando.proxies || {};
                        var proxy = proxies[chart.id + "_" + type];
                        if (!proxy) return;
                        removeListener(canvas, type, proxy);
                    }
                };
                helpers$1.addEvent = addListener;
                helpers$1.removeEvent = removeListener;
                var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;
                var platform = helpers$1.extend({
                    initialize: function() {},
                    acquireContext: function() {},
                    releaseContext: function() {},
                    addEventListener: function() {},
                    removeEventListener: function() {}
                }, implementation);
                core_defaults._set("global", {
                    plugins: {}
                });
                var core_plugins = {
                    _plugins: [],
                    _cacheId: 0,
                    register: function(plugins) {
                        var p = this._plugins;
                        [].concat(plugins).forEach((function(plugin) {
                            if (-1 === p.indexOf(plugin)) p.push(plugin);
                        }));
                        this._cacheId++;
                    },
                    unregister: function(plugins) {
                        var p = this._plugins;
                        [].concat(plugins).forEach((function(plugin) {
                            var idx = p.indexOf(plugin);
                            if (-1 !== idx) p.splice(idx, 1);
                        }));
                        this._cacheId++;
                    },
                    clear: function() {
                        this._plugins = [];
                        this._cacheId++;
                    },
                    count: function() {
                        return this._plugins.length;
                    },
                    getAll: function() {
                        return this._plugins;
                    },
                    notify: function(chart, hook, args) {
                        var descriptors = this.descriptors(chart);
                        var ilen = descriptors.length;
                        var i, descriptor, plugin, params, method;
                        for (i = 0; i < ilen; ++i) {
                            descriptor = descriptors[i];
                            plugin = descriptor.plugin;
                            method = plugin[hook];
                            if ("function" === typeof method) {
                                params = [ chart ].concat(args || []);
                                params.push(descriptor.options);
                                if (false === method.apply(plugin, params)) return false;
                            }
                        }
                        return true;
                    },
                    descriptors: function(chart) {
                        var cache = chart.$plugins || (chart.$plugins = {});
                        if (cache.id === this._cacheId) return cache.descriptors;
                        var plugins = [];
                        var descriptors = [];
                        var config = chart && chart.config || {};
                        var options = config.options && config.options.plugins || {};
                        this._plugins.concat(config.plugins || []).forEach((function(plugin) {
                            var idx = plugins.indexOf(plugin);
                            if (-1 !== idx) return;
                            var id = plugin.id;
                            var opts = options[id];
                            if (false === opts) return;
                            if (true === opts) opts = helpers$1.clone(core_defaults.global.plugins[id]);
                            plugins.push(plugin);
                            descriptors.push({
                                plugin,
                                options: opts || {}
                            });
                        }));
                        cache.descriptors = descriptors;
                        cache.id = this._cacheId;
                        return descriptors;
                    },
                    _invalidate: function(chart) {
                        delete chart.$plugins;
                    }
                };
                var core_scaleService = {
                    constructors: {},
                    defaults: {},
                    registerScaleType: function(type, scaleConstructor, scaleDefaults) {
                        this.constructors[type] = scaleConstructor;
                        this.defaults[type] = helpers$1.clone(scaleDefaults);
                    },
                    getScaleConstructor: function(type) {
                        return this.constructors.hasOwnProperty(type) ? this.constructors[type] : void 0;
                    },
                    getScaleDefaults: function(type) {
                        return this.defaults.hasOwnProperty(type) ? helpers$1.merge(Object.create(null), [ core_defaults.scale, this.defaults[type] ]) : {};
                    },
                    updateScaleDefaults: function(type, additions) {
                        var me = this;
                        if (me.defaults.hasOwnProperty(type)) me.defaults[type] = helpers$1.extend(me.defaults[type], additions);
                    },
                    addScalesToLayout: function(chart) {
                        helpers$1.each(chart.scales, (function(scale) {
                            scale.fullWidth = scale.options.fullWidth;
                            scale.position = scale.options.position;
                            scale.weight = scale.options.weight;
                            core_layouts.addBox(chart, scale);
                        }));
                    }
                };
                var valueOrDefault$8 = helpers$1.valueOrDefault;
                var getRtlHelper = helpers$1.rtl.getRtlAdapter;
                core_defaults._set("global", {
                    tooltips: {
                        enabled: true,
                        custom: null,
                        mode: "nearest",
                        position: "average",
                        intersect: true,
                        backgroundColor: "rgba(0,0,0,0.8)",
                        titleFontStyle: "bold",
                        titleSpacing: 2,
                        titleMarginBottom: 6,
                        titleFontColor: "#fff",
                        titleAlign: "left",
                        bodySpacing: 2,
                        bodyFontColor: "#fff",
                        bodyAlign: "left",
                        footerFontStyle: "bold",
                        footerSpacing: 2,
                        footerMarginTop: 6,
                        footerFontColor: "#fff",
                        footerAlign: "left",
                        yPadding: 6,
                        xPadding: 6,
                        caretPadding: 2,
                        caretSize: 5,
                        cornerRadius: 6,
                        multiKeyBackground: "#fff",
                        displayColors: true,
                        borderColor: "rgba(0,0,0,0)",
                        borderWidth: 0,
                        callbacks: {
                            beforeTitle: helpers$1.noop,
                            title: function(tooltipItems, data) {
                                var title = "";
                                var labels = data.labels;
                                var labelCount = labels ? labels.length : 0;
                                if (tooltipItems.length > 0) {
                                    var item = tooltipItems[0];
                                    if (item.label) title = item.label; else if (item.xLabel) title = item.xLabel; else if (labelCount > 0 && item.index < labelCount) title = labels[item.index];
                                }
                                return title;
                            },
                            afterTitle: helpers$1.noop,
                            beforeBody: helpers$1.noop,
                            beforeLabel: helpers$1.noop,
                            label: function(tooltipItem, data) {
                                var label = data.datasets[tooltipItem.datasetIndex].label || "";
                                if (label) label += ": ";
                                if (!helpers$1.isNullOrUndef(tooltipItem.value)) label += tooltipItem.value; else label += tooltipItem.yLabel;
                                return label;
                            },
                            labelColor: function(tooltipItem, chart) {
                                var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
                                var activeElement = meta.data[tooltipItem.index];
                                var view = activeElement._view;
                                return {
                                    borderColor: view.borderColor,
                                    backgroundColor: view.backgroundColor
                                };
                            },
                            labelTextColor: function() {
                                return this._options.bodyFontColor;
                            },
                            afterLabel: helpers$1.noop,
                            afterBody: helpers$1.noop,
                            beforeFooter: helpers$1.noop,
                            footer: helpers$1.noop,
                            afterFooter: helpers$1.noop
                        }
                    }
                });
                var positioners = {
                    average: function(elements) {
                        if (!elements.length) return false;
                        var i, len;
                        var x = 0;
                        var y = 0;
                        var count = 0;
                        for (i = 0, len = elements.length; i < len; ++i) {
                            var el = elements[i];
                            if (el && el.hasValue()) {
                                var pos = el.tooltipPosition();
                                x += pos.x;
                                y += pos.y;
                                ++count;
                            }
                        }
                        return {
                            x: x / count,
                            y: y / count
                        };
                    },
                    nearest: function(elements, eventPosition) {
                        var x = eventPosition.x;
                        var y = eventPosition.y;
                        var minDistance = Number.POSITIVE_INFINITY;
                        var i, len, nearestElement;
                        for (i = 0, len = elements.length; i < len; ++i) {
                            var el = elements[i];
                            if (el && el.hasValue()) {
                                var center = el.getCenterPoint();
                                var d = helpers$1.distanceBetweenPoints(eventPosition, center);
                                if (d < minDistance) {
                                    minDistance = d;
                                    nearestElement = el;
                                }
                            }
                        }
                        if (nearestElement) {
                            var tp = nearestElement.tooltipPosition();
                            x = tp.x;
                            y = tp.y;
                        }
                        return {
                            x,
                            y
                        };
                    }
                };
                function pushOrConcat(base, toPush) {
                    if (toPush) if (helpers$1.isArray(toPush)) Array.prototype.push.apply(base, toPush); else base.push(toPush);
                    return base;
                }
                function splitNewlines(str) {
                    if (("string" === typeof str || str instanceof String) && str.indexOf("\n") > -1) return str.split("\n");
                    return str;
                }
                function createTooltipItem(element) {
                    var xScale = element._xScale;
                    var yScale = element._yScale || element._scale;
                    var index = element._index;
                    var datasetIndex = element._datasetIndex;
                    var controller = element._chart.getDatasetMeta(datasetIndex).controller;
                    var indexScale = controller._getIndexScale();
                    var valueScale = controller._getValueScale();
                    return {
                        xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : "",
                        yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : "",
                        label: indexScale ? "" + indexScale.getLabelForIndex(index, datasetIndex) : "",
                        value: valueScale ? "" + valueScale.getLabelForIndex(index, datasetIndex) : "",
                        index,
                        datasetIndex,
                        x: element._model.x,
                        y: element._model.y
                    };
                }
                function getBaseModel(tooltipOpts) {
                    var globalDefaults = core_defaults.global;
                    return {
                        xPadding: tooltipOpts.xPadding,
                        yPadding: tooltipOpts.yPadding,
                        xAlign: tooltipOpts.xAlign,
                        yAlign: tooltipOpts.yAlign,
                        rtl: tooltipOpts.rtl,
                        textDirection: tooltipOpts.textDirection,
                        bodyFontColor: tooltipOpts.bodyFontColor,
                        _bodyFontFamily: valueOrDefault$8(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
                        _bodyFontStyle: valueOrDefault$8(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
                        _bodyAlign: tooltipOpts.bodyAlign,
                        bodyFontSize: valueOrDefault$8(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
                        bodySpacing: tooltipOpts.bodySpacing,
                        titleFontColor: tooltipOpts.titleFontColor,
                        _titleFontFamily: valueOrDefault$8(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
                        _titleFontStyle: valueOrDefault$8(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
                        titleFontSize: valueOrDefault$8(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
                        _titleAlign: tooltipOpts.titleAlign,
                        titleSpacing: tooltipOpts.titleSpacing,
                        titleMarginBottom: tooltipOpts.titleMarginBottom,
                        footerFontColor: tooltipOpts.footerFontColor,
                        _footerFontFamily: valueOrDefault$8(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
                        _footerFontStyle: valueOrDefault$8(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
                        footerFontSize: valueOrDefault$8(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
                        _footerAlign: tooltipOpts.footerAlign,
                        footerSpacing: tooltipOpts.footerSpacing,
                        footerMarginTop: tooltipOpts.footerMarginTop,
                        caretSize: tooltipOpts.caretSize,
                        cornerRadius: tooltipOpts.cornerRadius,
                        backgroundColor: tooltipOpts.backgroundColor,
                        opacity: 0,
                        legendColorBackground: tooltipOpts.multiKeyBackground,
                        displayColors: tooltipOpts.displayColors,
                        borderColor: tooltipOpts.borderColor,
                        borderWidth: tooltipOpts.borderWidth
                    };
                }
                function getTooltipSize(tooltip, model) {
                    var ctx = tooltip._chart.ctx;
                    var height = 2 * model.yPadding;
                    var width = 0;
                    var body = model.body;
                    var combinedBodyLength = body.reduce((function(count, bodyItem) {
                        return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
                    }), 0);
                    combinedBodyLength += model.beforeBody.length + model.afterBody.length;
                    var titleLineCount = model.title.length;
                    var footerLineCount = model.footer.length;
                    var titleFontSize = model.titleFontSize;
                    var bodyFontSize = model.bodyFontSize;
                    var footerFontSize = model.footerFontSize;
                    height += titleLineCount * titleFontSize;
                    height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0;
                    height += titleLineCount ? model.titleMarginBottom : 0;
                    height += combinedBodyLength * bodyFontSize;
                    height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0;
                    height += footerLineCount ? model.footerMarginTop : 0;
                    height += footerLineCount * footerFontSize;
                    height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0;
                    var widthPadding = 0;
                    var maxLineWidth = function(line) {
                        width = Math.max(width, ctx.measureText(line).width + widthPadding);
                    };
                    ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
                    helpers$1.each(model.title, maxLineWidth);
                    ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
                    helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth);
                    widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
                    helpers$1.each(body, (function(bodyItem) {
                        helpers$1.each(bodyItem.before, maxLineWidth);
                        helpers$1.each(bodyItem.lines, maxLineWidth);
                        helpers$1.each(bodyItem.after, maxLineWidth);
                    }));
                    widthPadding = 0;
                    ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
                    helpers$1.each(model.footer, maxLineWidth);
                    width += 2 * model.xPadding;
                    return {
                        width,
                        height
                    };
                }
                function determineAlignment(tooltip, size) {
                    var model = tooltip._model;
                    var chart = tooltip._chart;
                    var chartArea = tooltip._chart.chartArea;
                    var xAlign = "center";
                    var yAlign = "center";
                    if (model.y < size.height) yAlign = "top"; else if (model.y > chart.height - size.height) yAlign = "bottom";
                    var lf, rf;
                    var olf, orf;
                    var yf;
                    var midX = (chartArea.left + chartArea.right) / 2;
                    var midY = (chartArea.top + chartArea.bottom) / 2;
                    if ("center" === yAlign) {
                        lf = function(x) {
                            return x <= midX;
                        };
                        rf = function(x) {
                            return x > midX;
                        };
                    } else {
                        lf = function(x) {
                            return x <= size.width / 2;
                        };
                        rf = function(x) {
                            return x >= chart.width - size.width / 2;
                        };
                    }
                    olf = function(x) {
                        return x + size.width + model.caretSize + model.caretPadding > chart.width;
                    };
                    orf = function(x) {
                        return x - size.width - model.caretSize - model.caretPadding < 0;
                    };
                    yf = function(y) {
                        return y <= midY ? "top" : "bottom";
                    };
                    if (lf(model.x)) {
                        xAlign = "left";
                        if (olf(model.x)) {
                            xAlign = "center";
                            yAlign = yf(model.y);
                        }
                    } else if (rf(model.x)) {
                        xAlign = "right";
                        if (orf(model.x)) {
                            xAlign = "center";
                            yAlign = yf(model.y);
                        }
                    }
                    var opts = tooltip._options;
                    return {
                        xAlign: opts.xAlign ? opts.xAlign : xAlign,
                        yAlign: opts.yAlign ? opts.yAlign : yAlign
                    };
                }
                function getBackgroundPoint(vm, size, alignment, chart) {
                    var x = vm.x;
                    var y = vm.y;
                    var caretSize = vm.caretSize;
                    var caretPadding = vm.caretPadding;
                    var cornerRadius = vm.cornerRadius;
                    var xAlign = alignment.xAlign;
                    var yAlign = alignment.yAlign;
                    var paddingAndSize = caretSize + caretPadding;
                    var radiusAndPadding = cornerRadius + caretPadding;
                    if ("right" === xAlign) x -= size.width; else if ("center" === xAlign) {
                        x -= size.width / 2;
                        if (x + size.width > chart.width) x = chart.width - size.width;
                        if (x < 0) x = 0;
                    }
                    if ("top" === yAlign) y += paddingAndSize; else if ("bottom" === yAlign) y -= size.height + paddingAndSize; else y -= size.height / 2;
                    if ("center" === yAlign) {
                        if ("left" === xAlign) x += paddingAndSize; else if ("right" === xAlign) x -= paddingAndSize;
                    } else if ("left" === xAlign) x -= radiusAndPadding; else if ("right" === xAlign) x += radiusAndPadding;
                    return {
                        x,
                        y
                    };
                }
                function getAlignedX(vm, align) {
                    return "center" === align ? vm.x + vm.width / 2 : "right" === align ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;
                }
                function getBeforeAfterBodyLines(callback) {
                    return pushOrConcat([], splitNewlines(callback));
                }
                var exports$4 = core_element.extend({
                    initialize: function() {
                        this._model = getBaseModel(this._options);
                        this._lastActive = [];
                    },
                    getTitle: function() {
                        var me = this;
                        var opts = me._options;
                        var callbacks = opts.callbacks;
                        var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
                        var title = callbacks.title.apply(me, arguments);
                        var afterTitle = callbacks.afterTitle.apply(me, arguments);
                        var lines = [];
                        lines = pushOrConcat(lines, splitNewlines(beforeTitle));
                        lines = pushOrConcat(lines, splitNewlines(title));
                        lines = pushOrConcat(lines, splitNewlines(afterTitle));
                        return lines;
                    },
                    getBeforeBody: function() {
                        return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
                    },
                    getBody: function(tooltipItems, data) {
                        var me = this;
                        var callbacks = me._options.callbacks;
                        var bodyItems = [];
                        helpers$1.each(tooltipItems, (function(tooltipItem) {
                            var bodyItem = {
                                before: [],
                                lines: [],
                                after: []
                            };
                            pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));
                            pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
                            pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));
                            bodyItems.push(bodyItem);
                        }));
                        return bodyItems;
                    },
                    getAfterBody: function() {
                        return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
                    },
                    getFooter: function() {
                        var me = this;
                        var callbacks = me._options.callbacks;
                        var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
                        var footer = callbacks.footer.apply(me, arguments);
                        var afterFooter = callbacks.afterFooter.apply(me, arguments);
                        var lines = [];
                        lines = pushOrConcat(lines, splitNewlines(beforeFooter));
                        lines = pushOrConcat(lines, splitNewlines(footer));
                        lines = pushOrConcat(lines, splitNewlines(afterFooter));
                        return lines;
                    },
                    update: function(changed) {
                        var me = this;
                        var opts = me._options;
                        var existingModel = me._model;
                        var model = me._model = getBaseModel(opts);
                        var active = me._active;
                        var data = me._data;
                        var alignment = {
                            xAlign: existingModel.xAlign,
                            yAlign: existingModel.yAlign
                        };
                        var backgroundPoint = {
                            x: existingModel.x,
                            y: existingModel.y
                        };
                        var tooltipSize = {
                            width: existingModel.width,
                            height: existingModel.height
                        };
                        var tooltipPosition = {
                            x: existingModel.caretX,
                            y: existingModel.caretY
                        };
                        var i, len;
                        if (active.length) {
                            model.opacity = 1;
                            var labelColors = [];
                            var labelTextColors = [];
                            tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);
                            var tooltipItems = [];
                            for (i = 0, len = active.length; i < len; ++i) tooltipItems.push(createTooltipItem(active[i]));
                            if (opts.filter) tooltipItems = tooltipItems.filter((function(a) {
                                return opts.filter(a, data);
                            }));
                            if (opts.itemSort) tooltipItems = tooltipItems.sort((function(a, b) {
                                return opts.itemSort(a, b, data);
                            }));
                            helpers$1.each(tooltipItems, (function(tooltipItem) {
                                labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
                                labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
                            }));
                            model.title = me.getTitle(tooltipItems, data);
                            model.beforeBody = me.getBeforeBody(tooltipItems, data);
                            model.body = me.getBody(tooltipItems, data);
                            model.afterBody = me.getAfterBody(tooltipItems, data);
                            model.footer = me.getFooter(tooltipItems, data);
                            model.x = tooltipPosition.x;
                            model.y = tooltipPosition.y;
                            model.caretPadding = opts.caretPadding;
                            model.labelColors = labelColors;
                            model.labelTextColors = labelTextColors;
                            model.dataPoints = tooltipItems;
                            tooltipSize = getTooltipSize(this, model);
                            alignment = determineAlignment(this, tooltipSize);
                            backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
                        } else model.opacity = 0;
                        model.xAlign = alignment.xAlign;
                        model.yAlign = alignment.yAlign;
                        model.x = backgroundPoint.x;
                        model.y = backgroundPoint.y;
                        model.width = tooltipSize.width;
                        model.height = tooltipSize.height;
                        model.caretX = tooltipPosition.x;
                        model.caretY = tooltipPosition.y;
                        me._model = model;
                        if (changed && opts.custom) opts.custom.call(me, model);
                        return me;
                    },
                    drawCaret: function(tooltipPoint, size) {
                        var ctx = this._chart.ctx;
                        var vm = this._view;
                        var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
                        ctx.lineTo(caretPosition.x1, caretPosition.y1);
                        ctx.lineTo(caretPosition.x2, caretPosition.y2);
                        ctx.lineTo(caretPosition.x3, caretPosition.y3);
                    },
                    getCaretPosition: function(tooltipPoint, size, vm) {
                        var x1, x2, x3, y1, y2, y3;
                        var caretSize = vm.caretSize;
                        var cornerRadius = vm.cornerRadius;
                        var xAlign = vm.xAlign;
                        var yAlign = vm.yAlign;
                        var ptX = tooltipPoint.x;
                        var ptY = tooltipPoint.y;
                        var width = size.width;
                        var height = size.height;
                        if ("center" === yAlign) {
                            y2 = ptY + height / 2;
                            if ("left" === xAlign) {
                                x1 = ptX;
                                x2 = x1 - caretSize;
                                x3 = x1;
                                y1 = y2 + caretSize;
                                y3 = y2 - caretSize;
                            } else {
                                x1 = ptX + width;
                                x2 = x1 + caretSize;
                                x3 = x1;
                                y1 = y2 - caretSize;
                                y3 = y2 + caretSize;
                            }
                        } else {
                            if ("left" === xAlign) {
                                x2 = ptX + cornerRadius + caretSize;
                                x1 = x2 - caretSize;
                                x3 = x2 + caretSize;
                            } else if ("right" === xAlign) {
                                x2 = ptX + width - cornerRadius - caretSize;
                                x1 = x2 - caretSize;
                                x3 = x2 + caretSize;
                            } else {
                                x2 = vm.caretX;
                                x1 = x2 - caretSize;
                                x3 = x2 + caretSize;
                            }
                            if ("top" === yAlign) {
                                y1 = ptY;
                                y2 = y1 - caretSize;
                                y3 = y1;
                            } else {
                                y1 = ptY + height;
                                y2 = y1 + caretSize;
                                y3 = y1;
                                var tmp = x3;
                                x3 = x1;
                                x1 = tmp;
                            }
                        }
                        return {
                            x1,
                            x2,
                            x3,
                            y1,
                            y2,
                            y3
                        };
                    },
                    drawTitle: function(pt, vm, ctx) {
                        var title = vm.title;
                        var length = title.length;
                        var titleFontSize, titleSpacing, i;
                        if (length) {
                            var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
                            pt.x = getAlignedX(vm, vm._titleAlign);
                            ctx.textAlign = rtlHelper.textAlign(vm._titleAlign);
                            ctx.textBaseline = "middle";
                            titleFontSize = vm.titleFontSize;
                            titleSpacing = vm.titleSpacing;
                            ctx.fillStyle = vm.titleFontColor;
                            ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
                            for (i = 0; i < length; ++i) {
                                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFontSize / 2);
                                pt.y += titleFontSize + titleSpacing;
                                if (i + 1 === length) pt.y += vm.titleMarginBottom - titleSpacing;
                            }
                        }
                    },
                    drawBody: function(pt, vm, ctx) {
                        var bodyFontSize = vm.bodyFontSize;
                        var bodySpacing = vm.bodySpacing;
                        var bodyAlign = vm._bodyAlign;
                        var body = vm.body;
                        var drawColorBoxes = vm.displayColors;
                        var xLinePadding = 0;
                        var colorX = drawColorBoxes ? getAlignedX(vm, "left") : 0;
                        var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
                        var fillLineOfText = function(line) {
                            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyFontSize / 2);
                            pt.y += bodyFontSize + bodySpacing;
                        };
                        var bodyItem, textColor, labelColors, lines, i, j, ilen, jlen;
                        var bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
                        ctx.textAlign = bodyAlign;
                        ctx.textBaseline = "middle";
                        ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
                        pt.x = getAlignedX(vm, bodyAlignForCalculation);
                        ctx.fillStyle = vm.bodyFontColor;
                        helpers$1.each(vm.beforeBody, fillLineOfText);
                        xLinePadding = drawColorBoxes && "right" !== bodyAlignForCalculation ? "center" === bodyAlign ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0;
                        for (i = 0, ilen = body.length; i < ilen; ++i) {
                            bodyItem = body[i];
                            textColor = vm.labelTextColors[i];
                            labelColors = vm.labelColors[i];
                            ctx.fillStyle = textColor;
                            helpers$1.each(bodyItem.before, fillLineOfText);
                            lines = bodyItem.lines;
                            for (j = 0, jlen = lines.length; j < jlen; ++j) {
                                if (drawColorBoxes) {
                                    var rtlColorX = rtlHelper.x(colorX);
                                    ctx.fillStyle = vm.legendColorBackground;
                                    ctx.fillRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize);
                                    ctx.lineWidth = 1;
                                    ctx.strokeStyle = labelColors.borderColor;
                                    ctx.strokeRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize);
                                    ctx.fillStyle = labelColors.backgroundColor;
                                    ctx.fillRect(rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), bodyFontSize - 2), pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
                                    ctx.fillStyle = textColor;
                                }
                                fillLineOfText(lines[j]);
                            }
                            helpers$1.each(bodyItem.after, fillLineOfText);
                        }
                        xLinePadding = 0;
                        helpers$1.each(vm.afterBody, fillLineOfText);
                        pt.y -= bodySpacing;
                    },
                    drawFooter: function(pt, vm, ctx) {
                        var footer = vm.footer;
                        var length = footer.length;
                        var footerFontSize, i;
                        if (length) {
                            var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
                            pt.x = getAlignedX(vm, vm._footerAlign);
                            pt.y += vm.footerMarginTop;
                            ctx.textAlign = rtlHelper.textAlign(vm._footerAlign);
                            ctx.textBaseline = "middle";
                            footerFontSize = vm.footerFontSize;
                            ctx.fillStyle = vm.footerFontColor;
                            ctx.font = helpers$1.fontString(footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
                            for (i = 0; i < length; ++i) {
                                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFontSize / 2);
                                pt.y += footerFontSize + vm.footerSpacing;
                            }
                        }
                    },
                    drawBackground: function(pt, vm, ctx, tooltipSize) {
                        ctx.fillStyle = vm.backgroundColor;
                        ctx.strokeStyle = vm.borderColor;
                        ctx.lineWidth = vm.borderWidth;
                        var xAlign = vm.xAlign;
                        var yAlign = vm.yAlign;
                        var x = pt.x;
                        var y = pt.y;
                        var width = tooltipSize.width;
                        var height = tooltipSize.height;
                        var radius = vm.cornerRadius;
                        ctx.beginPath();
                        ctx.moveTo(x + radius, y);
                        if ("top" === yAlign) this.drawCaret(pt, tooltipSize);
                        ctx.lineTo(x + width - radius, y);
                        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                        if ("center" === yAlign && "right" === xAlign) this.drawCaret(pt, tooltipSize);
                        ctx.lineTo(x + width, y + height - radius);
                        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                        if ("bottom" === yAlign) this.drawCaret(pt, tooltipSize);
                        ctx.lineTo(x + radius, y + height);
                        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                        if ("center" === yAlign && "left" === xAlign) this.drawCaret(pt, tooltipSize);
                        ctx.lineTo(x, y + radius);
                        ctx.quadraticCurveTo(x, y, x + radius, y);
                        ctx.closePath();
                        ctx.fill();
                        if (vm.borderWidth > 0) ctx.stroke();
                    },
                    draw: function() {
                        var ctx = this._chart.ctx;
                        var vm = this._view;
                        if (0 === vm.opacity) return;
                        var tooltipSize = {
                            width: vm.width,
                            height: vm.height
                        };
                        var pt = {
                            x: vm.x,
                            y: vm.y
                        };
                        var opacity = Math.abs(vm.opacity < .001) ? 0 : vm.opacity;
                        var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;
                        if (this._options.enabled && hasTooltipContent) {
                            ctx.save();
                            ctx.globalAlpha = opacity;
                            this.drawBackground(pt, vm, ctx, tooltipSize);
                            pt.y += vm.yPadding;
                            helpers$1.rtl.overrideTextDirection(ctx, vm.textDirection);
                            this.drawTitle(pt, vm, ctx);
                            this.drawBody(pt, vm, ctx);
                            this.drawFooter(pt, vm, ctx);
                            helpers$1.rtl.restoreTextDirection(ctx, vm.textDirection);
                            ctx.restore();
                        }
                    },
                    handleEvent: function(e) {
                        var me = this;
                        var options = me._options;
                        var changed = false;
                        me._lastActive = me._lastActive || [];
                        if ("mouseout" === e.type) me._active = []; else {
                            me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
                            if (options.reverse) me._active.reverse();
                        }
                        changed = !helpers$1.arrayEquals(me._active, me._lastActive);
                        if (changed) {
                            me._lastActive = me._active;
                            if (options.enabled || options.custom) {
                                me._eventPosition = {
                                    x: e.x,
                                    y: e.y
                                };
                                me.update(true);
                                me.pivot();
                            }
                        }
                        return changed;
                    }
                });
                var positioners_1 = positioners;
                var core_tooltip = exports$4;
                core_tooltip.positioners = positioners_1;
                var valueOrDefault$9 = helpers$1.valueOrDefault;
                core_defaults._set("global", {
                    elements: {},
                    events: [ "mousemove", "mouseout", "click", "touchstart", "touchmove" ],
                    hover: {
                        onHover: null,
                        mode: "nearest",
                        intersect: true,
                        animationDuration: 400
                    },
                    onClick: null,
                    maintainAspectRatio: true,
                    responsive: true,
                    responsiveAnimationDuration: 0
                });
                function mergeScaleConfig() {
                    return helpers$1.merge(Object.create(null), [].slice.call(arguments), {
                        merger: function(key, target, source, options) {
                            if ("xAxes" === key || "yAxes" === key) {
                                var slen = source[key].length;
                                var i, type, scale;
                                if (!target[key]) target[key] = [];
                                for (i = 0; i < slen; ++i) {
                                    scale = source[key][i];
                                    type = valueOrDefault$9(scale.type, "xAxes" === key ? "category" : "linear");
                                    if (i >= target[key].length) target[key].push({});
                                    if (!target[key][i].type || scale.type && scale.type !== target[key][i].type) helpers$1.merge(target[key][i], [ core_scaleService.getScaleDefaults(type), scale ]); else helpers$1.merge(target[key][i], scale);
                                }
                            } else helpers$1._merger(key, target, source, options);
                        }
                    });
                }
                function mergeConfig() {
                    return helpers$1.merge(Object.create(null), [].slice.call(arguments), {
                        merger: function(key, target, source, options) {
                            var tval = target[key] || Object.create(null);
                            var sval = source[key];
                            if ("scales" === key) target[key] = mergeScaleConfig(tval, sval); else if ("scale" === key) target[key] = helpers$1.merge(tval, [ core_scaleService.getScaleDefaults(sval.type), sval ]); else helpers$1._merger(key, target, source, options);
                        }
                    });
                }
                function initConfig(config) {
                    config = config || Object.create(null);
                    var data = config.data = config.data || {};
                    data.datasets = data.datasets || [];
                    data.labels = data.labels || [];
                    config.options = mergeConfig(core_defaults.global, core_defaults[config.type], config.options || {});
                    return config;
                }
                function updateConfig(chart) {
                    var newOptions = chart.options;
                    helpers$1.each(chart.scales, (function(scale) {
                        core_layouts.removeBox(chart, scale);
                    }));
                    newOptions = mergeConfig(core_defaults.global, core_defaults[chart.config.type], newOptions);
                    chart.options = chart.config.options = newOptions;
                    chart.ensureScalesHaveIDs();
                    chart.buildOrUpdateScales();
                    chart.tooltip._options = newOptions.tooltips;
                    chart.tooltip.initialize();
                }
                function nextAvailableScaleId(axesOpts, prefix, index) {
                    var id;
                    var hasId = function(obj) {
                        return obj.id === id;
                    };
                    do {
                        id = prefix + index++;
                    } while (helpers$1.findIndex(axesOpts, hasId) >= 0);
                    return id;
                }
                function positionIsHorizontal(position) {
                    return "top" === position || "bottom" === position;
                }
                function compare2Level(l1, l2) {
                    return function(a, b) {
                        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
                    };
                }
                var Chart = function(item, config) {
                    this.construct(item, config);
                    return this;
                };
                helpers$1.extend(Chart.prototype, {
                    construct: function(item, config) {
                        var me = this;
                        config = initConfig(config);
                        var context = platform.acquireContext(item, config);
                        var canvas = context && context.canvas;
                        var height = canvas && canvas.height;
                        var width = canvas && canvas.width;
                        me.id = helpers$1.uid();
                        me.ctx = context;
                        me.canvas = canvas;
                        me.config = config;
                        me.width = width;
                        me.height = height;
                        me.aspectRatio = height ? width / height : null;
                        me.options = config.options;
                        me._bufferedRender = false;
                        me._layers = [];
                        me.chart = me;
                        me.controller = me;
                        Chart.instances[me.id] = me;
                        Object.defineProperty(me, "data", {
                            get: function() {
                                return me.config.data;
                            },
                            set: function(value) {
                                me.config.data = value;
                            }
                        });
                        if (!context || !canvas) {
                            console.error("Failed to create chart: can't acquire context from the given item");
                            return;
                        }
                        me.initialize();
                        me.update();
                    },
                    initialize: function() {
                        var me = this;
                        core_plugins.notify(me, "beforeInit");
                        helpers$1.retinaScale(me, me.options.devicePixelRatio);
                        me.bindEvents();
                        if (me.options.responsive) me.resize(true);
                        me.initToolTip();
                        core_plugins.notify(me, "afterInit");
                        return me;
                    },
                    clear: function() {
                        helpers$1.canvas.clear(this);
                        return this;
                    },
                    stop: function() {
                        core_animations.cancelAnimation(this);
                        return this;
                    },
                    resize: function(silent) {
                        var me = this;
                        var options = me.options;
                        var canvas = me.canvas;
                        var aspectRatio = options.maintainAspectRatio && me.aspectRatio || null;
                        var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas)));
                        var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas)));
                        if (me.width === newWidth && me.height === newHeight) return;
                        canvas.width = me.width = newWidth;
                        canvas.height = me.height = newHeight;
                        canvas.style.width = newWidth + "px";
                        canvas.style.height = newHeight + "px";
                        helpers$1.retinaScale(me, options.devicePixelRatio);
                        if (!silent) {
                            var newSize = {
                                width: newWidth,
                                height: newHeight
                            };
                            core_plugins.notify(me, "resize", [ newSize ]);
                            if (options.onResize) options.onResize(me, newSize);
                            me.stop();
                            me.update({
                                duration: options.responsiveAnimationDuration
                            });
                        }
                    },
                    ensureScalesHaveIDs: function() {
                        var options = this.options;
                        var scalesOptions = options.scales || {};
                        var scaleOptions = options.scale;
                        helpers$1.each(scalesOptions.xAxes, (function(xAxisOptions, index) {
                            if (!xAxisOptions.id) xAxisOptions.id = nextAvailableScaleId(scalesOptions.xAxes, "x-axis-", index);
                        }));
                        helpers$1.each(scalesOptions.yAxes, (function(yAxisOptions, index) {
                            if (!yAxisOptions.id) yAxisOptions.id = nextAvailableScaleId(scalesOptions.yAxes, "y-axis-", index);
                        }));
                        if (scaleOptions) scaleOptions.id = scaleOptions.id || "scale";
                    },
                    buildOrUpdateScales: function() {
                        var me = this;
                        var options = me.options;
                        var scales = me.scales || {};
                        var items = [];
                        var updated = Object.keys(scales).reduce((function(obj, id) {
                            obj[id] = false;
                            return obj;
                        }), {});
                        if (options.scales) items = items.concat((options.scales.xAxes || []).map((function(xAxisOptions) {
                            return {
                                options: xAxisOptions,
                                dtype: "category",
                                dposition: "bottom"
                            };
                        })), (options.scales.yAxes || []).map((function(yAxisOptions) {
                            return {
                                options: yAxisOptions,
                                dtype: "linear",
                                dposition: "left"
                            };
                        })));
                        if (options.scale) items.push({
                            options: options.scale,
                            dtype: "radialLinear",
                            isDefault: true,
                            dposition: "chartArea"
                        });
                        helpers$1.each(items, (function(item) {
                            var scaleOptions = item.options;
                            var id = scaleOptions.id;
                            var scaleType = valueOrDefault$9(scaleOptions.type, item.dtype);
                            if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) scaleOptions.position = item.dposition;
                            updated[id] = true;
                            var scale = null;
                            if (id in scales && scales[id].type === scaleType) {
                                scale = scales[id];
                                scale.options = scaleOptions;
                                scale.ctx = me.ctx;
                                scale.chart = me;
                            } else {
                                var scaleClass = core_scaleService.getScaleConstructor(scaleType);
                                if (!scaleClass) return;
                                scale = new scaleClass({
                                    id,
                                    type: scaleType,
                                    options: scaleOptions,
                                    ctx: me.ctx,
                                    chart: me
                                });
                                scales[scale.id] = scale;
                            }
                            scale.mergeTicksOptions();
                            if (item.isDefault) me.scale = scale;
                        }));
                        helpers$1.each(updated, (function(hasUpdated, id) {
                            if (!hasUpdated) delete scales[id];
                        }));
                        me.scales = scales;
                        core_scaleService.addScalesToLayout(this);
                    },
                    buildOrUpdateControllers: function() {
                        var me = this;
                        var newControllers = [];
                        var datasets = me.data.datasets;
                        var i, ilen;
                        for (i = 0, ilen = datasets.length; i < ilen; i++) {
                            var dataset = datasets[i];
                            var meta = me.getDatasetMeta(i);
                            var type = dataset.type || me.config.type;
                            if (meta.type && meta.type !== type) {
                                me.destroyDatasetMeta(i);
                                meta = me.getDatasetMeta(i);
                            }
                            meta.type = type;
                            meta.order = dataset.order || 0;
                            meta.index = i;
                            if (meta.controller) {
                                meta.controller.updateIndex(i);
                                meta.controller.linkScales();
                            } else {
                                var ControllerClass = controllers[meta.type];
                                if (void 0 === ControllerClass) throw new Error('"' + meta.type + '" is not a chart type.');
                                meta.controller = new ControllerClass(me, i);
                                newControllers.push(meta.controller);
                            }
                        }
                        return newControllers;
                    },
                    resetElements: function() {
                        var me = this;
                        helpers$1.each(me.data.datasets, (function(dataset, datasetIndex) {
                            me.getDatasetMeta(datasetIndex).controller.reset();
                        }), me);
                    },
                    reset: function() {
                        this.resetElements();
                        this.tooltip.initialize();
                    },
                    update: function(config) {
                        var me = this;
                        var i, ilen;
                        if (!config || "object" !== typeof config) config = {
                            duration: config,
                            lazy: arguments[1]
                        };
                        updateConfig(me);
                        core_plugins._invalidate(me);
                        if (false === core_plugins.notify(me, "beforeUpdate")) return;
                        me.tooltip._data = me.data;
                        var newControllers = me.buildOrUpdateControllers();
                        for (i = 0, ilen = me.data.datasets.length; i < ilen; i++) me.getDatasetMeta(i).controller.buildOrUpdateElements();
                        me.updateLayout();
                        if (me.options.animation && me.options.animation.duration) helpers$1.each(newControllers, (function(controller) {
                            controller.reset();
                        }));
                        me.updateDatasets();
                        me.tooltip.initialize();
                        me.lastActive = [];
                        core_plugins.notify(me, "afterUpdate");
                        me._layers.sort(compare2Level("z", "_idx"));
                        if (me._bufferedRender) me._bufferedRequest = {
                            duration: config.duration,
                            easing: config.easing,
                            lazy: config.lazy
                        }; else me.render(config);
                    },
                    updateLayout: function() {
                        var me = this;
                        if (false === core_plugins.notify(me, "beforeLayout")) return;
                        core_layouts.update(this, this.width, this.height);
                        me._layers = [];
                        helpers$1.each(me.boxes, (function(box) {
                            if (box._configure) box._configure();
                            me._layers.push.apply(me._layers, box._layers());
                        }), me);
                        me._layers.forEach((function(item, index) {
                            item._idx = index;
                        }));
                        core_plugins.notify(me, "afterScaleUpdate");
                        core_plugins.notify(me, "afterLayout");
                    },
                    updateDatasets: function() {
                        var me = this;
                        if (false === core_plugins.notify(me, "beforeDatasetsUpdate")) return;
                        for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) me.updateDataset(i);
                        core_plugins.notify(me, "afterDatasetsUpdate");
                    },
                    updateDataset: function(index) {
                        var me = this;
                        var meta = me.getDatasetMeta(index);
                        var args = {
                            meta,
                            index
                        };
                        if (false === core_plugins.notify(me, "beforeDatasetUpdate", [ args ])) return;
                        meta.controller._update();
                        core_plugins.notify(me, "afterDatasetUpdate", [ args ]);
                    },
                    render: function(config) {
                        var me = this;
                        if (!config || "object" !== typeof config) config = {
                            duration: config,
                            lazy: arguments[1]
                        };
                        var animationOptions = me.options.animation;
                        var duration = valueOrDefault$9(config.duration, animationOptions && animationOptions.duration);
                        var lazy = config.lazy;
                        if (false === core_plugins.notify(me, "beforeRender")) return;
                        var onComplete = function(animation) {
                            core_plugins.notify(me, "afterRender");
                            helpers$1.callback(animationOptions && animationOptions.onComplete, [ animation ], me);
                        };
                        if (animationOptions && duration) {
                            var animation = new core_animation({
                                numSteps: duration / 16.66,
                                easing: config.easing || animationOptions.easing,
                                render: function(chart, animationObject) {
                                    var easingFunction = helpers$1.easing.effects[animationObject.easing];
                                    var currentStep = animationObject.currentStep;
                                    var stepDecimal = currentStep / animationObject.numSteps;
                                    chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
                                },
                                onAnimationProgress: animationOptions.onProgress,
                                onAnimationComplete: onComplete
                            });
                            core_animations.addAnimation(me, animation, duration, lazy);
                        } else {
                            me.draw();
                            onComplete(new core_animation({
                                numSteps: 0,
                                chart: me
                            }));
                        }
                        return me;
                    },
                    draw: function(easingValue) {
                        var me = this;
                        var i, layers;
                        me.clear();
                        if (helpers$1.isNullOrUndef(easingValue)) easingValue = 1;
                        me.transition(easingValue);
                        if (me.width <= 0 || me.height <= 0) return;
                        if (false === core_plugins.notify(me, "beforeDraw", [ easingValue ])) return;
                        layers = me._layers;
                        for (i = 0; i < layers.length && layers[i].z <= 0; ++i) layers[i].draw(me.chartArea);
                        me.drawDatasets(easingValue);
                        for (;i < layers.length; ++i) layers[i].draw(me.chartArea);
                        me._drawTooltip(easingValue);
                        core_plugins.notify(me, "afterDraw", [ easingValue ]);
                    },
                    transition: function(easingValue) {
                        var me = this;
                        for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) if (me.isDatasetVisible(i)) me.getDatasetMeta(i).controller.transition(easingValue);
                        me.tooltip.transition(easingValue);
                    },
                    _getSortedDatasetMetas: function(filterVisible) {
                        var me = this;
                        var datasets = me.data.datasets || [];
                        var result = [];
                        var i, ilen;
                        for (i = 0, ilen = datasets.length; i < ilen; ++i) if (!filterVisible || me.isDatasetVisible(i)) result.push(me.getDatasetMeta(i));
                        result.sort(compare2Level("order", "index"));
                        return result;
                    },
                    _getSortedVisibleDatasetMetas: function() {
                        return this._getSortedDatasetMetas(true);
                    },
                    drawDatasets: function(easingValue) {
                        var me = this;
                        var metasets, i;
                        if (false === core_plugins.notify(me, "beforeDatasetsDraw", [ easingValue ])) return;
                        metasets = me._getSortedVisibleDatasetMetas();
                        for (i = metasets.length - 1; i >= 0; --i) me.drawDataset(metasets[i], easingValue);
                        core_plugins.notify(me, "afterDatasetsDraw", [ easingValue ]);
                    },
                    drawDataset: function(meta, easingValue) {
                        var me = this;
                        var args = {
                            meta,
                            index: meta.index,
                            easingValue
                        };
                        if (false === core_plugins.notify(me, "beforeDatasetDraw", [ args ])) return;
                        meta.controller.draw(easingValue);
                        core_plugins.notify(me, "afterDatasetDraw", [ args ]);
                    },
                    _drawTooltip: function(easingValue) {
                        var me = this;
                        var tooltip = me.tooltip;
                        var args = {
                            tooltip,
                            easingValue
                        };
                        if (false === core_plugins.notify(me, "beforeTooltipDraw", [ args ])) return;
                        tooltip.draw();
                        core_plugins.notify(me, "afterTooltipDraw", [ args ]);
                    },
                    getElementAtEvent: function(e) {
                        return core_interaction.modes.single(this, e);
                    },
                    getElementsAtEvent: function(e) {
                        return core_interaction.modes.label(this, e, {
                            intersect: true
                        });
                    },
                    getElementsAtXAxis: function(e) {
                        return core_interaction.modes["x-axis"](this, e, {
                            intersect: true
                        });
                    },
                    getElementsAtEventForMode: function(e, mode, options) {
                        var method = core_interaction.modes[mode];
                        if ("function" === typeof method) return method(this, e, options);
                        return [];
                    },
                    getDatasetAtEvent: function(e) {
                        return core_interaction.modes.dataset(this, e, {
                            intersect: true
                        });
                    },
                    getDatasetMeta: function(datasetIndex) {
                        var me = this;
                        var dataset = me.data.datasets[datasetIndex];
                        if (!dataset._meta) dataset._meta = {};
                        var meta = dataset._meta[me.id];
                        if (!meta) meta = dataset._meta[me.id] = {
                            type: null,
                            data: [],
                            dataset: null,
                            controller: null,
                            hidden: null,
                            xAxisID: null,
                            yAxisID: null,
                            order: dataset.order || 0,
                            index: datasetIndex
                        };
                        return meta;
                    },
                    getVisibleDatasetCount: function() {
                        var count = 0;
                        for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) if (this.isDatasetVisible(i)) count++;
                        return count;
                    },
                    isDatasetVisible: function(datasetIndex) {
                        var meta = this.getDatasetMeta(datasetIndex);
                        return "boolean" === typeof meta.hidden ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
                    },
                    generateLegend: function() {
                        return this.options.legendCallback(this);
                    },
                    destroyDatasetMeta: function(datasetIndex) {
                        var id = this.id;
                        var dataset = this.data.datasets[datasetIndex];
                        var meta = dataset._meta && dataset._meta[id];
                        if (meta) {
                            meta.controller.destroy();
                            delete dataset._meta[id];
                        }
                    },
                    destroy: function() {
                        var me = this;
                        var canvas = me.canvas;
                        var i, ilen;
                        me.stop();
                        for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) me.destroyDatasetMeta(i);
                        if (canvas) {
                            me.unbindEvents();
                            helpers$1.canvas.clear(me);
                            platform.releaseContext(me.ctx);
                            me.canvas = null;
                            me.ctx = null;
                        }
                        core_plugins.notify(me, "destroy");
                        delete Chart.instances[me.id];
                    },
                    toBase64Image: function() {
                        return this.canvas.toDataURL.apply(this.canvas, arguments);
                    },
                    initToolTip: function() {
                        var me = this;
                        me.tooltip = new core_tooltip({
                            _chart: me,
                            _chartInstance: me,
                            _data: me.data,
                            _options: me.options.tooltips
                        }, me);
                    },
                    bindEvents: function() {
                        var me = this;
                        var listeners = me._listeners = {};
                        var listener = function() {
                            me.eventHandler.apply(me, arguments);
                        };
                        helpers$1.each(me.options.events, (function(type) {
                            platform.addEventListener(me, type, listener);
                            listeners[type] = listener;
                        }));
                        if (me.options.responsive) {
                            listener = function() {
                                me.resize();
                            };
                            platform.addEventListener(me, "resize", listener);
                            listeners.resize = listener;
                        }
                    },
                    unbindEvents: function() {
                        var me = this;
                        var listeners = me._listeners;
                        if (!listeners) return;
                        delete me._listeners;
                        helpers$1.each(listeners, (function(listener, type) {
                            platform.removeEventListener(me, type, listener);
                        }));
                    },
                    updateHoverStyle: function(elements, mode, enabled) {
                        var prefix = enabled ? "set" : "remove";
                        var element, i, ilen;
                        for (i = 0, ilen = elements.length; i < ilen; ++i) {
                            element = elements[i];
                            if (element) this.getDatasetMeta(element._datasetIndex).controller[prefix + "HoverStyle"](element);
                        }
                        if ("dataset" === mode) this.getDatasetMeta(elements[0]._datasetIndex).controller["_" + prefix + "DatasetHoverStyle"]();
                    },
                    eventHandler: function(e) {
                        var me = this;
                        var tooltip = me.tooltip;
                        if (false === core_plugins.notify(me, "beforeEvent", [ e ])) return;
                        me._bufferedRender = true;
                        me._bufferedRequest = null;
                        var changed = me.handleEvent(e);
                        if (tooltip) changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);
                        core_plugins.notify(me, "afterEvent", [ e ]);
                        var bufferedRequest = me._bufferedRequest;
                        if (bufferedRequest) me.render(bufferedRequest); else if (changed && !me.animating) {
                            me.stop();
                            me.render({
                                duration: me.options.hover.animationDuration,
                                lazy: true
                            });
                        }
                        me._bufferedRender = false;
                        me._bufferedRequest = null;
                        return me;
                    },
                    handleEvent: function(e) {
                        var me = this;
                        var options = me.options || {};
                        var hoverOptions = options.hover;
                        var changed = false;
                        me.lastActive = me.lastActive || [];
                        if ("mouseout" === e.type) me.active = []; else me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
                        helpers$1.callback(options.onHover || options.hover.onHover, [ e.native, me.active ], me);
                        if ("mouseup" === e.type || "click" === e.type) if (options.onClick) options.onClick.call(me, e.native, me.active);
                        if (me.lastActive.length) me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
                        if (me.active.length && hoverOptions.mode) me.updateHoverStyle(me.active, hoverOptions.mode, true);
                        changed = !helpers$1.arrayEquals(me.active, me.lastActive);
                        me.lastActive = me.active;
                        return changed;
                    }
                });
                Chart.instances = {};
                var core_controller = Chart;
                Chart.Controller = Chart;
                Chart.types = {};
                helpers$1.configMerge = mergeConfig;
                helpers$1.scaleMerge = mergeScaleConfig;
                var core_helpers = function() {
                    helpers$1.where = function(collection, filterCallback) {
                        if (helpers$1.isArray(collection) && Array.prototype.filter) return collection.filter(filterCallback);
                        var filtered = [];
                        helpers$1.each(collection, (function(item) {
                            if (filterCallback(item)) filtered.push(item);
                        }));
                        return filtered;
                    };
                    helpers$1.findIndex = Array.prototype.findIndex ? function(array, callback, scope) {
                        return array.findIndex(callback, scope);
                    } : function(array, callback, scope) {
                        scope = void 0 === scope ? array : scope;
                        for (var i = 0, ilen = array.length; i < ilen; ++i) if (callback.call(scope, array[i], i, array)) return i;
                        return -1;
                    };
                    helpers$1.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
                        if (helpers$1.isNullOrUndef(startIndex)) startIndex = -1;
                        for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
                            var currentItem = arrayToSearch[i];
                            if (filterCallback(currentItem)) return currentItem;
                        }
                    };
                    helpers$1.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
                        if (helpers$1.isNullOrUndef(startIndex)) startIndex = arrayToSearch.length;
                        for (var i = startIndex - 1; i >= 0; i--) {
                            var currentItem = arrayToSearch[i];
                            if (filterCallback(currentItem)) return currentItem;
                        }
                    };
                    helpers$1.isNumber = function(n) {
                        return !isNaN(parseFloat(n)) && isFinite(n);
                    };
                    helpers$1.almostEquals = function(x, y, epsilon) {
                        return Math.abs(x - y) < epsilon;
                    };
                    helpers$1.almostWhole = function(x, epsilon) {
                        var rounded = Math.round(x);
                        return rounded - epsilon <= x && rounded + epsilon >= x;
                    };
                    helpers$1.max = function(array) {
                        return array.reduce((function(max, value) {
                            if (!isNaN(value)) return Math.max(max, value);
                            return max;
                        }), Number.NEGATIVE_INFINITY);
                    };
                    helpers$1.min = function(array) {
                        return array.reduce((function(min, value) {
                            if (!isNaN(value)) return Math.min(min, value);
                            return min;
                        }), Number.POSITIVE_INFINITY);
                    };
                    helpers$1.sign = Math.sign ? function(x) {
                        return Math.sign(x);
                    } : function(x) {
                        x = +x;
                        if (0 === x || isNaN(x)) return x;
                        return x > 0 ? 1 : -1;
                    };
                    helpers$1.toRadians = function(degrees) {
                        return degrees * (Math.PI / 180);
                    };
                    helpers$1.toDegrees = function(radians) {
                        return radians * (180 / Math.PI);
                    };
                    helpers$1._decimalPlaces = function(x) {
                        if (!helpers$1.isFinite(x)) return;
                        var e = 1;
                        var p = 0;
                        while (Math.round(x * e) / e !== x) {
                            e *= 10;
                            p++;
                        }
                        return p;
                    };
                    helpers$1.getAngleFromPoint = function(centrePoint, anglePoint) {
                        var distanceFromXCenter = anglePoint.x - centrePoint.x;
                        var distanceFromYCenter = anglePoint.y - centrePoint.y;
                        var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
                        var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
                        if (angle < -.5 * Math.PI) angle += 2 * Math.PI;
                        return {
                            angle,
                            distance: radialDistanceFromCenter
                        };
                    };
                    helpers$1.distanceBetweenPoints = function(pt1, pt2) {
                        return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
                    };
                    helpers$1.aliasPixel = function(pixelWidth) {
                        return pixelWidth % 2 === 0 ? 0 : .5;
                    };
                    helpers$1._alignPixel = function(chart, pixel, width) {
                        var devicePixelRatio = chart.currentDevicePixelRatio;
                        var halfWidth = width / 2;
                        return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
                    };
                    helpers$1.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {
                        var previous = firstPoint.skip ? middlePoint : firstPoint;
                        var current = middlePoint;
                        var next = afterPoint.skip ? middlePoint : afterPoint;
                        var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
                        var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
                        var s01 = d01 / (d01 + d12);
                        var s12 = d12 / (d01 + d12);
                        s01 = isNaN(s01) ? 0 : s01;
                        s12 = isNaN(s12) ? 0 : s12;
                        var fa = t * s01;
                        var fb = t * s12;
                        return {
                            previous: {
                                x: current.x - fa * (next.x - previous.x),
                                y: current.y - fa * (next.y - previous.y)
                            },
                            next: {
                                x: current.x + fb * (next.x - previous.x),
                                y: current.y + fb * (next.y - previous.y)
                            }
                        };
                    };
                    helpers$1.EPSILON = Number.EPSILON || 1e-14;
                    helpers$1.splineCurveMonotone = function(points) {
                        var pointsWithTangents = (points || []).map((function(point) {
                            return {
                                model: point._model,
                                deltaK: 0,
                                mK: 0
                            };
                        }));
                        var pointsLen = pointsWithTangents.length;
                        var i, pointBefore, pointCurrent, pointAfter;
                        for (i = 0; i < pointsLen; ++i) {
                            pointCurrent = pointsWithTangents[i];
                            if (pointCurrent.model.skip) continue;
                            pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
                            pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
                            if (pointAfter && !pointAfter.model.skip) {
                                var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x;
                                pointCurrent.deltaK = 0 !== slopeDeltaX ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
                            }
                            if (!pointBefore || pointBefore.model.skip) pointCurrent.mK = pointCurrent.deltaK; else if (!pointAfter || pointAfter.model.skip) pointCurrent.mK = pointBefore.deltaK; else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) pointCurrent.mK = 0; else pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
                        }
                        var alphaK, betaK, tauK, squaredMagnitude;
                        for (i = 0; i < pointsLen - 1; ++i) {
                            pointCurrent = pointsWithTangents[i];
                            pointAfter = pointsWithTangents[i + 1];
                            if (pointCurrent.model.skip || pointAfter.model.skip) continue;
                            if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
                                pointCurrent.mK = pointAfter.mK = 0;
                                continue;
                            }
                            alphaK = pointCurrent.mK / pointCurrent.deltaK;
                            betaK = pointAfter.mK / pointCurrent.deltaK;
                            squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
                            if (squaredMagnitude <= 9) continue;
                            tauK = 3 / Math.sqrt(squaredMagnitude);
                            pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
                            pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
                        }
                        var deltaX;
                        for (i = 0; i < pointsLen; ++i) {
                            pointCurrent = pointsWithTangents[i];
                            if (pointCurrent.model.skip) continue;
                            pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
                            pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
                            if (pointBefore && !pointBefore.model.skip) {
                                deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
                                pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
                                pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
                            }
                            if (pointAfter && !pointAfter.model.skip) {
                                deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
                                pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
                                pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
                            }
                        }
                    };
                    helpers$1.nextItem = function(collection, index, loop) {
                        if (loop) return index >= collection.length - 1 ? collection[0] : collection[index + 1];
                        return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
                    };
                    helpers$1.previousItem = function(collection, index, loop) {
                        if (loop) return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
                        return index <= 0 ? collection[0] : collection[index - 1];
                    };
                    helpers$1.niceNum = function(range, round) {
                        var exponent = Math.floor(helpers$1.log10(range));
                        var fraction = range / Math.pow(10, exponent);
                        var niceFraction;
                        if (round) if (fraction < 1.5) niceFraction = 1; else if (fraction < 3) niceFraction = 2; else if (fraction < 7) niceFraction = 5; else niceFraction = 10; else if (fraction <= 1) niceFraction = 1; else if (fraction <= 2) niceFraction = 2; else if (fraction <= 5) niceFraction = 5; else niceFraction = 10;
                        return niceFraction * Math.pow(10, exponent);
                    };
                    helpers$1.requestAnimFrame = function() {
                        if ("undefined" === typeof window) return function(callback) {
                            callback();
                        };
                        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
                            return window.setTimeout(callback, 1e3 / 60);
                        };
                    }();
                    helpers$1.getRelativePosition = function(evt, chart) {
                        var mouseX, mouseY;
                        var e = evt.originalEvent || evt;
                        var canvas = evt.target || evt.srcElement;
                        var boundingRect = canvas.getBoundingClientRect();
                        var touches = e.touches;
                        if (touches && touches.length > 0) {
                            mouseX = touches[0].clientX;
                            mouseY = touches[0].clientY;
                        } else {
                            mouseX = e.clientX;
                            mouseY = e.clientY;
                        }
                        var paddingLeft = parseFloat(helpers$1.getStyle(canvas, "padding-left"));
                        var paddingTop = parseFloat(helpers$1.getStyle(canvas, "padding-top"));
                        var paddingRight = parseFloat(helpers$1.getStyle(canvas, "padding-right"));
                        var paddingBottom = parseFloat(helpers$1.getStyle(canvas, "padding-bottom"));
                        var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
                        var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;
                        mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);
                        mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);
                        return {
                            x: mouseX,
                            y: mouseY
                        };
                    };
                    function parseMaxStyle(styleValue, node, parentProperty) {
                        var valueInPixels;
                        if ("string" === typeof styleValue) {
                            valueInPixels = parseInt(styleValue, 10);
                            if (-1 !== styleValue.indexOf("%")) valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
                        } else valueInPixels = styleValue;
                        return valueInPixels;
                    }
                    function isConstrainedValue(value) {
                        return void 0 !== value && null !== value && "none" !== value;
                    }
                    function getConstraintDimension(domNode, maxStyle, percentageProperty) {
                        var view = document.defaultView;
                        var parentNode = helpers$1._getParentNode(domNode);
                        var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
                        var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
                        var hasCNode = isConstrainedValue(constrainedNode);
                        var hasCContainer = isConstrainedValue(constrainedContainer);
                        var infinity = Number.POSITIVE_INFINITY;
                        if (hasCNode || hasCContainer) return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
                        return "none";
                    }
                    helpers$1.getConstraintWidth = function(domNode) {
                        return getConstraintDimension(domNode, "max-width", "clientWidth");
                    };
                    helpers$1.getConstraintHeight = function(domNode) {
                        return getConstraintDimension(domNode, "max-height", "clientHeight");
                    };
                    helpers$1._calculatePadding = function(container, padding, parentDimension) {
                        padding = helpers$1.getStyle(container, padding);
                        return padding.indexOf("%") > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);
                    };
                    helpers$1._getParentNode = function(domNode) {
                        var parent = domNode.parentNode;
                        if (parent && "[object ShadowRoot]" === parent.toString()) parent = parent.host;
                        return parent;
                    };
                    helpers$1.getMaximumWidth = function(domNode) {
                        var container = helpers$1._getParentNode(domNode);
                        if (!container) return domNode.clientWidth;
                        var clientWidth = container.clientWidth;
                        var paddingLeft = helpers$1._calculatePadding(container, "padding-left", clientWidth);
                        var paddingRight = helpers$1._calculatePadding(container, "padding-right", clientWidth);
                        var w = clientWidth - paddingLeft - paddingRight;
                        var cw = helpers$1.getConstraintWidth(domNode);
                        return isNaN(cw) ? w : Math.min(w, cw);
                    };
                    helpers$1.getMaximumHeight = function(domNode) {
                        var container = helpers$1._getParentNode(domNode);
                        if (!container) return domNode.clientHeight;
                        var clientHeight = container.clientHeight;
                        var paddingTop = helpers$1._calculatePadding(container, "padding-top", clientHeight);
                        var paddingBottom = helpers$1._calculatePadding(container, "padding-bottom", clientHeight);
                        var h = clientHeight - paddingTop - paddingBottom;
                        var ch = helpers$1.getConstraintHeight(domNode);
                        return isNaN(ch) ? h : Math.min(h, ch);
                    };
                    helpers$1.getStyle = function(el, property) {
                        return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
                    };
                    helpers$1.retinaScale = function(chart, forceRatio) {
                        var pixelRatio = chart.currentDevicePixelRatio = forceRatio || "undefined" !== typeof window && window.devicePixelRatio || 1;
                        if (1 === pixelRatio) return;
                        var canvas = chart.canvas;
                        var height = chart.height;
                        var width = chart.width;
                        canvas.height = height * pixelRatio;
                        canvas.width = width * pixelRatio;
                        chart.ctx.scale(pixelRatio, pixelRatio);
                        if (!canvas.style.height && !canvas.style.width) {
                            canvas.style.height = height + "px";
                            canvas.style.width = width + "px";
                        }
                    };
                    helpers$1.fontString = function(pixelSize, fontStyle, fontFamily) {
                        return fontStyle + " " + pixelSize + "px " + fontFamily;
                    };
                    helpers$1.longestText = function(ctx, font, arrayOfThings, cache) {
                        cache = cache || {};
                        var data = cache.data = cache.data || {};
                        var gc = cache.garbageCollect = cache.garbageCollect || [];
                        if (cache.font !== font) {
                            data = cache.data = {};
                            gc = cache.garbageCollect = [];
                            cache.font = font;
                        }
                        ctx.font = font;
                        var longest = 0;
                        var ilen = arrayOfThings.length;
                        var i, j, jlen, thing, nestedThing;
                        for (i = 0; i < ilen; i++) {
                            thing = arrayOfThings[i];
                            if (void 0 !== thing && null !== thing && true !== helpers$1.isArray(thing)) longest = helpers$1.measureText(ctx, data, gc, longest, thing); else if (helpers$1.isArray(thing)) for (j = 0, 
                            jlen = thing.length; j < jlen; j++) {
                                nestedThing = thing[j];
                                if (void 0 !== nestedThing && null !== nestedThing && !helpers$1.isArray(nestedThing)) longest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);
                            }
                        }
                        var gcLen = gc.length / 2;
                        if (gcLen > arrayOfThings.length) {
                            for (i = 0; i < gcLen; i++) delete data[gc[i]];
                            gc.splice(0, gcLen);
                        }
                        return longest;
                    };
                    helpers$1.measureText = function(ctx, data, gc, longest, string) {
                        var textWidth = data[string];
                        if (!textWidth) {
                            textWidth = data[string] = ctx.measureText(string).width;
                            gc.push(string);
                        }
                        if (textWidth > longest) longest = textWidth;
                        return longest;
                    };
                    helpers$1.numberOfLabelLines = function(arrayOfThings) {
                        var numberOfLines = 1;
                        helpers$1.each(arrayOfThings, (function(thing) {
                            if (helpers$1.isArray(thing)) if (thing.length > numberOfLines) numberOfLines = thing.length;
                        }));
                        return numberOfLines;
                    };
                    helpers$1.color = !chartjsColor ? function(value) {
                        console.error("Color.js not found!");
                        return value;
                    } : function(value) {
                        if (value instanceof CanvasGradient) value = core_defaults.global.defaultColor;
                        return chartjsColor(value);
                    };
                    helpers$1.getHoverColor = function(colorValue) {
                        return colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient ? colorValue : helpers$1.color(colorValue).saturate(.5).darken(.1).rgbString();
                    };
                };
                function abstract() {
                    throw new Error("This method is not implemented: either no adapter can " + "be found or an incomplete integration was provided.");
                }
                function DateAdapter(options) {
                    this.options = options || {};
                }
                helpers$1.extend(DateAdapter.prototype, {
                    formats: abstract,
                    parse: abstract,
                    format: abstract,
                    add: abstract,
                    diff: abstract,
                    startOf: abstract,
                    endOf: abstract,
                    _create: function(value) {
                        return value;
                    }
                });
                DateAdapter.override = function(members) {
                    helpers$1.extend(DateAdapter.prototype, members);
                };
                var _date = DateAdapter;
                var core_adapters = {
                    _date
                };
                var core_ticks = {
                    formatters: {
                        values: function(value) {
                            return helpers$1.isArray(value) ? value : "" + value;
                        },
                        linear: function(tickValue, index, ticks) {
                            var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];
                            if (Math.abs(delta) > 1) if (tickValue !== Math.floor(tickValue)) delta = tickValue - Math.floor(tickValue);
                            var logDelta = helpers$1.log10(Math.abs(delta));
                            var tickString = "";
                            if (0 !== tickValue) {
                                var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));
                                if (maxTick < 1e-4) {
                                    var logTick = helpers$1.log10(Math.abs(tickValue));
                                    var numExponential = Math.floor(logTick) - Math.floor(logDelta);
                                    numExponential = Math.max(Math.min(numExponential, 20), 0);
                                    tickString = tickValue.toExponential(numExponential);
                                } else {
                                    var numDecimal = -1 * Math.floor(logDelta);
                                    numDecimal = Math.max(Math.min(numDecimal, 20), 0);
                                    tickString = tickValue.toFixed(numDecimal);
                                }
                            } else tickString = "0";
                            return tickString;
                        },
                        logarithmic: function(tickValue, index, ticks) {
                            var remain = tickValue / Math.pow(10, Math.floor(helpers$1.log10(tickValue)));
                            if (0 === tickValue) return "0"; else if (1 === remain || 2 === remain || 5 === remain || 0 === index || index === ticks.length - 1) return tickValue.toExponential();
                            return "";
                        }
                    }
                };
                var isArray = helpers$1.isArray;
                var isNullOrUndef = helpers$1.isNullOrUndef;
                var valueOrDefault$a = helpers$1.valueOrDefault;
                var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;
                core_defaults._set("scale", {
                    display: true,
                    position: "left",
                    offset: false,
                    gridLines: {
                        display: true,
                        color: "rgba(0,0,0,0.1)",
                        lineWidth: 1,
                        drawBorder: true,
                        drawOnChartArea: true,
                        drawTicks: true,
                        tickMarkLength: 10,
                        zeroLineWidth: 1,
                        zeroLineColor: "rgba(0,0,0,0.25)",
                        zeroLineBorderDash: [],
                        zeroLineBorderDashOffset: 0,
                        offsetGridLines: false,
                        borderDash: [],
                        borderDashOffset: 0
                    },
                    scaleLabel: {
                        display: false,
                        labelString: "",
                        padding: {
                            top: 4,
                            bottom: 4
                        }
                    },
                    ticks: {
                        beginAtZero: false,
                        minRotation: 0,
                        maxRotation: 50,
                        mirror: false,
                        padding: 0,
                        reverse: false,
                        display: true,
                        autoSkip: true,
                        autoSkipPadding: 0,
                        labelOffset: 0,
                        callback: core_ticks.formatters.values,
                        minor: {},
                        major: {}
                    }
                });
                function sample(arr, numItems) {
                    var result = [];
                    var increment = arr.length / numItems;
                    var i = 0;
                    var len = arr.length;
                    for (;i < len; i += increment) result.push(arr[Math.floor(i)]);
                    return result;
                }
                function getPixelForGridLine(scale, index, offsetGridLines) {
                    var length = scale.getTicks().length;
                    var validIndex = Math.min(index, length - 1);
                    var lineValue = scale.getPixelForTick(validIndex);
                    var start = scale._startPixel;
                    var end = scale._endPixel;
                    var epsilon = 1e-6;
                    var offset;
                    if (offsetGridLines) {
                        if (1 === length) offset = Math.max(lineValue - start, end - lineValue); else if (0 === index) offset = (scale.getPixelForTick(1) - lineValue) / 2; else offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
                        lineValue += validIndex < index ? offset : -offset;
                        if (lineValue < start - epsilon || lineValue > end + epsilon) return;
                    }
                    return lineValue;
                }
                function garbageCollect(caches, length) {
                    helpers$1.each(caches, (function(cache) {
                        var gc = cache.gc;
                        var gcLen = gc.length / 2;
                        var i;
                        if (gcLen > length) {
                            for (i = 0; i < gcLen; ++i) delete cache.data[gc[i]];
                            gc.splice(0, gcLen);
                        }
                    }));
                }
                function computeLabelSizes(ctx, tickFonts, ticks, caches) {
                    var length = ticks.length;
                    var widths = [];
                    var heights = [];
                    var offsets = [];
                    var widestLabelSize = 0;
                    var highestLabelSize = 0;
                    var i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel, widest, highest;
                    for (i = 0; i < length; ++i) {
                        label = ticks[i].label;
                        tickFont = ticks[i].major ? tickFonts.major : tickFonts.minor;
                        ctx.font = fontString = tickFont.string;
                        cache = caches[fontString] = caches[fontString] || {
                            data: {},
                            gc: []
                        };
                        lineHeight = tickFont.lineHeight;
                        width = height = 0;
                        if (!isNullOrUndef(label) && !isArray(label)) {
                            width = helpers$1.measureText(ctx, cache.data, cache.gc, width, label);
                            height = lineHeight;
                        } else if (isArray(label)) for (j = 0, jlen = label.length; j < jlen; ++j) {
                            nestedLabel = label[j];
                            if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
                                width = helpers$1.measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                                height += lineHeight;
                            }
                        }
                        widths.push(width);
                        heights.push(height);
                        offsets.push(lineHeight / 2);
                        widestLabelSize = Math.max(width, widestLabelSize);
                        highestLabelSize = Math.max(height, highestLabelSize);
                    }
                    garbageCollect(caches, length);
                    widest = widths.indexOf(widestLabelSize);
                    highest = heights.indexOf(highestLabelSize);
                    function valueAt(idx) {
                        return {
                            width: widths[idx] || 0,
                            height: heights[idx] || 0,
                            offset: offsets[idx] || 0
                        };
                    }
                    return {
                        first: valueAt(0),
                        last: valueAt(length - 1),
                        widest: valueAt(widest),
                        highest: valueAt(highest)
                    };
                }
                function getTickMarkLength(options) {
                    return options.drawTicks ? options.tickMarkLength : 0;
                }
                function getScaleLabelHeight(options) {
                    var font, padding;
                    if (!options.display) return 0;
                    font = helpers$1.options._parseFont(options);
                    padding = helpers$1.options.toPadding(options.padding);
                    return font.lineHeight + padding.height;
                }
                function parseFontOptions(options, nestedOpts) {
                    return helpers$1.extend(helpers$1.options._parseFont({
                        fontFamily: valueOrDefault$a(nestedOpts.fontFamily, options.fontFamily),
                        fontSize: valueOrDefault$a(nestedOpts.fontSize, options.fontSize),
                        fontStyle: valueOrDefault$a(nestedOpts.fontStyle, options.fontStyle),
                        lineHeight: valueOrDefault$a(nestedOpts.lineHeight, options.lineHeight)
                    }), {
                        color: helpers$1.options.resolve([ nestedOpts.fontColor, options.fontColor, core_defaults.global.defaultFontColor ])
                    });
                }
                function parseTickFontOptions(options) {
                    var minor = parseFontOptions(options, options.minor);
                    var major = options.major.enabled ? parseFontOptions(options, options.major) : minor;
                    return {
                        minor,
                        major
                    };
                }
                function nonSkipped(ticksToFilter) {
                    var filtered = [];
                    var item, index, len;
                    for (index = 0, len = ticksToFilter.length; index < len; ++index) {
                        item = ticksToFilter[index];
                        if ("undefined" !== typeof item._index) filtered.push(item);
                    }
                    return filtered;
                }
                function getEvenSpacing(arr) {
                    var len = arr.length;
                    var i, diff;
                    if (len < 2) return false;
                    for (diff = arr[0], i = 1; i < len; ++i) if (arr[i] - arr[i - 1] !== diff) return false;
                    return diff;
                }
                function calculateSpacing(majorIndices, ticks, axisLength, ticksLimit) {
                    var evenMajorSpacing = getEvenSpacing(majorIndices);
                    var spacing = (ticks.length - 1) / ticksLimit;
                    var factors, factor, i, ilen;
                    if (!evenMajorSpacing) return Math.max(spacing, 1);
                    factors = helpers$1.math._factorize(evenMajorSpacing);
                    for (i = 0, ilen = factors.length - 1; i < ilen; i++) {
                        factor = factors[i];
                        if (factor > spacing) return factor;
                    }
                    return Math.max(spacing, 1);
                }
                function getMajorIndices(ticks) {
                    var result = [];
                    var i, ilen;
                    for (i = 0, ilen = ticks.length; i < ilen; i++) if (ticks[i].major) result.push(i);
                    return result;
                }
                function skipMajors(ticks, majorIndices, spacing) {
                    var count = 0;
                    var next = majorIndices[0];
                    var i, tick;
                    spacing = Math.ceil(spacing);
                    for (i = 0; i < ticks.length; i++) {
                        tick = ticks[i];
                        if (i === next) {
                            tick._index = i;
                            count++;
                            next = majorIndices[count * spacing];
                        } else delete tick.label;
                    }
                }
                function skip(ticks, spacing, majorStart, majorEnd) {
                    var start = valueOrDefault$a(majorStart, 0);
                    var end = Math.min(valueOrDefault$a(majorEnd, ticks.length), ticks.length);
                    var count = 0;
                    var length, i, tick, next;
                    spacing = Math.ceil(spacing);
                    if (majorEnd) {
                        length = majorEnd - majorStart;
                        spacing = length / Math.floor(length / spacing);
                    }
                    next = start;
                    while (next < 0) {
                        count++;
                        next = Math.round(start + count * spacing);
                    }
                    for (i = Math.max(start, 0); i < end; i++) {
                        tick = ticks[i];
                        if (i === next) {
                            tick._index = i;
                            count++;
                            next = Math.round(start + count * spacing);
                        } else delete tick.label;
                    }
                }
                var Scale = core_element.extend({
                    zeroLineIndex: 0,
                    getPadding: function() {
                        var me = this;
                        return {
                            left: me.paddingLeft || 0,
                            top: me.paddingTop || 0,
                            right: me.paddingRight || 0,
                            bottom: me.paddingBottom || 0
                        };
                    },
                    getTicks: function() {
                        return this._ticks;
                    },
                    _getLabels: function() {
                        var data = this.chart.data;
                        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
                    },
                    mergeTicksOptions: function() {},
                    beforeUpdate: function() {
                        helpers$1.callback(this.options.beforeUpdate, [ this ]);
                    },
                    update: function(maxWidth, maxHeight, margins) {
                        var me = this;
                        var tickOpts = me.options.ticks;
                        var sampleSize = tickOpts.sampleSize;
                        var i, ilen, labels, ticks, samplingEnabled;
                        me.beforeUpdate();
                        me.maxWidth = maxWidth;
                        me.maxHeight = maxHeight;
                        me.margins = helpers$1.extend({
                            left: 0,
                            right: 0,
                            top: 0,
                            bottom: 0
                        }, margins);
                        me._ticks = null;
                        me.ticks = null;
                        me._labelSizes = null;
                        me._maxLabelLines = 0;
                        me.longestLabelWidth = 0;
                        me.longestTextCache = me.longestTextCache || {};
                        me._gridLineItems = null;
                        me._labelItems = null;
                        me.beforeSetDimensions();
                        me.setDimensions();
                        me.afterSetDimensions();
                        me.beforeDataLimits();
                        me.determineDataLimits();
                        me.afterDataLimits();
                        me.beforeBuildTicks();
                        ticks = me.buildTicks() || [];
                        ticks = me.afterBuildTicks(ticks) || ticks;
                        if ((!ticks || !ticks.length) && me.ticks) {
                            ticks = [];
                            for (i = 0, ilen = me.ticks.length; i < ilen; ++i) ticks.push({
                                value: me.ticks[i],
                                major: false
                            });
                        }
                        me._ticks = ticks;
                        samplingEnabled = sampleSize < ticks.length;
                        labels = me._convertTicksToLabels(samplingEnabled ? sample(ticks, sampleSize) : ticks);
                        me._configure();
                        me.beforeCalculateTickRotation();
                        me.calculateTickRotation();
                        me.afterCalculateTickRotation();
                        me.beforeFit();
                        me.fit();
                        me.afterFit();
                        me._ticksToDraw = tickOpts.display && (tickOpts.autoSkip || "auto" === tickOpts.source) ? me._autoSkip(ticks) : ticks;
                        if (samplingEnabled) labels = me._convertTicksToLabels(me._ticksToDraw);
                        me.ticks = labels;
                        me.afterUpdate();
                        return me.minSize;
                    },
                    _configure: function() {
                        var me = this;
                        var reversePixels = me.options.ticks.reverse;
                        var startPixel, endPixel;
                        if (me.isHorizontal()) {
                            startPixel = me.left;
                            endPixel = me.right;
                        } else {
                            startPixel = me.top;
                            endPixel = me.bottom;
                            reversePixels = !reversePixels;
                        }
                        me._startPixel = startPixel;
                        me._endPixel = endPixel;
                        me._reversePixels = reversePixels;
                        me._length = endPixel - startPixel;
                    },
                    afterUpdate: function() {
                        helpers$1.callback(this.options.afterUpdate, [ this ]);
                    },
                    beforeSetDimensions: function() {
                        helpers$1.callback(this.options.beforeSetDimensions, [ this ]);
                    },
                    setDimensions: function() {
                        var me = this;
                        if (me.isHorizontal()) {
                            me.width = me.maxWidth;
                            me.left = 0;
                            me.right = me.width;
                        } else {
                            me.height = me.maxHeight;
                            me.top = 0;
                            me.bottom = me.height;
                        }
                        me.paddingLeft = 0;
                        me.paddingTop = 0;
                        me.paddingRight = 0;
                        me.paddingBottom = 0;
                    },
                    afterSetDimensions: function() {
                        helpers$1.callback(this.options.afterSetDimensions, [ this ]);
                    },
                    beforeDataLimits: function() {
                        helpers$1.callback(this.options.beforeDataLimits, [ this ]);
                    },
                    determineDataLimits: helpers$1.noop,
                    afterDataLimits: function() {
                        helpers$1.callback(this.options.afterDataLimits, [ this ]);
                    },
                    beforeBuildTicks: function() {
                        helpers$1.callback(this.options.beforeBuildTicks, [ this ]);
                    },
                    buildTicks: helpers$1.noop,
                    afterBuildTicks: function(ticks) {
                        var me = this;
                        if (isArray(ticks) && ticks.length) return helpers$1.callback(me.options.afterBuildTicks, [ me, ticks ]);
                        me.ticks = helpers$1.callback(me.options.afterBuildTicks, [ me, me.ticks ]) || me.ticks;
                        return ticks;
                    },
                    beforeTickToLabelConversion: function() {
                        helpers$1.callback(this.options.beforeTickToLabelConversion, [ this ]);
                    },
                    convertTicksToLabels: function() {
                        var me = this;
                        var tickOpts = me.options.ticks;
                        me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
                    },
                    afterTickToLabelConversion: function() {
                        helpers$1.callback(this.options.afterTickToLabelConversion, [ this ]);
                    },
                    beforeCalculateTickRotation: function() {
                        helpers$1.callback(this.options.beforeCalculateTickRotation, [ this ]);
                    },
                    calculateTickRotation: function() {
                        var me = this;
                        var options = me.options;
                        var tickOpts = options.ticks;
                        var numTicks = me.getTicks().length;
                        var minRotation = tickOpts.minRotation || 0;
                        var maxRotation = tickOpts.maxRotation;
                        var labelRotation = minRotation;
                        var labelSizes, maxLabelWidth, maxLabelHeight, maxWidth, tickWidth, maxHeight, maxLabelDiagonal;
                        if (!me._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal()) {
                            me.labelRotation = minRotation;
                            return;
                        }
                        labelSizes = me._getLabelSizes();
                        maxLabelWidth = labelSizes.widest.width;
                        maxLabelHeight = labelSizes.highest.height - labelSizes.highest.offset;
                        maxWidth = Math.min(me.maxWidth, me.chart.width - maxLabelWidth);
                        tickWidth = options.offset ? me.maxWidth / numTicks : maxWidth / (numTicks - 1);
                        if (maxLabelWidth + 6 > tickWidth) {
                            tickWidth = maxWidth / (numTicks - (options.offset ? .5 : 1));
                            maxHeight = me.maxHeight - getTickMarkLength(options.gridLines) - tickOpts.padding - getScaleLabelHeight(options.scaleLabel);
                            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
                            labelRotation = helpers$1.toDegrees(Math.min(Math.asin(Math.min((labelSizes.highest.height + 6) / tickWidth, 1)), Math.asin(Math.min(maxHeight / maxLabelDiagonal, 1)) - Math.asin(maxLabelHeight / maxLabelDiagonal)));
                            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
                        }
                        me.labelRotation = labelRotation;
                    },
                    afterCalculateTickRotation: function() {
                        helpers$1.callback(this.options.afterCalculateTickRotation, [ this ]);
                    },
                    beforeFit: function() {
                        helpers$1.callback(this.options.beforeFit, [ this ]);
                    },
                    fit: function() {
                        var me = this;
                        var minSize = me.minSize = {
                            width: 0,
                            height: 0
                        };
                        var chart = me.chart;
                        var opts = me.options;
                        var tickOpts = opts.ticks;
                        var scaleLabelOpts = opts.scaleLabel;
                        var gridLineOpts = opts.gridLines;
                        var display = me._isVisible();
                        var isBottom = "bottom" === opts.position;
                        var isHorizontal = me.isHorizontal();
                        if (isHorizontal) minSize.width = me.maxWidth; else if (display) minSize.width = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);
                        if (!isHorizontal) minSize.height = me.maxHeight; else if (display) minSize.height = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);
                        if (tickOpts.display && display) {
                            var tickFonts = parseTickFontOptions(tickOpts);
                            var labelSizes = me._getLabelSizes();
                            var firstLabelSize = labelSizes.first;
                            var lastLabelSize = labelSizes.last;
                            var widestLabelSize = labelSizes.widest;
                            var highestLabelSize = labelSizes.highest;
                            var lineSpace = .4 * tickFonts.minor.lineHeight;
                            var tickPadding = tickOpts.padding;
                            if (isHorizontal) {
                                var isRotated = 0 !== me.labelRotation;
                                var angleRadians = helpers$1.toRadians(me.labelRotation);
                                var cosRotation = Math.cos(angleRadians);
                                var sinRotation = Math.sin(angleRadians);
                                var labelHeight = sinRotation * widestLabelSize.width + cosRotation * (highestLabelSize.height - (isRotated ? highestLabelSize.offset : 0)) + (isRotated ? 0 : lineSpace);
                                minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
                                var offsetLeft = me.getPixelForTick(0) - me.left;
                                var offsetRight = me.right - me.getPixelForTick(me.getTicks().length - 1);
                                var paddingLeft, paddingRight;
                                if (isRotated) {
                                    paddingLeft = isBottom ? cosRotation * firstLabelSize.width + sinRotation * firstLabelSize.offset : sinRotation * (firstLabelSize.height - firstLabelSize.offset);
                                    paddingRight = isBottom ? sinRotation * (lastLabelSize.height - lastLabelSize.offset) : cosRotation * lastLabelSize.width + sinRotation * lastLabelSize.offset;
                                } else {
                                    paddingLeft = firstLabelSize.width / 2;
                                    paddingRight = lastLabelSize.width / 2;
                                }
                                me.paddingLeft = Math.max((paddingLeft - offsetLeft) * me.width / (me.width - offsetLeft), 0) + 3;
                                me.paddingRight = Math.max((paddingRight - offsetRight) * me.width / (me.width - offsetRight), 0) + 3;
                            } else {
                                var labelWidth = tickOpts.mirror ? 0 : widestLabelSize.width + tickPadding + lineSpace;
                                minSize.width = Math.min(me.maxWidth, minSize.width + labelWidth);
                                me.paddingTop = firstLabelSize.height / 2;
                                me.paddingBottom = lastLabelSize.height / 2;
                            }
                        }
                        me.handleMargins();
                        if (isHorizontal) {
                            me.width = me._length = chart.width - me.margins.left - me.margins.right;
                            me.height = minSize.height;
                        } else {
                            me.width = minSize.width;
                            me.height = me._length = chart.height - me.margins.top - me.margins.bottom;
                        }
                    },
                    handleMargins: function() {
                        var me = this;
                        if (me.margins) {
                            me.margins.left = Math.max(me.paddingLeft, me.margins.left);
                            me.margins.top = Math.max(me.paddingTop, me.margins.top);
                            me.margins.right = Math.max(me.paddingRight, me.margins.right);
                            me.margins.bottom = Math.max(me.paddingBottom, me.margins.bottom);
                        }
                    },
                    afterFit: function() {
                        helpers$1.callback(this.options.afterFit, [ this ]);
                    },
                    isHorizontal: function() {
                        var pos = this.options.position;
                        return "top" === pos || "bottom" === pos;
                    },
                    isFullWidth: function() {
                        return this.options.fullWidth;
                    },
                    getRightValue: function(rawValue) {
                        if (isNullOrUndef(rawValue)) return NaN;
                        if (("number" === typeof rawValue || rawValue instanceof Number) && !isFinite(rawValue)) return NaN;
                        if (rawValue) if (this.isHorizontal()) {
                            if (void 0 !== rawValue.x) return this.getRightValue(rawValue.x);
                        } else if (void 0 !== rawValue.y) return this.getRightValue(rawValue.y);
                        return rawValue;
                    },
                    _convertTicksToLabels: function(ticks) {
                        var me = this;
                        var labels, i, ilen;
                        me.ticks = ticks.map((function(tick) {
                            return tick.value;
                        }));
                        me.beforeTickToLabelConversion();
                        labels = me.convertTicksToLabels(ticks) || me.ticks;
                        me.afterTickToLabelConversion();
                        for (i = 0, ilen = ticks.length; i < ilen; ++i) ticks[i].label = labels[i];
                        return labels;
                    },
                    _getLabelSizes: function() {
                        var me = this;
                        var labelSizes = me._labelSizes;
                        if (!labelSizes) {
                            me._labelSizes = labelSizes = computeLabelSizes(me.ctx, parseTickFontOptions(me.options.ticks), me.getTicks(), me.longestTextCache);
                            me.longestLabelWidth = labelSizes.widest.width;
                        }
                        return labelSizes;
                    },
                    _parseValue: function(value) {
                        var start, end, min, max;
                        if (isArray(value)) {
                            start = +this.getRightValue(value[0]);
                            end = +this.getRightValue(value[1]);
                            min = Math.min(start, end);
                            max = Math.max(start, end);
                        } else {
                            value = +this.getRightValue(value);
                            start = void 0;
                            end = value;
                            min = value;
                            max = value;
                        }
                        return {
                            min,
                            max,
                            start,
                            end
                        };
                    },
                    _getScaleLabel: function(rawValue) {
                        var v = this._parseValue(rawValue);
                        if (void 0 !== v.start) return "[" + v.start + ", " + v.end + "]";
                        return +this.getRightValue(rawValue);
                    },
                    getLabelForIndex: helpers$1.noop,
                    getPixelForValue: helpers$1.noop,
                    getValueForPixel: helpers$1.noop,
                    getPixelForTick: function(index) {
                        var me = this;
                        var offset = me.options.offset;
                        var numTicks = me._ticks.length;
                        var tickWidth = 1 / Math.max(numTicks - (offset ? 0 : 1), 1);
                        return index < 0 || index > numTicks - 1 ? null : me.getPixelForDecimal(index * tickWidth + (offset ? tickWidth / 2 : 0));
                    },
                    getPixelForDecimal: function(decimal) {
                        var me = this;
                        if (me._reversePixels) decimal = 1 - decimal;
                        return me._startPixel + decimal * me._length;
                    },
                    getDecimalForPixel: function(pixel) {
                        var decimal = (pixel - this._startPixel) / this._length;
                        return this._reversePixels ? 1 - decimal : decimal;
                    },
                    getBasePixel: function() {
                        return this.getPixelForValue(this.getBaseValue());
                    },
                    getBaseValue: function() {
                        var me = this;
                        var min = me.min;
                        var max = me.max;
                        return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
                    },
                    _autoSkip: function(ticks) {
                        var me = this;
                        var tickOpts = me.options.ticks;
                        var axisLength = me._length;
                        var ticksLimit = tickOpts.maxTicksLimit || axisLength / me._tickSize() + 1;
                        var majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
                        var numMajorIndices = majorIndices.length;
                        var first = majorIndices[0];
                        var last = majorIndices[numMajorIndices - 1];
                        var i, ilen, spacing, avgMajorSpacing;
                        if (numMajorIndices > ticksLimit) {
                            skipMajors(ticks, majorIndices, numMajorIndices / ticksLimit);
                            return nonSkipped(ticks);
                        }
                        spacing = calculateSpacing(majorIndices, ticks, axisLength, ticksLimit);
                        if (numMajorIndices > 0) {
                            for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) skip(ticks, spacing, majorIndices[i], majorIndices[i + 1]);
                            avgMajorSpacing = numMajorIndices > 1 ? (last - first) / (numMajorIndices - 1) : null;
                            skip(ticks, spacing, helpers$1.isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
                            skip(ticks, spacing, last, helpers$1.isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
                            return nonSkipped(ticks);
                        }
                        skip(ticks, spacing);
                        return nonSkipped(ticks);
                    },
                    _tickSize: function() {
                        var me = this;
                        var optionTicks = me.options.ticks;
                        var rot = helpers$1.toRadians(me.labelRotation);
                        var cos = Math.abs(Math.cos(rot));
                        var sin = Math.abs(Math.sin(rot));
                        var labelSizes = me._getLabelSizes();
                        var padding = optionTicks.autoSkipPadding || 0;
                        var w = labelSizes ? labelSizes.widest.width + padding : 0;
                        var h = labelSizes ? labelSizes.highest.height + padding : 0;
                        return me.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
                    },
                    _isVisible: function() {
                        var me = this;
                        var chart = me.chart;
                        var display = me.options.display;
                        var i, ilen, meta;
                        if ("auto" !== display) return !!display;
                        for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) if (chart.isDatasetVisible(i)) {
                            meta = chart.getDatasetMeta(i);
                            if (meta.xAxisID === me.id || meta.yAxisID === me.id) return true;
                        }
                        return false;
                    },
                    _computeGridLineItems: function(chartArea) {
                        var me = this;
                        var chart = me.chart;
                        var options = me.options;
                        var gridLines = options.gridLines;
                        var position = options.position;
                        var offsetGridLines = gridLines.offsetGridLines;
                        var isHorizontal = me.isHorizontal();
                        var ticks = me._ticksToDraw;
                        var ticksLength = ticks.length + (offsetGridLines ? 1 : 0);
                        var tl = getTickMarkLength(gridLines);
                        var items = [];
                        var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
                        var axisHalfWidth = axisWidth / 2;
                        var alignPixel = helpers$1._alignPixel;
                        var alignBorderValue = function(pixel) {
                            return alignPixel(chart, pixel, axisWidth);
                        };
                        var borderValue, i, tick, lineValue, alignedLineValue;
                        var tx1, ty1, tx2, ty2, x1, y1, x2, y2, lineWidth, lineColor, borderDash, borderDashOffset;
                        if ("top" === position) {
                            borderValue = alignBorderValue(me.bottom);
                            ty1 = me.bottom - tl;
                            ty2 = borderValue - axisHalfWidth;
                            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
                            y2 = chartArea.bottom;
                        } else if ("bottom" === position) {
                            borderValue = alignBorderValue(me.top);
                            y1 = chartArea.top;
                            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
                            ty1 = borderValue + axisHalfWidth;
                            ty2 = me.top + tl;
                        } else if ("left" === position) {
                            borderValue = alignBorderValue(me.right);
                            tx1 = me.right - tl;
                            tx2 = borderValue - axisHalfWidth;
                            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
                            x2 = chartArea.right;
                        } else {
                            borderValue = alignBorderValue(me.left);
                            x1 = chartArea.left;
                            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
                            tx1 = borderValue + axisHalfWidth;
                            tx2 = me.left + tl;
                        }
                        for (i = 0; i < ticksLength; ++i) {
                            tick = ticks[i] || {};
                            if (isNullOrUndef(tick.label) && i < ticks.length) continue;
                            if (i === me.zeroLineIndex && options.offset === offsetGridLines) {
                                lineWidth = gridLines.zeroLineWidth;
                                lineColor = gridLines.zeroLineColor;
                                borderDash = gridLines.zeroLineBorderDash || [];
                                borderDashOffset = gridLines.zeroLineBorderDashOffset || 0;
                            } else {
                                lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, i, 1);
                                lineColor = valueAtIndexOrDefault(gridLines.color, i, "rgba(0,0,0,0.1)");
                                borderDash = gridLines.borderDash || [];
                                borderDashOffset = gridLines.borderDashOffset || 0;
                            }
                            lineValue = getPixelForGridLine(me, tick._index || i, offsetGridLines);
                            if (void 0 === lineValue) continue;
                            alignedLineValue = alignPixel(chart, lineValue, lineWidth);
                            if (isHorizontal) tx1 = tx2 = x1 = x2 = alignedLineValue; else ty1 = ty2 = y1 = y2 = alignedLineValue;
                            items.push({
                                tx1,
                                ty1,
                                tx2,
                                ty2,
                                x1,
                                y1,
                                x2,
                                y2,
                                width: lineWidth,
                                color: lineColor,
                                borderDash,
                                borderDashOffset
                            });
                        }
                        items.ticksLength = ticksLength;
                        items.borderValue = borderValue;
                        return items;
                    },
                    _computeLabelItems: function() {
                        var me = this;
                        var options = me.options;
                        var optionTicks = options.ticks;
                        var position = options.position;
                        var isMirrored = optionTicks.mirror;
                        var isHorizontal = me.isHorizontal();
                        var ticks = me._ticksToDraw;
                        var fonts = parseTickFontOptions(optionTicks);
                        var tickPadding = optionTicks.padding;
                        var tl = getTickMarkLength(options.gridLines);
                        var rotation = -helpers$1.toRadians(me.labelRotation);
                        var items = [];
                        var i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
                        if ("top" === position) {
                            y = me.bottom - tl - tickPadding;
                            textAlign = !rotation ? "center" : "left";
                        } else if ("bottom" === position) {
                            y = me.top + tl + tickPadding;
                            textAlign = !rotation ? "center" : "right";
                        } else if ("left" === position) {
                            x = me.right - (isMirrored ? 0 : tl) - tickPadding;
                            textAlign = isMirrored ? "left" : "right";
                        } else {
                            x = me.left + (isMirrored ? 0 : tl) + tickPadding;
                            textAlign = isMirrored ? "right" : "left";
                        }
                        for (i = 0, ilen = ticks.length; i < ilen; ++i) {
                            tick = ticks[i];
                            label = tick.label;
                            if (isNullOrUndef(label)) continue;
                            pixel = me.getPixelForTick(tick._index || i) + optionTicks.labelOffset;
                            font = tick.major ? fonts.major : fonts.minor;
                            lineHeight = font.lineHeight;
                            lineCount = isArray(label) ? label.length : 1;
                            if (isHorizontal) {
                                x = pixel;
                                textOffset = "top" === position ? ((!rotation ? .5 : 1) - lineCount) * lineHeight : (!rotation ? .5 : 0) * lineHeight;
                            } else {
                                y = pixel;
                                textOffset = (1 - lineCount) * lineHeight / 2;
                            }
                            items.push({
                                x,
                                y,
                                rotation,
                                label,
                                font,
                                textOffset,
                                textAlign
                            });
                        }
                        return items;
                    },
                    _drawGrid: function(chartArea) {
                        var me = this;
                        var gridLines = me.options.gridLines;
                        if (!gridLines.display) return;
                        var ctx = me.ctx;
                        var chart = me.chart;
                        var alignPixel = helpers$1._alignPixel;
                        var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
                        var items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));
                        var width, color, i, ilen, item;
                        for (i = 0, ilen = items.length; i < ilen; ++i) {
                            item = items[i];
                            width = item.width;
                            color = item.color;
                            if (width && color) {
                                ctx.save();
                                ctx.lineWidth = width;
                                ctx.strokeStyle = color;
                                if (ctx.setLineDash) {
                                    ctx.setLineDash(item.borderDash);
                                    ctx.lineDashOffset = item.borderDashOffset;
                                }
                                ctx.beginPath();
                                if (gridLines.drawTicks) {
                                    ctx.moveTo(item.tx1, item.ty1);
                                    ctx.lineTo(item.tx2, item.ty2);
                                }
                                if (gridLines.drawOnChartArea) {
                                    ctx.moveTo(item.x1, item.y1);
                                    ctx.lineTo(item.x2, item.y2);
                                }
                                ctx.stroke();
                                ctx.restore();
                            }
                        }
                        if (axisWidth) {
                            var firstLineWidth = axisWidth;
                            var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, items.ticksLength - 1, 1);
                            var borderValue = items.borderValue;
                            var x1, x2, y1, y2;
                            if (me.isHorizontal()) {
                                x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;
                                x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;
                                y1 = y2 = borderValue;
                            } else {
                                y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;
                                y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;
                                x1 = x2 = borderValue;
                            }
                            ctx.lineWidth = axisWidth;
                            ctx.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);
                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }
                    },
                    _drawLabels: function() {
                        var me = this;
                        var optionTicks = me.options.ticks;
                        if (!optionTicks.display) return;
                        var ctx = me.ctx;
                        var items = me._labelItems || (me._labelItems = me._computeLabelItems());
                        var i, j, ilen, jlen, item, tickFont, label, y;
                        for (i = 0, ilen = items.length; i < ilen; ++i) {
                            item = items[i];
                            tickFont = item.font;
                            ctx.save();
                            ctx.translate(item.x, item.y);
                            ctx.rotate(item.rotation);
                            ctx.font = tickFont.string;
                            ctx.fillStyle = tickFont.color;
                            ctx.textBaseline = "middle";
                            ctx.textAlign = item.textAlign;
                            label = item.label;
                            y = item.textOffset;
                            if (isArray(label)) for (j = 0, jlen = label.length; j < jlen; ++j) {
                                ctx.fillText("" + label[j], 0, y);
                                y += tickFont.lineHeight;
                            } else ctx.fillText(label, 0, y);
                            ctx.restore();
                        }
                    },
                    _drawTitle: function() {
                        var me = this;
                        var ctx = me.ctx;
                        var options = me.options;
                        var scaleLabel = options.scaleLabel;
                        if (!scaleLabel.display) return;
                        var scaleLabelFontColor = valueOrDefault$a(scaleLabel.fontColor, core_defaults.global.defaultFontColor);
                        var scaleLabelFont = helpers$1.options._parseFont(scaleLabel);
                        var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);
                        var halfLineHeight = scaleLabelFont.lineHeight / 2;
                        var position = options.position;
                        var rotation = 0;
                        var scaleLabelX, scaleLabelY;
                        if (me.isHorizontal()) {
                            scaleLabelX = me.left + me.width / 2;
                            scaleLabelY = "bottom" === position ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
                        } else {
                            var isLeft = "left" === position;
                            scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
                            scaleLabelY = me.top + me.height / 2;
                            rotation = isLeft ? -.5 * Math.PI : .5 * Math.PI;
                        }
                        ctx.save();
                        ctx.translate(scaleLabelX, scaleLabelY);
                        ctx.rotate(rotation);
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillStyle = scaleLabelFontColor;
                        ctx.font = scaleLabelFont.string;
                        ctx.fillText(scaleLabel.labelString, 0, 0);
                        ctx.restore();
                    },
                    draw: function(chartArea) {
                        var me = this;
                        if (!me._isVisible()) return;
                        me._drawGrid(chartArea);
                        me._drawTitle();
                        me._drawLabels();
                    },
                    _layers: function() {
                        var me = this;
                        var opts = me.options;
                        var tz = opts.ticks && opts.ticks.z || 0;
                        var gz = opts.gridLines && opts.gridLines.z || 0;
                        if (!me._isVisible() || tz === gz || me.draw !== me._draw) return [ {
                            z: tz,
                            draw: function() {
                                me.draw.apply(me, arguments);
                            }
                        } ];
                        return [ {
                            z: gz,
                            draw: function() {
                                me._drawGrid.apply(me, arguments);
                                me._drawTitle.apply(me, arguments);
                            }
                        }, {
                            z: tz,
                            draw: function() {
                                me._drawLabels.apply(me, arguments);
                            }
                        } ];
                    },
                    _getMatchingVisibleMetas: function(type) {
                        var me = this;
                        var isHorizontal = me.isHorizontal();
                        return me.chart._getSortedVisibleDatasetMetas().filter((function(meta) {
                            return (!type || meta.type === type) && (isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id);
                        }));
                    }
                });
                Scale.prototype._draw = Scale.prototype.draw;
                var core_scale = Scale;
                var isNullOrUndef$1 = helpers$1.isNullOrUndef;
                var defaultConfig = {
                    position: "bottom"
                };
                var scale_category = core_scale.extend({
                    determineDataLimits: function() {
                        var me = this;
                        var labels = me._getLabels();
                        var ticksOpts = me.options.ticks;
                        var min = ticksOpts.min;
                        var max = ticksOpts.max;
                        var minIndex = 0;
                        var maxIndex = labels.length - 1;
                        var findIndex;
                        if (void 0 !== min) {
                            findIndex = labels.indexOf(min);
                            if (findIndex >= 0) minIndex = findIndex;
                        }
                        if (void 0 !== max) {
                            findIndex = labels.indexOf(max);
                            if (findIndex >= 0) maxIndex = findIndex;
                        }
                        me.minIndex = minIndex;
                        me.maxIndex = maxIndex;
                        me.min = labels[minIndex];
                        me.max = labels[maxIndex];
                    },
                    buildTicks: function() {
                        var me = this;
                        var labels = me._getLabels();
                        var minIndex = me.minIndex;
                        var maxIndex = me.maxIndex;
                        me.ticks = 0 === minIndex && maxIndex === labels.length - 1 ? labels : labels.slice(minIndex, maxIndex + 1);
                    },
                    getLabelForIndex: function(index, datasetIndex) {
                        var me = this;
                        var chart = me.chart;
                        if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) return me.getRightValue(chart.data.datasets[datasetIndex].data[index]);
                        return me._getLabels()[index];
                    },
                    _configure: function() {
                        var me = this;
                        var offset = me.options.offset;
                        var ticks = me.ticks;
                        core_scale.prototype._configure.call(me);
                        if (!me.isHorizontal()) me._reversePixels = !me._reversePixels;
                        if (!ticks) return;
                        me._startValue = me.minIndex - (offset ? .5 : 0);
                        me._valueRange = Math.max(ticks.length - (offset ? 0 : 1), 1);
                    },
                    getPixelForValue: function(value, index, datasetIndex) {
                        var me = this;
                        var valueCategory, labels, idx;
                        if (!isNullOrUndef$1(index) && !isNullOrUndef$1(datasetIndex)) value = me.chart.data.datasets[datasetIndex].data[index];
                        if (!isNullOrUndef$1(value)) valueCategory = me.isHorizontal() ? value.x : value.y;
                        if (void 0 !== valueCategory || void 0 !== value && isNaN(index)) {
                            labels = me._getLabels();
                            value = helpers$1.valueOrDefault(valueCategory, value);
                            idx = labels.indexOf(value);
                            index = -1 !== idx ? idx : index;
                            if (isNaN(index)) index = value;
                        }
                        return me.getPixelForDecimal((index - me._startValue) / me._valueRange);
                    },
                    getPixelForTick: function(index) {
                        var ticks = this.ticks;
                        return index < 0 || index > ticks.length - 1 ? null : this.getPixelForValue(ticks[index], index + this.minIndex);
                    },
                    getValueForPixel: function(pixel) {
                        var me = this;
                        var value = Math.round(me._startValue + me.getDecimalForPixel(pixel) * me._valueRange);
                        return Math.min(Math.max(value, 0), me.ticks.length - 1);
                    },
                    getBasePixel: function() {
                        return this.bottom;
                    }
                });
                var _defaults = defaultConfig;
                scale_category._defaults = _defaults;
                var noop = helpers$1.noop;
                var isNullOrUndef$2 = helpers$1.isNullOrUndef;
                function generateTicks(generationOptions, dataRange) {
                    var ticks = [];
                    var MIN_SPACING = 1e-14;
                    var stepSize = generationOptions.stepSize;
                    var unit = stepSize || 1;
                    var maxNumSpaces = generationOptions.maxTicks - 1;
                    var min = generationOptions.min;
                    var max = generationOptions.max;
                    var precision = generationOptions.precision;
                    var rmin = dataRange.min;
                    var rmax = dataRange.max;
                    var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;
                    var factor, niceMin, niceMax, numSpaces;
                    if (spacing < MIN_SPACING && isNullOrUndef$2(min) && isNullOrUndef$2(max)) return [ rmin, rmax ];
                    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
                    if (numSpaces > maxNumSpaces) spacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;
                    if (stepSize || isNullOrUndef$2(precision)) factor = Math.pow(10, helpers$1._decimalPlaces(spacing)); else {
                        factor = Math.pow(10, precision);
                        spacing = Math.ceil(spacing * factor) / factor;
                    }
                    niceMin = Math.floor(rmin / spacing) * spacing;
                    niceMax = Math.ceil(rmax / spacing) * spacing;
                    if (stepSize) {
                        if (!isNullOrUndef$2(min) && helpers$1.almostWhole(min / spacing, spacing / 1e3)) niceMin = min;
                        if (!isNullOrUndef$2(max) && helpers$1.almostWhole(max / spacing, spacing / 1e3)) niceMax = max;
                    }
                    numSpaces = (niceMax - niceMin) / spacing;
                    if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) numSpaces = Math.round(numSpaces); else numSpaces = Math.ceil(numSpaces);
                    niceMin = Math.round(niceMin * factor) / factor;
                    niceMax = Math.round(niceMax * factor) / factor;
                    ticks.push(isNullOrUndef$2(min) ? niceMin : min);
                    for (var j = 1; j < numSpaces; ++j) ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);
                    ticks.push(isNullOrUndef$2(max) ? niceMax : max);
                    return ticks;
                }
                var scale_linearbase = core_scale.extend({
                    getRightValue: function(value) {
                        if ("string" === typeof value) return +value;
                        return core_scale.prototype.getRightValue.call(this, value);
                    },
                    handleTickRangeOptions: function() {
                        var me = this;
                        var opts = me.options;
                        var tickOpts = opts.ticks;
                        if (tickOpts.beginAtZero) {
                            var minSign = helpers$1.sign(me.min);
                            var maxSign = helpers$1.sign(me.max);
                            if (minSign < 0 && maxSign < 0) me.max = 0; else if (minSign > 0 && maxSign > 0) me.min = 0;
                        }
                        var setMin = void 0 !== tickOpts.min || void 0 !== tickOpts.suggestedMin;
                        var setMax = void 0 !== tickOpts.max || void 0 !== tickOpts.suggestedMax;
                        if (void 0 !== tickOpts.min) me.min = tickOpts.min; else if (void 0 !== tickOpts.suggestedMin) if (null === me.min) me.min = tickOpts.suggestedMin; else me.min = Math.min(me.min, tickOpts.suggestedMin);
                        if (void 0 !== tickOpts.max) me.max = tickOpts.max; else if (void 0 !== tickOpts.suggestedMax) if (null === me.max) me.max = tickOpts.suggestedMax; else me.max = Math.max(me.max, tickOpts.suggestedMax);
                        if (setMin !== setMax) if (me.min >= me.max) if (setMin) me.max = me.min + 1; else me.min = me.max - 1;
                        if (me.min === me.max) {
                            me.max++;
                            if (!tickOpts.beginAtZero) me.min--;
                        }
                    },
                    getTickLimit: function() {
                        var me = this;
                        var tickOpts = me.options.ticks;
                        var stepSize = tickOpts.stepSize;
                        var maxTicksLimit = tickOpts.maxTicksLimit;
                        var maxTicks;
                        if (stepSize) maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1; else {
                            maxTicks = me._computeTickLimit();
                            maxTicksLimit = maxTicksLimit || 11;
                        }
                        if (maxTicksLimit) maxTicks = Math.min(maxTicksLimit, maxTicks);
                        return maxTicks;
                    },
                    _computeTickLimit: function() {
                        return Number.POSITIVE_INFINITY;
                    },
                    handleDirectionalChanges: noop,
                    buildTicks: function() {
                        var me = this;
                        var opts = me.options;
                        var tickOpts = opts.ticks;
                        var maxTicks = me.getTickLimit();
                        maxTicks = Math.max(2, maxTicks);
                        var numericGeneratorOptions = {
                            maxTicks,
                            min: tickOpts.min,
                            max: tickOpts.max,
                            precision: tickOpts.precision,
                            stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
                        };
                        var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);
                        me.handleDirectionalChanges();
                        me.max = helpers$1.max(ticks);
                        me.min = helpers$1.min(ticks);
                        if (tickOpts.reverse) {
                            ticks.reverse();
                            me.start = me.max;
                            me.end = me.min;
                        } else {
                            me.start = me.min;
                            me.end = me.max;
                        }
                    },
                    convertTicksToLabels: function() {
                        var me = this;
                        me.ticksAsNumbers = me.ticks.slice();
                        me.zeroLineIndex = me.ticks.indexOf(0);
                        core_scale.prototype.convertTicksToLabels.call(me);
                    },
                    _configure: function() {
                        var me = this;
                        var ticks = me.getTicks();
                        var start = me.min;
                        var end = me.max;
                        var offset;
                        core_scale.prototype._configure.call(me);
                        if (me.options.offset && ticks.length) {
                            offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
                            start -= offset;
                            end += offset;
                        }
                        me._startValue = start;
                        me._endValue = end;
                        me._valueRange = end - start;
                    }
                });
                var defaultConfig$1 = {
                    position: "left",
                    ticks: {
                        callback: core_ticks.formatters.linear
                    }
                };
                var DEFAULT_MIN = 0;
                var DEFAULT_MAX = 1;
                function getOrCreateStack(stacks, stacked, meta) {
                    var key = [ meta.type, void 0 === stacked && void 0 === meta.stack ? meta.index : "", meta.stack ].join(".");
                    if (void 0 === stacks[key]) stacks[key] = {
                        pos: [],
                        neg: []
                    };
                    return stacks[key];
                }
                function stackData(scale, stacks, meta, data) {
                    var opts = scale.options;
                    var stacked = opts.stacked;
                    var stack = getOrCreateStack(stacks, stacked, meta);
                    var pos = stack.pos;
                    var neg = stack.neg;
                    var ilen = data.length;
                    var i, value;
                    for (i = 0; i < ilen; ++i) {
                        value = scale._parseValue(data[i]);
                        if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) continue;
                        pos[i] = pos[i] || 0;
                        neg[i] = neg[i] || 0;
                        if (opts.relativePoints) pos[i] = 100; else if (value.min < 0 || value.max < 0) neg[i] += value.min; else pos[i] += value.max;
                    }
                }
                function updateMinMax(scale, meta, data) {
                    var ilen = data.length;
                    var i, value;
                    for (i = 0; i < ilen; ++i) {
                        value = scale._parseValue(data[i]);
                        if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) continue;
                        scale.min = Math.min(scale.min, value.min);
                        scale.max = Math.max(scale.max, value.max);
                    }
                }
                var scale_linear = scale_linearbase.extend({
                    determineDataLimits: function() {
                        var me = this;
                        var opts = me.options;
                        var chart = me.chart;
                        var datasets = chart.data.datasets;
                        var metasets = me._getMatchingVisibleMetas();
                        var hasStacks = opts.stacked;
                        var stacks = {};
                        var ilen = metasets.length;
                        var i, meta, data, values;
                        me.min = Number.POSITIVE_INFINITY;
                        me.max = Number.NEGATIVE_INFINITY;
                        if (void 0 === hasStacks) for (i = 0; !hasStacks && i < ilen; ++i) {
                            meta = metasets[i];
                            hasStacks = void 0 !== meta.stack;
                        }
                        for (i = 0; i < ilen; ++i) {
                            meta = metasets[i];
                            data = datasets[meta.index].data;
                            if (hasStacks) stackData(me, stacks, meta, data); else updateMinMax(me, meta, data);
                        }
                        helpers$1.each(stacks, (function(stackValues) {
                            values = stackValues.pos.concat(stackValues.neg);
                            me.min = Math.min(me.min, helpers$1.min(values));
                            me.max = Math.max(me.max, helpers$1.max(values));
                        }));
                        me.min = helpers$1.isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
                        me.max = helpers$1.isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;
                        me.handleTickRangeOptions();
                    },
                    _computeTickLimit: function() {
                        var me = this;
                        var tickFont;
                        if (me.isHorizontal()) return Math.ceil(me.width / 40);
                        tickFont = helpers$1.options._parseFont(me.options.ticks);
                        return Math.ceil(me.height / tickFont.lineHeight);
                    },
                    handleDirectionalChanges: function() {
                        if (!this.isHorizontal()) this.ticks.reverse();
                    },
                    getLabelForIndex: function(index, datasetIndex) {
                        return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);
                    },
                    getPixelForValue: function(value) {
                        var me = this;
                        return me.getPixelForDecimal((+me.getRightValue(value) - me._startValue) / me._valueRange);
                    },
                    getValueForPixel: function(pixel) {
                        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
                    },
                    getPixelForTick: function(index) {
                        var ticks = this.ticksAsNumbers;
                        if (index < 0 || index > ticks.length - 1) return null;
                        return this.getPixelForValue(ticks[index]);
                    }
                });
                var _defaults$1 = defaultConfig$1;
                scale_linear._defaults = _defaults$1;
                var valueOrDefault$b = helpers$1.valueOrDefault;
                var log10 = helpers$1.math.log10;
                function generateTicks$1(generationOptions, dataRange) {
                    var ticks = [];
                    var tickVal = valueOrDefault$b(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
                    var endExp = Math.floor(log10(dataRange.max));
                    var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
                    var exp, significand;
                    if (0 === tickVal) {
                        exp = Math.floor(log10(dataRange.minNotZero));
                        significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
                        ticks.push(tickVal);
                        tickVal = significand * Math.pow(10, exp);
                    } else {
                        exp = Math.floor(log10(tickVal));
                        significand = Math.floor(tickVal / Math.pow(10, exp));
                    }
                    var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
                    do {
                        ticks.push(tickVal);
                        ++significand;
                        if (10 === significand) {
                            significand = 1;
                            ++exp;
                            precision = exp >= 0 ? 1 : precision;
                        }
                        tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
                    } while (exp < endExp || exp === endExp && significand < endSignificand);
                    var lastTick = valueOrDefault$b(generationOptions.max, tickVal);
                    ticks.push(lastTick);
                    return ticks;
                }
                var defaultConfig$2 = {
                    position: "left",
                    ticks: {
                        callback: core_ticks.formatters.logarithmic
                    }
                };
                function nonNegativeOrDefault(value, defaultValue) {
                    return helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;
                }
                var scale_logarithmic = core_scale.extend({
                    determineDataLimits: function() {
                        var me = this;
                        var opts = me.options;
                        var chart = me.chart;
                        var datasets = chart.data.datasets;
                        var isHorizontal = me.isHorizontal();
                        function IDMatches(meta) {
                            return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
                        }
                        var datasetIndex, meta, value, data, i, ilen;
                        me.min = Number.POSITIVE_INFINITY;
                        me.max = Number.NEGATIVE_INFINITY;
                        me.minNotZero = Number.POSITIVE_INFINITY;
                        var hasStacks = opts.stacked;
                        if (void 0 === hasStacks) for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                            meta = chart.getDatasetMeta(datasetIndex);
                            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && void 0 !== meta.stack) {
                                hasStacks = true;
                                break;
                            }
                        }
                        if (opts.stacked || hasStacks) {
                            var valuesPerStack = {};
                            for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                                meta = chart.getDatasetMeta(datasetIndex);
                                var key = [ meta.type, void 0 === opts.stacked && void 0 === meta.stack ? datasetIndex : "", meta.stack ].join(".");
                                if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                                    if (void 0 === valuesPerStack[key]) valuesPerStack[key] = [];
                                    data = datasets[datasetIndex].data;
                                    for (i = 0, ilen = data.length; i < ilen; i++) {
                                        var values = valuesPerStack[key];
                                        value = me._parseValue(data[i]);
                                        if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) continue;
                                        values[i] = values[i] || 0;
                                        values[i] += value.max;
                                    }
                                }
                            }
                            helpers$1.each(valuesPerStack, (function(valuesForType) {
                                if (valuesForType.length > 0) {
                                    var minVal = helpers$1.min(valuesForType);
                                    var maxVal = helpers$1.max(valuesForType);
                                    me.min = Math.min(me.min, minVal);
                                    me.max = Math.max(me.max, maxVal);
                                }
                            }));
                        } else for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                            meta = chart.getDatasetMeta(datasetIndex);
                            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                                data = datasets[datasetIndex].data;
                                for (i = 0, ilen = data.length; i < ilen; i++) {
                                    value = me._parseValue(data[i]);
                                    if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) continue;
                                    me.min = Math.min(value.min, me.min);
                                    me.max = Math.max(value.max, me.max);
                                    if (0 !== value.min) me.minNotZero = Math.min(value.min, me.minNotZero);
                                }
                            }
                        }
                        me.min = helpers$1.isFinite(me.min) ? me.min : null;
                        me.max = helpers$1.isFinite(me.max) ? me.max : null;
                        me.minNotZero = helpers$1.isFinite(me.minNotZero) ? me.minNotZero : null;
                        this.handleTickRangeOptions();
                    },
                    handleTickRangeOptions: function() {
                        var me = this;
                        var tickOpts = me.options.ticks;
                        var DEFAULT_MIN = 1;
                        var DEFAULT_MAX = 10;
                        me.min = nonNegativeOrDefault(tickOpts.min, me.min);
                        me.max = nonNegativeOrDefault(tickOpts.max, me.max);
                        if (me.min === me.max) if (0 !== me.min && null !== me.min) {
                            me.min = Math.pow(10, Math.floor(log10(me.min)) - 1);
                            me.max = Math.pow(10, Math.floor(log10(me.max)) + 1);
                        } else {
                            me.min = DEFAULT_MIN;
                            me.max = DEFAULT_MAX;
                        }
                        if (null === me.min) me.min = Math.pow(10, Math.floor(log10(me.max)) - 1);
                        if (null === me.max) me.max = 0 !== me.min ? Math.pow(10, Math.floor(log10(me.min)) + 1) : DEFAULT_MAX;
                        if (null === me.minNotZero) if (me.min > 0) me.minNotZero = me.min; else if (me.max < 1) me.minNotZero = Math.pow(10, Math.floor(log10(me.max))); else me.minNotZero = DEFAULT_MIN;
                    },
                    buildTicks: function() {
                        var me = this;
                        var tickOpts = me.options.ticks;
                        var reverse = !me.isHorizontal();
                        var generationOptions = {
                            min: nonNegativeOrDefault(tickOpts.min),
                            max: nonNegativeOrDefault(tickOpts.max)
                        };
                        var ticks = me.ticks = generateTicks$1(generationOptions, me);
                        me.max = helpers$1.max(ticks);
                        me.min = helpers$1.min(ticks);
                        if (tickOpts.reverse) {
                            reverse = !reverse;
                            me.start = me.max;
                            me.end = me.min;
                        } else {
                            me.start = me.min;
                            me.end = me.max;
                        }
                        if (reverse) ticks.reverse();
                    },
                    convertTicksToLabels: function() {
                        this.tickValues = this.ticks.slice();
                        core_scale.prototype.convertTicksToLabels.call(this);
                    },
                    getLabelForIndex: function(index, datasetIndex) {
                        return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);
                    },
                    getPixelForTick: function(index) {
                        var ticks = this.tickValues;
                        if (index < 0 || index > ticks.length - 1) return null;
                        return this.getPixelForValue(ticks[index]);
                    },
                    _getFirstTickValue: function(value) {
                        var exp = Math.floor(log10(value));
                        var significand = Math.floor(value / Math.pow(10, exp));
                        return significand * Math.pow(10, exp);
                    },
                    _configure: function() {
                        var me = this;
                        var start = me.min;
                        var offset = 0;
                        core_scale.prototype._configure.call(me);
                        if (0 === start) {
                            start = me._getFirstTickValue(me.minNotZero);
                            offset = valueOrDefault$b(me.options.ticks.fontSize, core_defaults.global.defaultFontSize) / me._length;
                        }
                        me._startValue = log10(start);
                        me._valueOffset = offset;
                        me._valueRange = (log10(me.max) - log10(start)) / (1 - offset);
                    },
                    getPixelForValue: function(value) {
                        var me = this;
                        var decimal = 0;
                        value = +me.getRightValue(value);
                        if (value > me.min && value > 0) decimal = (log10(value) - me._startValue) / me._valueRange + me._valueOffset;
                        return me.getPixelForDecimal(decimal);
                    },
                    getValueForPixel: function(pixel) {
                        var me = this;
                        var decimal = me.getDecimalForPixel(pixel);
                        return 0 === decimal && 0 === me.min ? 0 : Math.pow(10, me._startValue + (decimal - me._valueOffset) * me._valueRange);
                    }
                });
                var _defaults$2 = defaultConfig$2;
                scale_logarithmic._defaults = _defaults$2;
                var valueOrDefault$c = helpers$1.valueOrDefault;
                var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;
                var resolve$4 = helpers$1.options.resolve;
                var defaultConfig$3 = {
                    display: true,
                    animate: true,
                    position: "chartArea",
                    angleLines: {
                        display: true,
                        color: "rgba(0,0,0,0.1)",
                        lineWidth: 1,
                        borderDash: [],
                        borderDashOffset: 0
                    },
                    gridLines: {
                        circular: false
                    },
                    ticks: {
                        showLabelBackdrop: true,
                        backdropColor: "rgba(255,255,255,0.75)",
                        backdropPaddingY: 2,
                        backdropPaddingX: 2,
                        callback: core_ticks.formatters.linear
                    },
                    pointLabels: {
                        display: true,
                        fontSize: 10,
                        callback: function(label) {
                            return label;
                        }
                    }
                };
                function getTickBackdropHeight(opts) {
                    var tickOpts = opts.ticks;
                    if (tickOpts.display && opts.display) return valueOrDefault$c(tickOpts.fontSize, core_defaults.global.defaultFontSize) + 2 * tickOpts.backdropPaddingY;
                    return 0;
                }
                function measureLabelSize(ctx, lineHeight, label) {
                    if (helpers$1.isArray(label)) return {
                        w: helpers$1.longestText(ctx, ctx.font, label),
                        h: label.length * lineHeight
                    };
                    return {
                        w: ctx.measureText(label).width,
                        h: lineHeight
                    };
                }
                function determineLimits(angle, pos, size, min, max) {
                    if (angle === min || angle === max) return {
                        start: pos - size / 2,
                        end: pos + size / 2
                    }; else if (angle < min || angle > max) return {
                        start: pos - size,
                        end: pos
                    };
                    return {
                        start: pos,
                        end: pos + size
                    };
                }
                function fitWithPointLabels(scale) {
                    var plFont = helpers$1.options._parseFont(scale.options.pointLabels);
                    var furthestLimits = {
                        l: 0,
                        r: scale.width,
                        t: 0,
                        b: scale.height - scale.paddingTop
                    };
                    var furthestAngles = {};
                    var i, textSize, pointPosition;
                    scale.ctx.font = plFont.string;
                    scale._pointLabelSizes = [];
                    var valueCount = scale.chart.data.labels.length;
                    for (i = 0; i < valueCount; i++) {
                        pointPosition = scale.getPointPosition(i, scale.drawingArea + 5);
                        textSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i]);
                        scale._pointLabelSizes[i] = textSize;
                        var angleRadians = scale.getIndexAngle(i);
                        var angle = helpers$1.toDegrees(angleRadians) % 360;
                        var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
                        var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
                        if (hLimits.start < furthestLimits.l) {
                            furthestLimits.l = hLimits.start;
                            furthestAngles.l = angleRadians;
                        }
                        if (hLimits.end > furthestLimits.r) {
                            furthestLimits.r = hLimits.end;
                            furthestAngles.r = angleRadians;
                        }
                        if (vLimits.start < furthestLimits.t) {
                            furthestLimits.t = vLimits.start;
                            furthestAngles.t = angleRadians;
                        }
                        if (vLimits.end > furthestLimits.b) {
                            furthestLimits.b = vLimits.end;
                            furthestAngles.b = angleRadians;
                        }
                    }
                    scale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);
                }
                function getTextAlignForAngle(angle) {
                    if (0 === angle || 180 === angle) return "center"; else if (angle < 180) return "left";
                    return "right";
                }
                function fillText(ctx, text, position, lineHeight) {
                    var y = position.y + lineHeight / 2;
                    var i, ilen;
                    if (helpers$1.isArray(text)) for (i = 0, ilen = text.length; i < ilen; ++i) {
                        ctx.fillText(text[i], position.x, y);
                        y += lineHeight;
                    } else ctx.fillText(text, position.x, y);
                }
                function adjustPointPositionForLabelHeight(angle, textSize, position) {
                    if (90 === angle || 270 === angle) position.y -= textSize.h / 2; else if (angle > 270 || angle < 90) position.y -= textSize.h;
                }
                function drawPointLabels(scale) {
                    var ctx = scale.ctx;
                    var opts = scale.options;
                    var pointLabelOpts = opts.pointLabels;
                    var tickBackdropHeight = getTickBackdropHeight(opts);
                    var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);
                    var plFont = helpers$1.options._parseFont(pointLabelOpts);
                    ctx.save();
                    ctx.font = plFont.string;
                    ctx.textBaseline = "middle";
                    for (var i = scale.chart.data.labels.length - 1; i >= 0; i--) {
                        var extra = 0 === i ? tickBackdropHeight / 2 : 0;
                        var pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5);
                        var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);
                        ctx.fillStyle = pointLabelFontColor;
                        var angleRadians = scale.getIndexAngle(i);
                        var angle = helpers$1.toDegrees(angleRadians);
                        ctx.textAlign = getTextAlignForAngle(angle);
                        adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
                        fillText(ctx, scale.pointLabels[i], pointLabelPosition, plFont.lineHeight);
                    }
                    ctx.restore();
                }
                function drawRadiusLine(scale, gridLineOpts, radius, index) {
                    var ctx = scale.ctx;
                    var circular = gridLineOpts.circular;
                    var valueCount = scale.chart.data.labels.length;
                    var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);
                    var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);
                    var pointPosition;
                    if (!circular && !valueCount || !lineColor || !lineWidth) return;
                    ctx.save();
                    ctx.strokeStyle = lineColor;
                    ctx.lineWidth = lineWidth;
                    if (ctx.setLineDash) {
                        ctx.setLineDash(gridLineOpts.borderDash || []);
                        ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0;
                    }
                    ctx.beginPath();
                    if (circular) ctx.arc(scale.xCenter, scale.yCenter, radius, 0, 2 * Math.PI); else {
                        pointPosition = scale.getPointPosition(0, radius);
                        ctx.moveTo(pointPosition.x, pointPosition.y);
                        for (var i = 1; i < valueCount; i++) {
                            pointPosition = scale.getPointPosition(i, radius);
                            ctx.lineTo(pointPosition.x, pointPosition.y);
                        }
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
                function numberOrZero(param) {
                    return helpers$1.isNumber(param) ? param : 0;
                }
                var scale_radialLinear = scale_linearbase.extend({
                    setDimensions: function() {
                        var me = this;
                        me.width = me.maxWidth;
                        me.height = me.maxHeight;
                        me.paddingTop = getTickBackdropHeight(me.options) / 2;
                        me.xCenter = Math.floor(me.width / 2);
                        me.yCenter = Math.floor((me.height - me.paddingTop) / 2);
                        me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;
                    },
                    determineDataLimits: function() {
                        var me = this;
                        var chart = me.chart;
                        var min = Number.POSITIVE_INFINITY;
                        var max = Number.NEGATIVE_INFINITY;
                        helpers$1.each(chart.data.datasets, (function(dataset, datasetIndex) {
                            if (chart.isDatasetVisible(datasetIndex)) {
                                var meta = chart.getDatasetMeta(datasetIndex);
                                helpers$1.each(dataset.data, (function(rawValue, index) {
                                    var value = +me.getRightValue(rawValue);
                                    if (isNaN(value) || meta.data[index].hidden) return;
                                    min = Math.min(value, min);
                                    max = Math.max(value, max);
                                }));
                            }
                        }));
                        me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
                        me.max = max === Number.NEGATIVE_INFINITY ? 0 : max;
                        me.handleTickRangeOptions();
                    },
                    _computeTickLimit: function() {
                        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
                    },
                    convertTicksToLabels: function() {
                        var me = this;
                        scale_linearbase.prototype.convertTicksToLabels.call(me);
                        me.pointLabels = me.chart.data.labels.map((function() {
                            var label = helpers$1.callback(me.options.pointLabels.callback, arguments, me);
                            return label || 0 === label ? label : "";
                        }));
                    },
                    getLabelForIndex: function(index, datasetIndex) {
                        return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
                    },
                    fit: function() {
                        var me = this;
                        var opts = me.options;
                        if (opts.display && opts.pointLabels.display) fitWithPointLabels(me); else me.setCenterPoint(0, 0, 0, 0);
                    },
                    setReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {
                        var me = this;
                        var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
                        var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
                        var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
                        var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);
                        radiusReductionLeft = numberOrZero(radiusReductionLeft);
                        radiusReductionRight = numberOrZero(radiusReductionRight);
                        radiusReductionTop = numberOrZero(radiusReductionTop);
                        radiusReductionBottom = numberOrZero(radiusReductionBottom);
                        me.drawingArea = Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
                        me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
                    },
                    setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {
                        var me = this;
                        var maxRight = me.width - rightMovement - me.drawingArea;
                        var maxLeft = leftMovement + me.drawingArea;
                        var maxTop = topMovement + me.drawingArea;
                        var maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;
                        me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);
                        me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);
                    },
                    getIndexAngle: function(index) {
                        var chart = this.chart;
                        var angleMultiplier = 360 / chart.data.labels.length;
                        var options = chart.options || {};
                        var startAngle = options.startAngle || 0;
                        var angle = (index * angleMultiplier + startAngle) % 360;
                        return (angle < 0 ? angle + 360 : angle) * Math.PI * 2 / 360;
                    },
                    getDistanceFromCenterForValue: function(value) {
                        var me = this;
                        if (helpers$1.isNullOrUndef(value)) return NaN;
                        var scalingFactor = me.drawingArea / (me.max - me.min);
                        if (me.options.ticks.reverse) return (me.max - value) * scalingFactor;
                        return (value - me.min) * scalingFactor;
                    },
                    getPointPosition: function(index, distanceFromCenter) {
                        var me = this;
                        var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
                        return {
                            x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,
                            y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter
                        };
                    },
                    getPointPositionForValue: function(index, value) {
                        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
                    },
                    getBasePosition: function(index) {
                        var me = this;
                        var min = me.min;
                        var max = me.max;
                        return me.getPointPositionForValue(index || 0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);
                    },
                    _drawGrid: function() {
                        var me = this;
                        var ctx = me.ctx;
                        var opts = me.options;
                        var gridLineOpts = opts.gridLines;
                        var angleLineOpts = opts.angleLines;
                        var lineWidth = valueOrDefault$c(angleLineOpts.lineWidth, gridLineOpts.lineWidth);
                        var lineColor = valueOrDefault$c(angleLineOpts.color, gridLineOpts.color);
                        var i, offset, position;
                        if (opts.pointLabels.display) drawPointLabels(me);
                        if (gridLineOpts.display) helpers$1.each(me.ticks, (function(label, index) {
                            if (0 !== index) {
                                offset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
                                drawRadiusLine(me, gridLineOpts, offset, index);
                            }
                        }));
                        if (angleLineOpts.display && lineWidth && lineColor) {
                            ctx.save();
                            ctx.lineWidth = lineWidth;
                            ctx.strokeStyle = lineColor;
                            if (ctx.setLineDash) {
                                ctx.setLineDash(resolve$4([ angleLineOpts.borderDash, gridLineOpts.borderDash, [] ]));
                                ctx.lineDashOffset = resolve$4([ angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0 ]);
                            }
                            for (i = me.chart.data.labels.length - 1; i >= 0; i--) {
                                offset = me.getDistanceFromCenterForValue(opts.ticks.reverse ? me.min : me.max);
                                position = me.getPointPosition(i, offset);
                                ctx.beginPath();
                                ctx.moveTo(me.xCenter, me.yCenter);
                                ctx.lineTo(position.x, position.y);
                                ctx.stroke();
                            }
                            ctx.restore();
                        }
                    },
                    _drawLabels: function() {
                        var me = this;
                        var ctx = me.ctx;
                        var opts = me.options;
                        var tickOpts = opts.ticks;
                        if (!tickOpts.display) return;
                        var startAngle = me.getIndexAngle(0);
                        var tickFont = helpers$1.options._parseFont(tickOpts);
                        var tickFontColor = valueOrDefault$c(tickOpts.fontColor, core_defaults.global.defaultFontColor);
                        var offset, width;
                        ctx.save();
                        ctx.font = tickFont.string;
                        ctx.translate(me.xCenter, me.yCenter);
                        ctx.rotate(startAngle);
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        helpers$1.each(me.ticks, (function(label, index) {
                            if (0 === index && !tickOpts.reverse) return;
                            offset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
                            if (tickOpts.showLabelBackdrop) {
                                width = ctx.measureText(label).width;
                                ctx.fillStyle = tickOpts.backdropColor;
                                ctx.fillRect(-width / 2 - tickOpts.backdropPaddingX, -offset - tickFont.size / 2 - tickOpts.backdropPaddingY, width + 2 * tickOpts.backdropPaddingX, tickFont.size + 2 * tickOpts.backdropPaddingY);
                            }
                            ctx.fillStyle = tickFontColor;
                            ctx.fillText(label, 0, -offset);
                        }));
                        ctx.restore();
                    },
                    _drawTitle: helpers$1.noop
                });
                var _defaults$3 = defaultConfig$3;
                scale_radialLinear._defaults = _defaults$3;
                var deprecated$1 = helpers$1._deprecated;
                var resolve$5 = helpers$1.options.resolve;
                var valueOrDefault$d = helpers$1.valueOrDefault;
                var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
                var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
                var INTERVALS = {
                    millisecond: {
                        common: true,
                        size: 1,
                        steps: 1e3
                    },
                    second: {
                        common: true,
                        size: 1e3,
                        steps: 60
                    },
                    minute: {
                        common: true,
                        size: 6e4,
                        steps: 60
                    },
                    hour: {
                        common: true,
                        size: 36e5,
                        steps: 24
                    },
                    day: {
                        common: true,
                        size: 864e5,
                        steps: 30
                    },
                    week: {
                        common: false,
                        size: 6048e5,
                        steps: 4
                    },
                    month: {
                        common: true,
                        size: 2628e6,
                        steps: 12
                    },
                    quarter: {
                        common: false,
                        size: 7884e6,
                        steps: 4
                    },
                    year: {
                        common: true,
                        size: 3154e7
                    }
                };
                var UNITS = Object.keys(INTERVALS);
                function sorter(a, b) {
                    return a - b;
                }
                function arrayUnique(items) {
                    var hash = {};
                    var out = [];
                    var i, ilen, item;
                    for (i = 0, ilen = items.length; i < ilen; ++i) {
                        item = items[i];
                        if (!hash[item]) {
                            hash[item] = true;
                            out.push(item);
                        }
                    }
                    return out;
                }
                function getMin(options) {
                    return helpers$1.valueOrDefault(options.time.min, options.ticks.min);
                }
                function getMax(options) {
                    return helpers$1.valueOrDefault(options.time.max, options.ticks.max);
                }
                function buildLookupTable(timestamps, min, max, distribution) {
                    if ("linear" === distribution || !timestamps.length) return [ {
                        time: min,
                        pos: 0
                    }, {
                        time: max,
                        pos: 1
                    } ];
                    var table = [];
                    var items = [ min ];
                    var i, ilen, prev, curr, next;
                    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
                        curr = timestamps[i];
                        if (curr > min && curr < max) items.push(curr);
                    }
                    items.push(max);
                    for (i = 0, ilen = items.length; i < ilen; ++i) {
                        next = items[i + 1];
                        prev = items[i - 1];
                        curr = items[i];
                        if (void 0 === prev || void 0 === next || Math.round((next + prev) / 2) !== curr) table.push({
                            time: curr,
                            pos: i / (ilen - 1)
                        });
                    }
                    return table;
                }
                function lookup(table, key, value) {
                    var lo = 0;
                    var hi = table.length - 1;
                    var mid, i0, i1;
                    while (lo >= 0 && lo <= hi) {
                        mid = lo + hi >> 1;
                        i0 = table[mid - 1] || null;
                        i1 = table[mid];
                        if (!i0) return {
                            lo: null,
                            hi: i1
                        }; else if (i1[key] < value) lo = mid + 1; else if (i0[key] > value) hi = mid - 1; else return {
                            lo: i0,
                            hi: i1
                        };
                    }
                    return {
                        lo: i1,
                        hi: null
                    };
                }
                function interpolate$1(table, skey, sval, tkey) {
                    var range = lookup(table, skey, sval);
                    var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
                    var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
                    var span = next[skey] - prev[skey];
                    var ratio = span ? (sval - prev[skey]) / span : 0;
                    var offset = (next[tkey] - prev[tkey]) * ratio;
                    return prev[tkey] + offset;
                }
                function toTimestamp(scale, input) {
                    var adapter = scale._adapter;
                    var options = scale.options.time;
                    var parser = options.parser;
                    var format = parser || options.format;
                    var value = input;
                    if ("function" === typeof parser) value = parser(value);
                    if (!helpers$1.isFinite(value)) value = "string" === typeof format ? adapter.parse(value, format) : adapter.parse(value);
                    if (null !== value) return +value;
                    if (!parser && "function" === typeof format) {
                        value = format(input);
                        if (!helpers$1.isFinite(value)) value = adapter.parse(value);
                    }
                    return value;
                }
                function parse(scale, input) {
                    if (helpers$1.isNullOrUndef(input)) return null;
                    var options = scale.options.time;
                    var value = toTimestamp(scale, scale.getRightValue(input));
                    if (null === value) return value;
                    if (options.round) value = +scale._adapter.startOf(value, options.round);
                    return value;
                }
                function determineUnitForAutoTicks(minUnit, min, max, capacity) {
                    var ilen = UNITS.length;
                    var i, interval, factor;
                    for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
                        interval = INTERVALS[UNITS[i]];
                        factor = interval.steps ? interval.steps : MAX_INTEGER;
                        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) return UNITS[i];
                    }
                    return UNITS[ilen - 1];
                }
                function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
                    var i, unit;
                    for (i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
                        unit = UNITS[i];
                        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) return unit;
                    }
                    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
                }
                function determineMajorUnit(unit) {
                    for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) if (INTERVALS[UNITS[i]].common) return UNITS[i];
                }
                function generate(scale, min, max, capacity) {
                    var adapter = scale._adapter;
                    var options = scale.options;
                    var timeOpts = options.time;
                    var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
                    var stepSize = resolve$5([ timeOpts.stepSize, timeOpts.unitStepSize, 1 ]);
                    var weekday = "week" === minor ? timeOpts.isoWeekday : false;
                    var first = min;
                    var ticks = [];
                    var time;
                    if (weekday) first = +adapter.startOf(first, "isoWeek", weekday);
                    first = +adapter.startOf(first, weekday ? "day" : minor);
                    if (adapter.diff(max, min, minor) > 1e5 * stepSize) throw min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor;
                    for (time = first; time < max; time = +adapter.add(time, stepSize, minor)) ticks.push(time);
                    if (time === max || "ticks" === options.bounds) ticks.push(time);
                    return ticks;
                }
                function computeOffsets(table, ticks, min, max, options) {
                    var start = 0;
                    var end = 0;
                    var first, last;
                    if (options.offset && ticks.length) {
                        first = interpolate$1(table, "time", ticks[0], "pos");
                        if (1 === ticks.length) start = 1 - first; else start = (interpolate$1(table, "time", ticks[1], "pos") - first) / 2;
                        last = interpolate$1(table, "time", ticks[ticks.length - 1], "pos");
                        if (1 === ticks.length) end = last; else end = (last - interpolate$1(table, "time", ticks[ticks.length - 2], "pos")) / 2;
                    }
                    return {
                        start,
                        end,
                        factor: 1 / (start + 1 + end)
                    };
                }
                function setMajorTicks(scale, ticks, map, majorUnit) {
                    var adapter = scale._adapter;
                    var first = +adapter.startOf(ticks[0].value, majorUnit);
                    var last = ticks[ticks.length - 1].value;
                    var major, index;
                    for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
                        index = map[major];
                        if (index >= 0) ticks[index].major = true;
                    }
                    return ticks;
                }
                function ticksFromTimestamps(scale, values, majorUnit) {
                    var ticks = [];
                    var map = {};
                    var ilen = values.length;
                    var i, value;
                    for (i = 0; i < ilen; ++i) {
                        value = values[i];
                        map[value] = i;
                        ticks.push({
                            value,
                            major: false
                        });
                    }
                    return 0 === ilen || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
                }
                var defaultConfig$4 = {
                    position: "bottom",
                    distribution: "linear",
                    bounds: "data",
                    adapters: {},
                    time: {
                        parser: false,
                        unit: false,
                        round: false,
                        displayFormat: false,
                        isoWeekday: false,
                        minUnit: "millisecond",
                        displayFormats: {}
                    },
                    ticks: {
                        autoSkip: false,
                        source: "auto",
                        major: {
                            enabled: false
                        }
                    }
                };
                var scale_time = core_scale.extend({
                    initialize: function() {
                        this.mergeTicksOptions();
                        core_scale.prototype.initialize.call(this);
                    },
                    update: function() {
                        var me = this;
                        var options = me.options;
                        var time = options.time || (options.time = {});
                        var adapter = me._adapter = new core_adapters._date(options.adapters.date);
                        deprecated$1("time scale", time.format, "time.format", "time.parser");
                        deprecated$1("time scale", time.min, "time.min", "ticks.min");
                        deprecated$1("time scale", time.max, "time.max", "ticks.max");
                        helpers$1.mergeIf(time.displayFormats, adapter.formats());
                        return core_scale.prototype.update.apply(me, arguments);
                    },
                    getRightValue: function(rawValue) {
                        if (rawValue && void 0 !== rawValue.t) rawValue = rawValue.t;
                        return core_scale.prototype.getRightValue.call(this, rawValue);
                    },
                    determineDataLimits: function() {
                        var me = this;
                        var chart = me.chart;
                        var adapter = me._adapter;
                        var options = me.options;
                        var unit = options.time.unit || "day";
                        var min = MAX_INTEGER;
                        var max = MIN_INTEGER;
                        var timestamps = [];
                        var datasets = [];
                        var labels = [];
                        var i, j, ilen, jlen, data, timestamp, labelsAdded;
                        var dataLabels = me._getLabels();
                        for (i = 0, ilen = dataLabels.length; i < ilen; ++i) labels.push(parse(me, dataLabels[i]));
                        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) if (chart.isDatasetVisible(i)) {
                            data = chart.data.datasets[i].data;
                            if (helpers$1.isObject(data[0])) {
                                datasets[i] = [];
                                for (j = 0, jlen = data.length; j < jlen; ++j) {
                                    timestamp = parse(me, data[j]);
                                    timestamps.push(timestamp);
                                    datasets[i][j] = timestamp;
                                }
                            } else {
                                datasets[i] = labels.slice(0);
                                if (!labelsAdded) {
                                    timestamps = timestamps.concat(labels);
                                    labelsAdded = true;
                                }
                            }
                        } else datasets[i] = [];
                        if (labels.length) {
                            min = Math.min(min, labels[0]);
                            max = Math.max(max, labels[labels.length - 1]);
                        }
                        if (timestamps.length) {
                            timestamps = ilen > 1 ? arrayUnique(timestamps).sort(sorter) : timestamps.sort(sorter);
                            min = Math.min(min, timestamps[0]);
                            max = Math.max(max, timestamps[timestamps.length - 1]);
                        }
                        min = parse(me, getMin(options)) || min;
                        max = parse(me, getMax(options)) || max;
                        min = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;
                        max = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max;
                        me.min = Math.min(min, max);
                        me.max = Math.max(min + 1, max);
                        me._table = [];
                        me._timestamps = {
                            data: timestamps,
                            datasets,
                            labels
                        };
                    },
                    buildTicks: function() {
                        var me = this;
                        var min = me.min;
                        var max = me.max;
                        var options = me.options;
                        var tickOpts = options.ticks;
                        var timeOpts = options.time;
                        var timestamps = me._timestamps;
                        var ticks = [];
                        var capacity = me.getLabelCapacity(min);
                        var source = tickOpts.source;
                        var distribution = options.distribution;
                        var i, ilen, timestamp;
                        if ("data" === source || "auto" === source && "series" === distribution) timestamps = timestamps.data; else if ("labels" === source) timestamps = timestamps.labels; else timestamps = generate(me, min, max, capacity);
                        if ("ticks" === options.bounds && timestamps.length) {
                            min = timestamps[0];
                            max = timestamps[timestamps.length - 1];
                        }
                        min = parse(me, getMin(options)) || min;
                        max = parse(me, getMax(options)) || max;
                        for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
                            timestamp = timestamps[i];
                            if (timestamp >= min && timestamp <= max) ticks.push(timestamp);
                        }
                        me.min = min;
                        me.max = max;
                        me._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, me.min, me.max, capacity) : determineUnitForFormatting(me, ticks.length, timeOpts.minUnit, me.min, me.max));
                        me._majorUnit = !tickOpts.major.enabled || "year" === me._unit ? void 0 : determineMajorUnit(me._unit);
                        me._table = buildLookupTable(me._timestamps.data, min, max, distribution);
                        me._offsets = computeOffsets(me._table, ticks, min, max, options);
                        if (tickOpts.reverse) ticks.reverse();
                        return ticksFromTimestamps(me, ticks, me._majorUnit);
                    },
                    getLabelForIndex: function(index, datasetIndex) {
                        var me = this;
                        var adapter = me._adapter;
                        var data = me.chart.data;
                        var timeOpts = me.options.time;
                        var label = data.labels && index < data.labels.length ? data.labels[index] : "";
                        var value = data.datasets[datasetIndex].data[index];
                        if (helpers$1.isObject(value)) label = me.getRightValue(value);
                        if (timeOpts.tooltipFormat) return adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);
                        if ("string" === typeof label) return label;
                        return adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);
                    },
                    tickFormatFunction: function(time, index, ticks, format) {
                        var me = this;
                        var adapter = me._adapter;
                        var options = me.options;
                        var formats = options.time.displayFormats;
                        var minorFormat = formats[me._unit];
                        var majorUnit = me._majorUnit;
                        var majorFormat = formats[majorUnit];
                        var tick = ticks[index];
                        var tickOpts = options.ticks;
                        var major = majorUnit && majorFormat && tick && tick.major;
                        var label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);
                        var nestedTickOpts = major ? tickOpts.major : tickOpts.minor;
                        var formatter = resolve$5([ nestedTickOpts.callback, nestedTickOpts.userCallback, tickOpts.callback, tickOpts.userCallback ]);
                        return formatter ? formatter(label, index, ticks) : label;
                    },
                    convertTicksToLabels: function(ticks) {
                        var labels = [];
                        var i, ilen;
                        for (i = 0, ilen = ticks.length; i < ilen; ++i) labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));
                        return labels;
                    },
                    getPixelForOffset: function(time) {
                        var me = this;
                        var offsets = me._offsets;
                        var pos = interpolate$1(me._table, "time", time, "pos");
                        return me.getPixelForDecimal((offsets.start + pos) * offsets.factor);
                    },
                    getPixelForValue: function(value, index, datasetIndex) {
                        var me = this;
                        var time = null;
                        if (void 0 !== index && void 0 !== datasetIndex) time = me._timestamps.datasets[datasetIndex][index];
                        if (null === time) time = parse(me, value);
                        if (null !== time) return me.getPixelForOffset(time);
                    },
                    getPixelForTick: function(index) {
                        var ticks = this.getTicks();
                        return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;
                    },
                    getValueForPixel: function(pixel) {
                        var me = this;
                        var offsets = me._offsets;
                        var pos = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
                        var time = interpolate$1(me._table, "pos", pos, "time");
                        return me._adapter._create(time);
                    },
                    _getLabelSize: function(label) {
                        var me = this;
                        var ticksOpts = me.options.ticks;
                        var tickLabelWidth = me.ctx.measureText(label).width;
                        var angle = helpers$1.toRadians(me.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
                        var cosRotation = Math.cos(angle);
                        var sinRotation = Math.sin(angle);
                        var tickFontSize = valueOrDefault$d(ticksOpts.fontSize, core_defaults.global.defaultFontSize);
                        return {
                            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
                            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
                        };
                    },
                    getLabelWidth: function(label) {
                        return this._getLabelSize(label).w;
                    },
                    getLabelCapacity: function(exampleTime) {
                        var me = this;
                        var timeOpts = me.options.time;
                        var displayFormats = timeOpts.displayFormats;
                        var format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
                        var exampleLabel = me.tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [ exampleTime ], me._majorUnit), format);
                        var size = me._getLabelSize(exampleLabel);
                        var capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h);
                        if (me.options.offset) capacity--;
                        return capacity > 0 ? capacity : 1;
                    }
                });
                var _defaults$4 = defaultConfig$4;
                scale_time._defaults = _defaults$4;
                var scales = {
                    category: scale_category,
                    linear: scale_linear,
                    logarithmic: scale_logarithmic,
                    radialLinear: scale_radialLinear,
                    time: scale_time
                };
                var FORMATS = {
                    datetime: "MMM D, YYYY, h:mm:ss a",
                    millisecond: "h:mm:ss.SSS a",
                    second: "h:mm:ss a",
                    minute: "h:mm a",
                    hour: "hA",
                    day: "MMM D",
                    week: "ll",
                    month: "MMM YYYY",
                    quarter: "[Q]Q - YYYY",
                    year: "YYYY"
                };
                core_adapters._date.override("function" === typeof moment ? {
                    _id: "moment",
                    formats: function() {
                        return FORMATS;
                    },
                    parse: function(value, format) {
                        if ("string" === typeof value && "string" === typeof format) value = moment(value, format); else if (!(value instanceof moment)) value = moment(value);
                        return value.isValid() ? value.valueOf() : null;
                    },
                    format: function(time, format) {
                        return moment(time).format(format);
                    },
                    add: function(time, amount, unit) {
                        return moment(time).add(amount, unit).valueOf();
                    },
                    diff: function(max, min, unit) {
                        return moment(max).diff(moment(min), unit);
                    },
                    startOf: function(time, unit, weekday) {
                        time = moment(time);
                        if ("isoWeek" === unit) return time.isoWeekday(weekday).valueOf();
                        return time.startOf(unit).valueOf();
                    },
                    endOf: function(time, unit) {
                        return moment(time).endOf(unit).valueOf();
                    },
                    _create: function(time) {
                        return moment(time);
                    }
                } : {});
                core_defaults._set("global", {
                    plugins: {
                        filler: {
                            propagate: true
                        }
                    }
                });
                var mappers = {
                    dataset: function(source) {
                        var index = source.fill;
                        var chart = source.chart;
                        var meta = chart.getDatasetMeta(index);
                        var visible = meta && chart.isDatasetVisible(index);
                        var points = visible && meta.dataset._children || [];
                        var length = points.length || 0;
                        return !length ? null : function(point, i) {
                            return i < length && points[i]._view || null;
                        };
                    },
                    boundary: function(source) {
                        var boundary = source.boundary;
                        var x = boundary ? boundary.x : null;
                        var y = boundary ? boundary.y : null;
                        if (helpers$1.isArray(boundary)) return function(point, i) {
                            return boundary[i];
                        };
                        return function(point) {
                            return {
                                x: null === x ? point.x : x,
                                y: null === y ? point.y : y
                            };
                        };
                    }
                };
                function decodeFill(el, index, count) {
                    var model = el._model || {};
                    var fill = model.fill;
                    var target;
                    if (void 0 === fill) fill = !!model.backgroundColor;
                    if (false === fill || null === fill) return false;
                    if (true === fill) return "origin";
                    target = parseFloat(fill, 10);
                    if (isFinite(target) && Math.floor(target) === target) {
                        if ("-" === fill[0] || "+" === fill[0]) target = index + target;
                        if (target === index || target < 0 || target >= count) return false;
                        return target;
                    }
                    switch (fill) {
                      case "bottom":
                        return "start";

                      case "top":
                        return "end";

                      case "zero":
                        return "origin";

                      case "origin":
                      case "start":
                      case "end":
                        return fill;

                      default:
                        return false;
                    }
                }
                function computeLinearBoundary(source) {
                    var model = source.el._model || {};
                    var scale = source.el._scale || {};
                    var fill = source.fill;
                    var target = null;
                    var horizontal;
                    if (isFinite(fill)) return null;
                    if ("start" === fill) target = void 0 === model.scaleBottom ? scale.bottom : model.scaleBottom; else if ("end" === fill) target = void 0 === model.scaleTop ? scale.top : model.scaleTop; else if (void 0 !== model.scaleZero) target = model.scaleZero; else if (scale.getBasePixel) target = scale.getBasePixel();
                    if (void 0 !== target && null !== target) {
                        if (void 0 !== target.x && void 0 !== target.y) return target;
                        if (helpers$1.isFinite(target)) {
                            horizontal = scale.isHorizontal();
                            return {
                                x: horizontal ? target : null,
                                y: horizontal ? null : target
                            };
                        }
                    }
                    return null;
                }
                function computeCircularBoundary(source) {
                    var scale = source.el._scale;
                    var options = scale.options;
                    var length = scale.chart.data.labels.length;
                    var fill = source.fill;
                    var target = [];
                    var start, end, center, i, point;
                    if (!length) return null;
                    start = options.ticks.reverse ? scale.max : scale.min;
                    end = options.ticks.reverse ? scale.min : scale.max;
                    center = scale.getPointPositionForValue(0, start);
                    for (i = 0; i < length; ++i) {
                        point = "start" === fill || "end" === fill ? scale.getPointPositionForValue(i, "start" === fill ? start : end) : scale.getBasePosition(i);
                        if (options.gridLines.circular) {
                            point.cx = center.x;
                            point.cy = center.y;
                            point.angle = scale.getIndexAngle(i) - Math.PI / 2;
                        }
                        target.push(point);
                    }
                    return target;
                }
                function computeBoundary(source) {
                    var scale = source.el._scale || {};
                    if (scale.getPointPositionForValue) return computeCircularBoundary(source);
                    return computeLinearBoundary(source);
                }
                function resolveTarget(sources, index, propagate) {
                    var source = sources[index];
                    var fill = source.fill;
                    var visited = [ index ];
                    var target;
                    if (!propagate) return fill;
                    while (false !== fill && -1 === visited.indexOf(fill)) {
                        if (!isFinite(fill)) return fill;
                        target = sources[fill];
                        if (!target) return false;
                        if (target.visible) return fill;
                        visited.push(fill);
                        fill = target.fill;
                    }
                    return false;
                }
                function createMapper(source) {
                    var fill = source.fill;
                    var type = "dataset";
                    if (false === fill) return null;
                    if (!isFinite(fill)) type = "boundary";
                    return mappers[type](source);
                }
                function isDrawable(point) {
                    return point && !point.skip;
                }
                function drawArea(ctx, curve0, curve1, len0, len1) {
                    var i, cx, cy, r;
                    if (!len0 || !len1) return;
                    ctx.moveTo(curve0[0].x, curve0[0].y);
                    for (i = 1; i < len0; ++i) helpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
                    if (void 0 !== curve1[0].angle) {
                        cx = curve1[0].cx;
                        cy = curve1[0].cy;
                        r = Math.sqrt(Math.pow(curve1[0].x - cx, 2) + Math.pow(curve1[0].y - cy, 2));
                        for (i = len1 - 1; i > 0; --i) ctx.arc(cx, cy, r, curve1[i].angle, curve1[i - 1].angle, true);
                        return;
                    }
                    ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);
                    for (i = len1 - 1; i > 0; --i) helpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
                }
                function doFill(ctx, points, mapper, view, color, loop) {
                    var count = points.length;
                    var span = view.spanGaps;
                    var curve0 = [];
                    var curve1 = [];
                    var len0 = 0;
                    var len1 = 0;
                    var i, ilen, index, p0, p1, d0, d1, loopOffset;
                    ctx.beginPath();
                    for (i = 0, ilen = count; i < ilen; ++i) {
                        index = i % count;
                        p0 = points[index]._view;
                        p1 = mapper(p0, index, view);
                        d0 = isDrawable(p0);
                        d1 = isDrawable(p1);
                        if (loop && void 0 === loopOffset && d0) {
                            loopOffset = i + 1;
                            ilen = count + loopOffset;
                        }
                        if (d0 && d1) {
                            len0 = curve0.push(p0);
                            len1 = curve1.push(p1);
                        } else if (len0 && len1) if (!span) {
                            drawArea(ctx, curve0, curve1, len0, len1);
                            len0 = len1 = 0;
                            curve0 = [];
                            curve1 = [];
                        } else {
                            if (d0) curve0.push(p0);
                            if (d1) curve1.push(p1);
                        }
                    }
                    drawArea(ctx, curve0, curve1, len0, len1);
                    ctx.closePath();
                    ctx.fillStyle = color;
                    ctx.fill();
                }
                var plugin_filler = {
                    id: "filler",
                    afterDatasetsUpdate: function(chart, options) {
                        var count = (chart.data.datasets || []).length;
                        var propagate = options.propagate;
                        var sources = [];
                        var meta, i, el, source;
                        for (i = 0; i < count; ++i) {
                            meta = chart.getDatasetMeta(i);
                            el = meta.dataset;
                            source = null;
                            if (el && el._model && el instanceof elements.Line) source = {
                                visible: chart.isDatasetVisible(i),
                                fill: decodeFill(el, i, count),
                                chart,
                                el
                            };
                            meta.$filler = source;
                            sources.push(source);
                        }
                        for (i = 0; i < count; ++i) {
                            source = sources[i];
                            if (!source) continue;
                            source.fill = resolveTarget(sources, i, propagate);
                            source.boundary = computeBoundary(source);
                            source.mapper = createMapper(source);
                        }
                    },
                    beforeDatasetsDraw: function(chart) {
                        var metasets = chart._getSortedVisibleDatasetMetas();
                        var ctx = chart.ctx;
                        var meta, i, el, view, points, mapper, color;
                        for (i = metasets.length - 1; i >= 0; --i) {
                            meta = metasets[i].$filler;
                            if (!meta || !meta.visible) continue;
                            el = meta.el;
                            view = el._view;
                            points = el._children || [];
                            mapper = meta.mapper;
                            color = view.backgroundColor || core_defaults.global.defaultColor;
                            if (mapper && color && points.length) {
                                helpers$1.canvas.clipArea(ctx, chart.chartArea);
                                doFill(ctx, points, mapper, view, color, el._loop);
                                helpers$1.canvas.unclipArea(ctx);
                            }
                        }
                    }
                };
                var getRtlHelper$1 = helpers$1.rtl.getRtlAdapter;
                var noop$1 = helpers$1.noop;
                var valueOrDefault$e = helpers$1.valueOrDefault;
                core_defaults._set("global", {
                    legend: {
                        display: true,
                        position: "top",
                        align: "center",
                        fullWidth: true,
                        reverse: false,
                        weight: 1e3,
                        onClick: function(e, legendItem) {
                            var index = legendItem.datasetIndex;
                            var ci = this.chart;
                            var meta = ci.getDatasetMeta(index);
                            meta.hidden = null === meta.hidden ? !ci.data.datasets[index].hidden : null;
                            ci.update();
                        },
                        onHover: null,
                        onLeave: null,
                        labels: {
                            boxWidth: 40,
                            padding: 10,
                            generateLabels: function(chart) {
                                var datasets = chart.data.datasets;
                                var options = chart.options.legend || {};
                                var usePointStyle = options.labels && options.labels.usePointStyle;
                                return chart._getSortedDatasetMetas().map((function(meta) {
                                    var style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
                                    return {
                                        text: datasets[meta.index].label,
                                        fillStyle: style.backgroundColor,
                                        hidden: !chart.isDatasetVisible(meta.index),
                                        lineCap: style.borderCapStyle,
                                        lineDash: style.borderDash,
                                        lineDashOffset: style.borderDashOffset,
                                        lineJoin: style.borderJoinStyle,
                                        lineWidth: style.borderWidth,
                                        strokeStyle: style.borderColor,
                                        pointStyle: style.pointStyle,
                                        rotation: style.rotation,
                                        datasetIndex: meta.index
                                    };
                                }), this);
                            }
                        }
                    },
                    legendCallback: function(chart) {
                        var list = document.createElement("ul");
                        var datasets = chart.data.datasets;
                        var i, ilen, listItem, listItemSpan;
                        list.setAttribute("class", chart.id + "-legend");
                        for (i = 0, ilen = datasets.length; i < ilen; i++) {
                            listItem = list.appendChild(document.createElement("li"));
                            listItemSpan = listItem.appendChild(document.createElement("span"));
                            listItemSpan.style.backgroundColor = datasets[i].backgroundColor;
                            if (datasets[i].label) listItem.appendChild(document.createTextNode(datasets[i].label));
                        }
                        return list.outerHTML;
                    }
                });
                function getBoxWidth(labelOpts, fontSize) {
                    return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;
                }
                var Legend = core_element.extend({
                    initialize: function(config) {
                        var me = this;
                        helpers$1.extend(me, config);
                        me.legendHitBoxes = [];
                        me._hoveredItem = null;
                        me.doughnutMode = false;
                    },
                    beforeUpdate: noop$1,
                    update: function(maxWidth, maxHeight, margins) {
                        var me = this;
                        me.beforeUpdate();
                        me.maxWidth = maxWidth;
                        me.maxHeight = maxHeight;
                        me.margins = margins;
                        me.beforeSetDimensions();
                        me.setDimensions();
                        me.afterSetDimensions();
                        me.beforeBuildLabels();
                        me.buildLabels();
                        me.afterBuildLabels();
                        me.beforeFit();
                        me.fit();
                        me.afterFit();
                        me.afterUpdate();
                        return me.minSize;
                    },
                    afterUpdate: noop$1,
                    beforeSetDimensions: noop$1,
                    setDimensions: function() {
                        var me = this;
                        if (me.isHorizontal()) {
                            me.width = me.maxWidth;
                            me.left = 0;
                            me.right = me.width;
                        } else {
                            me.height = me.maxHeight;
                            me.top = 0;
                            me.bottom = me.height;
                        }
                        me.paddingLeft = 0;
                        me.paddingTop = 0;
                        me.paddingRight = 0;
                        me.paddingBottom = 0;
                        me.minSize = {
                            width: 0,
                            height: 0
                        };
                    },
                    afterSetDimensions: noop$1,
                    beforeBuildLabels: noop$1,
                    buildLabels: function() {
                        var me = this;
                        var labelOpts = me.options.labels || {};
                        var legendItems = helpers$1.callback(labelOpts.generateLabels, [ me.chart ], me) || [];
                        if (labelOpts.filter) legendItems = legendItems.filter((function(item) {
                            return labelOpts.filter(item, me.chart.data);
                        }));
                        if (me.options.reverse) legendItems.reverse();
                        me.legendItems = legendItems;
                    },
                    afterBuildLabels: noop$1,
                    beforeFit: noop$1,
                    fit: function() {
                        var me = this;
                        var opts = me.options;
                        var labelOpts = opts.labels;
                        var display = opts.display;
                        var ctx = me.ctx;
                        var labelFont = helpers$1.options._parseFont(labelOpts);
                        var fontSize = labelFont.size;
                        var hitboxes = me.legendHitBoxes = [];
                        var minSize = me.minSize;
                        var isHorizontal = me.isHorizontal();
                        if (isHorizontal) {
                            minSize.width = me.maxWidth;
                            minSize.height = display ? 10 : 0;
                        } else {
                            minSize.width = display ? 10 : 0;
                            minSize.height = me.maxHeight;
                        }
                        if (!display) {
                            me.width = minSize.width = me.height = minSize.height = 0;
                            return;
                        }
                        ctx.font = labelFont.string;
                        if (isHorizontal) {
                            var lineWidths = me.lineWidths = [ 0 ];
                            var totalHeight = 0;
                            ctx.textAlign = "left";
                            ctx.textBaseline = "middle";
                            helpers$1.each(me.legendItems, (function(legendItem, i) {
                                var boxWidth = getBoxWidth(labelOpts, fontSize);
                                var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                                if (0 === i || lineWidths[lineWidths.length - 1] + width + 2 * labelOpts.padding > minSize.width) {
                                    totalHeight += fontSize + labelOpts.padding;
                                    lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                                }
                                hitboxes[i] = {
                                    left: 0,
                                    top: 0,
                                    width,
                                    height: fontSize
                                };
                                lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
                            }));
                            minSize.height += totalHeight;
                        } else {
                            var vPadding = labelOpts.padding;
                            var columnWidths = me.columnWidths = [];
                            var columnHeights = me.columnHeights = [];
                            var totalWidth = labelOpts.padding;
                            var currentColWidth = 0;
                            var currentColHeight = 0;
                            helpers$1.each(me.legendItems, (function(legendItem, i) {
                                var boxWidth = getBoxWidth(labelOpts, fontSize);
                                var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                                if (i > 0 && currentColHeight + fontSize + 2 * vPadding > minSize.height) {
                                    totalWidth += currentColWidth + labelOpts.padding;
                                    columnWidths.push(currentColWidth);
                                    columnHeights.push(currentColHeight);
                                    currentColWidth = 0;
                                    currentColHeight = 0;
                                }
                                currentColWidth = Math.max(currentColWidth, itemWidth);
                                currentColHeight += fontSize + vPadding;
                                hitboxes[i] = {
                                    left: 0,
                                    top: 0,
                                    width: itemWidth,
                                    height: fontSize
                                };
                            }));
                            totalWidth += currentColWidth;
                            columnWidths.push(currentColWidth);
                            columnHeights.push(currentColHeight);
                            minSize.width += totalWidth;
                        }
                        me.width = minSize.width;
                        me.height = minSize.height;
                    },
                    afterFit: noop$1,
                    isHorizontal: function() {
                        return "top" === this.options.position || "bottom" === this.options.position;
                    },
                    draw: function() {
                        var me = this;
                        var opts = me.options;
                        var labelOpts = opts.labels;
                        var globalDefaults = core_defaults.global;
                        var defaultColor = globalDefaults.defaultColor;
                        var lineDefault = globalDefaults.elements.line;
                        var legendHeight = me.height;
                        var columnHeights = me.columnHeights;
                        var legendWidth = me.width;
                        var lineWidths = me.lineWidths;
                        if (!opts.display) return;
                        var rtlHelper = getRtlHelper$1(opts.rtl, me.left, me.minSize.width);
                        var ctx = me.ctx;
                        var fontColor = valueOrDefault$e(labelOpts.fontColor, globalDefaults.defaultFontColor);
                        var labelFont = helpers$1.options._parseFont(labelOpts);
                        var fontSize = labelFont.size;
                        var cursor;
                        ctx.textAlign = rtlHelper.textAlign("left");
                        ctx.textBaseline = "middle";
                        ctx.lineWidth = .5;
                        ctx.strokeStyle = fontColor;
                        ctx.fillStyle = fontColor;
                        ctx.font = labelFont.string;
                        var boxWidth = getBoxWidth(labelOpts, fontSize);
                        var hitboxes = me.legendHitBoxes;
                        var drawLegendBox = function(x, y, legendItem) {
                            if (isNaN(boxWidth) || boxWidth <= 0) return;
                            ctx.save();
                            var lineWidth = valueOrDefault$e(legendItem.lineWidth, lineDefault.borderWidth);
                            ctx.fillStyle = valueOrDefault$e(legendItem.fillStyle, defaultColor);
                            ctx.lineCap = valueOrDefault$e(legendItem.lineCap, lineDefault.borderCapStyle);
                            ctx.lineDashOffset = valueOrDefault$e(legendItem.lineDashOffset, lineDefault.borderDashOffset);
                            ctx.lineJoin = valueOrDefault$e(legendItem.lineJoin, lineDefault.borderJoinStyle);
                            ctx.lineWidth = lineWidth;
                            ctx.strokeStyle = valueOrDefault$e(legendItem.strokeStyle, defaultColor);
                            if (ctx.setLineDash) ctx.setLineDash(valueOrDefault$e(legendItem.lineDash, lineDefault.borderDash));
                            if (labelOpts && labelOpts.usePointStyle) {
                                var radius = boxWidth * Math.SQRT2 / 2;
                                var centerX = rtlHelper.xPlus(x, boxWidth / 2);
                                var centerY = y + fontSize / 2;
                                helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY, legendItem.rotation);
                            } else {
                                ctx.fillRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);
                                if (0 !== lineWidth) ctx.strokeRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);
                            }
                            ctx.restore();
                        };
                        var fillText = function(x, y, legendItem, textWidth) {
                            var halfFontSize = fontSize / 2;
                            var xLeft = rtlHelper.xPlus(x, boxWidth + halfFontSize);
                            var yMiddle = y + halfFontSize;
                            ctx.fillText(legendItem.text, xLeft, yMiddle);
                            if (legendItem.hidden) {
                                ctx.beginPath();
                                ctx.lineWidth = 2;
                                ctx.moveTo(xLeft, yMiddle);
                                ctx.lineTo(rtlHelper.xPlus(xLeft, textWidth), yMiddle);
                                ctx.stroke();
                            }
                        };
                        var alignmentOffset = function(dimension, blockSize) {
                            switch (opts.align) {
                              case "start":
                                return labelOpts.padding;

                              case "end":
                                return dimension - blockSize;

                              default:
                                return (dimension - blockSize + labelOpts.padding) / 2;
                            }
                        };
                        var isHorizontal = me.isHorizontal();
                        if (isHorizontal) cursor = {
                            x: me.left + alignmentOffset(legendWidth, lineWidths[0]),
                            y: me.top + labelOpts.padding,
                            line: 0
                        }; else cursor = {
                            x: me.left + labelOpts.padding,
                            y: me.top + alignmentOffset(legendHeight, columnHeights[0]),
                            line: 0
                        };
                        helpers$1.rtl.overrideTextDirection(me.ctx, opts.textDirection);
                        var itemHeight = fontSize + labelOpts.padding;
                        helpers$1.each(me.legendItems, (function(legendItem, i) {
                            var textWidth = ctx.measureText(legendItem.text).width;
                            var width = boxWidth + fontSize / 2 + textWidth;
                            var x = cursor.x;
                            var y = cursor.y;
                            rtlHelper.setWidth(me.minSize.width);
                            if (isHorizontal) {
                                if (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {
                                    y = cursor.y += itemHeight;
                                    cursor.line++;
                                    x = cursor.x = me.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);
                                }
                            } else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {
                                x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
                                cursor.line++;
                                y = cursor.y = me.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);
                            }
                            var realX = rtlHelper.x(x);
                            drawLegendBox(realX, y, legendItem);
                            hitboxes[i].left = rtlHelper.leftForLtr(realX, hitboxes[i].width);
                            hitboxes[i].top = y;
                            fillText(realX, y, legendItem, textWidth);
                            if (isHorizontal) cursor.x += width + labelOpts.padding; else cursor.y += itemHeight;
                        }));
                        helpers$1.rtl.restoreTextDirection(me.ctx, opts.textDirection);
                    },
                    _getLegendItemAt: function(x, y) {
                        var me = this;
                        var i, hitBox, lh;
                        if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
                            lh = me.legendHitBoxes;
                            for (i = 0; i < lh.length; ++i) {
                                hitBox = lh[i];
                                if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) return me.legendItems[i];
                            }
                        }
                        return null;
                    },
                    handleEvent: function(e) {
                        var me = this;
                        var opts = me.options;
                        var type = "mouseup" === e.type ? "click" : e.type;
                        var hoveredItem;
                        if ("mousemove" === type) {
                            if (!opts.onHover && !opts.onLeave) return;
                        } else if ("click" === type) {
                            if (!opts.onClick) return;
                        } else return;
                        hoveredItem = me._getLegendItemAt(e.x, e.y);
                        if ("click" === type) {
                            if (hoveredItem && opts.onClick) opts.onClick.call(me, e.native, hoveredItem);
                        } else {
                            if (opts.onLeave && hoveredItem !== me._hoveredItem) {
                                if (me._hoveredItem) opts.onLeave.call(me, e.native, me._hoveredItem);
                                me._hoveredItem = hoveredItem;
                            }
                            if (opts.onHover && hoveredItem) opts.onHover.call(me, e.native, hoveredItem);
                        }
                    }
                });
                function createNewLegendAndAttach(chart, legendOpts) {
                    var legend = new Legend({
                        ctx: chart.ctx,
                        options: legendOpts,
                        chart
                    });
                    core_layouts.configure(chart, legend, legendOpts);
                    core_layouts.addBox(chart, legend);
                    chart.legend = legend;
                }
                var plugin_legend = {
                    id: "legend",
                    _element: Legend,
                    beforeInit: function(chart) {
                        var legendOpts = chart.options.legend;
                        if (legendOpts) createNewLegendAndAttach(chart, legendOpts);
                    },
                    beforeUpdate: function(chart) {
                        var legendOpts = chart.options.legend;
                        var legend = chart.legend;
                        if (legendOpts) {
                            helpers$1.mergeIf(legendOpts, core_defaults.global.legend);
                            if (legend) {
                                core_layouts.configure(chart, legend, legendOpts);
                                legend.options = legendOpts;
                            } else createNewLegendAndAttach(chart, legendOpts);
                        } else if (legend) {
                            core_layouts.removeBox(chart, legend);
                            delete chart.legend;
                        }
                    },
                    afterEvent: function(chart, e) {
                        var legend = chart.legend;
                        if (legend) legend.handleEvent(e);
                    }
                };
                var noop$2 = helpers$1.noop;
                core_defaults._set("global", {
                    title: {
                        display: false,
                        fontStyle: "bold",
                        fullWidth: true,
                        padding: 10,
                        position: "top",
                        text: "",
                        weight: 2e3
                    }
                });
                var Title = core_element.extend({
                    initialize: function(config) {
                        var me = this;
                        helpers$1.extend(me, config);
                        me.legendHitBoxes = [];
                    },
                    beforeUpdate: noop$2,
                    update: function(maxWidth, maxHeight, margins) {
                        var me = this;
                        me.beforeUpdate();
                        me.maxWidth = maxWidth;
                        me.maxHeight = maxHeight;
                        me.margins = margins;
                        me.beforeSetDimensions();
                        me.setDimensions();
                        me.afterSetDimensions();
                        me.beforeBuildLabels();
                        me.buildLabels();
                        me.afterBuildLabels();
                        me.beforeFit();
                        me.fit();
                        me.afterFit();
                        me.afterUpdate();
                        return me.minSize;
                    },
                    afterUpdate: noop$2,
                    beforeSetDimensions: noop$2,
                    setDimensions: function() {
                        var me = this;
                        if (me.isHorizontal()) {
                            me.width = me.maxWidth;
                            me.left = 0;
                            me.right = me.width;
                        } else {
                            me.height = me.maxHeight;
                            me.top = 0;
                            me.bottom = me.height;
                        }
                        me.paddingLeft = 0;
                        me.paddingTop = 0;
                        me.paddingRight = 0;
                        me.paddingBottom = 0;
                        me.minSize = {
                            width: 0,
                            height: 0
                        };
                    },
                    afterSetDimensions: noop$2,
                    beforeBuildLabels: noop$2,
                    buildLabels: noop$2,
                    afterBuildLabels: noop$2,
                    beforeFit: noop$2,
                    fit: function() {
                        var me = this;
                        var opts = me.options;
                        var minSize = me.minSize = {};
                        var isHorizontal = me.isHorizontal();
                        var lineCount, textSize;
                        if (!opts.display) {
                            me.width = minSize.width = me.height = minSize.height = 0;
                            return;
                        }
                        lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;
                        textSize = lineCount * helpers$1.options._parseFont(opts).lineHeight + 2 * opts.padding;
                        me.width = minSize.width = isHorizontal ? me.maxWidth : textSize;
                        me.height = minSize.height = isHorizontal ? textSize : me.maxHeight;
                    },
                    afterFit: noop$2,
                    isHorizontal: function() {
                        var pos = this.options.position;
                        return "top" === pos || "bottom" === pos;
                    },
                    draw: function() {
                        var me = this;
                        var ctx = me.ctx;
                        var opts = me.options;
                        if (!opts.display) return;
                        var fontOpts = helpers$1.options._parseFont(opts);
                        var lineHeight = fontOpts.lineHeight;
                        var offset = lineHeight / 2 + opts.padding;
                        var rotation = 0;
                        var top = me.top;
                        var left = me.left;
                        var bottom = me.bottom;
                        var right = me.right;
                        var maxWidth, titleX, titleY;
                        ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor);
                        ctx.font = fontOpts.string;
                        if (me.isHorizontal()) {
                            titleX = left + (right - left) / 2;
                            titleY = top + offset;
                            maxWidth = right - left;
                        } else {
                            titleX = "left" === opts.position ? left + offset : right - offset;
                            titleY = top + (bottom - top) / 2;
                            maxWidth = bottom - top;
                            rotation = Math.PI * ("left" === opts.position ? -.5 : .5);
                        }
                        ctx.save();
                        ctx.translate(titleX, titleY);
                        ctx.rotate(rotation);
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        var text = opts.text;
                        if (helpers$1.isArray(text)) {
                            var y = 0;
                            for (var i = 0; i < text.length; ++i) {
                                ctx.fillText(text[i], 0, y, maxWidth);
                                y += lineHeight;
                            }
                        } else ctx.fillText(text, 0, 0, maxWidth);
                        ctx.restore();
                    }
                });
                function createNewTitleBlockAndAttach(chart, titleOpts) {
                    var title = new Title({
                        ctx: chart.ctx,
                        options: titleOpts,
                        chart
                    });
                    core_layouts.configure(chart, title, titleOpts);
                    core_layouts.addBox(chart, title);
                    chart.titleBlock = title;
                }
                var plugin_title = {
                    id: "title",
                    _element: Title,
                    beforeInit: function(chart) {
                        var titleOpts = chart.options.title;
                        if (titleOpts) createNewTitleBlockAndAttach(chart, titleOpts);
                    },
                    beforeUpdate: function(chart) {
                        var titleOpts = chart.options.title;
                        var titleBlock = chart.titleBlock;
                        if (titleOpts) {
                            helpers$1.mergeIf(titleOpts, core_defaults.global.title);
                            if (titleBlock) {
                                core_layouts.configure(chart, titleBlock, titleOpts);
                                titleBlock.options = titleOpts;
                            } else createNewTitleBlockAndAttach(chart, titleOpts);
                        } else if (titleBlock) {
                            core_layouts.removeBox(chart, titleBlock);
                            delete chart.titleBlock;
                        }
                    }
                };
                var plugins = {};
                var filler = plugin_filler;
                var legend = plugin_legend;
                var title = plugin_title;
                plugins.filler = filler;
                plugins.legend = legend;
                plugins.title = title;
                core_controller.helpers = helpers$1;
                core_helpers();
                core_controller._adapters = core_adapters;
                core_controller.Animation = core_animation;
                core_controller.animationService = core_animations;
                core_controller.controllers = controllers;
                core_controller.DatasetController = core_datasetController;
                core_controller.defaults = core_defaults;
                core_controller.Element = core_element;
                core_controller.elements = elements;
                core_controller.Interaction = core_interaction;
                core_controller.layouts = core_layouts;
                core_controller.platform = platform;
                core_controller.plugins = core_plugins;
                core_controller.Scale = core_scale;
                core_controller.scaleService = core_scaleService;
                core_controller.Ticks = core_ticks;
                core_controller.Tooltip = core_tooltip;
                core_controller.helpers.each(scales, (function(scale, type) {
                    core_controller.scaleService.registerScaleType(type, scale, scale._defaults);
                }));
                for (var k in plugins) if (plugins.hasOwnProperty(k)) core_controller.plugins.register(plugins[k]);
                core_controller.platform.initialize();
                var src = core_controller;
                if ("undefined" !== typeof window) window.Chart = core_controller;
                core_controller.Chart = core_controller;
                core_controller.Legend = plugins.legend._element;
                core_controller.Title = plugins.title._element;
                core_controller.pluginService = core_controller.plugins;
                core_controller.PluginBase = core_controller.Element.extend({});
                core_controller.canvasHelpers = core_controller.helpers.canvas;
                core_controller.layoutService = core_controller.layouts;
                core_controller.LinearScaleBase = scale_linearbase;
                core_controller.helpers.each([ "Bar", "Bubble", "Doughnut", "Line", "PolarArea", "Radar", "Scatter" ], (function(klass) {
                    core_controller[klass] = function(ctx, cfg) {
                        return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {
                            type: klass.charAt(0).toLowerCase() + klass.slice(1)
                        }));
                    };
                }));
                return src;
            }));
        },
        2786: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var af = moment.defineLocale("af", {
                    months: "Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember".split("_"),
                    monthsShort: "Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des".split("_"),
                    weekdays: "Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag".split("_"),
                    weekdaysShort: "Son_Maa_Din_Woe_Don_Vry_Sat".split("_"),
                    weekdaysMin: "So_Ma_Di_Wo_Do_Vr_Sa".split("_"),
                    meridiemParse: /vm|nm/i,
                    isPM: function(input) {
                        return /^nm$/i.test(input);
                    },
                    meridiem: function(hours, minutes, isLower) {
                        if (hours < 12) return isLower ? "vm" : "VM"; else return isLower ? "nm" : "NM";
                    },
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[Vandag om] LT",
                        nextDay: "[Mre om] LT",
                        nextWeek: "dddd [om] LT",
                        lastDay: "[Gister om] LT",
                        lastWeek: "[Laas] dddd [om] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "oor %s",
                        past: "%s gelede",
                        s: "'n paar sekondes",
                        ss: "%d sekondes",
                        m: "'n minuut",
                        mm: "%d minute",
                        h: "'n uur",
                        hh: "%d ure",
                        d: "'n dag",
                        dd: "%d dae",
                        M: "'n maand",
                        MM: "%d maande",
                        y: "'n jaar",
                        yy: "%d jaar"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
                    ordinal: function(number) {
                        return number + (1 === number || 8 === number || number >= 20 ? "ste" : "de");
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return af;
            }));
        },
        4130: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var pluralForm = function(n) {
                    return 0 === n ? 0 : 1 === n ? 1 : 2 === n ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
                }, plurals = {
                    s: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
                    m: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
                    h: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
                    d: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
                    M: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
                    y: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ]
                }, pluralize = function(u) {
                    return function(number, withoutSuffix, string, isFuture) {
                        var f = pluralForm(number), str = plurals[u][pluralForm(number)];
                        if (2 === f) str = str[withoutSuffix ? 0 : 1];
                        return str.replace(/%d/i, number);
                    };
                }, months = [ "", "", "", "", "", "", "", "", "", "", "", "" ];
                var arDz = moment.defineLocale("ar-dz", {
                    months,
                    monthsShort: months,
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "D/M/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    meridiemParse: /|/,
                    isPM: function(input) {
                        return "" === input;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 12) return ""; else return "";
                    },
                    calendar: {
                        sameDay: "[  ] LT",
                        nextDay: "[  ] LT",
                        nextWeek: "dddd [ ] LT",
                        lastDay: "[  ] LT",
                        lastWeek: "dddd [ ] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s",
                        past: " %s",
                        s: pluralize("s"),
                        ss: pluralize("s"),
                        m: pluralize("m"),
                        mm: pluralize("m"),
                        h: pluralize("h"),
                        hh: pluralize("h"),
                        d: pluralize("d"),
                        dd: pluralize("d"),
                        M: pluralize("M"),
                        MM: pluralize("M"),
                        y: pluralize("y"),
                        yy: pluralize("y")
                    },
                    postformat: function(string) {
                        return string.replace(/,/g, "");
                    },
                    week: {
                        dow: 0,
                        doy: 4
                    }
                });
                return arDz;
            }));
        },
        6135: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var arKw = moment.defineLocale("ar-kw", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[  ] LT",
                        nextDay: "[  ] LT",
                        nextWeek: "dddd [ ] LT",
                        lastDay: "[  ] LT",
                        lastWeek: "dddd [ ] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s",
                        past: " %s",
                        s: "",
                        ss: "%d ",
                        m: "",
                        mm: "%d ",
                        h: "",
                        hh: "%d ",
                        d: "",
                        dd: "%d ",
                        M: "",
                        MM: "%d ",
                        y: "",
                        yy: "%d "
                    },
                    week: {
                        dow: 0,
                        doy: 12
                    }
                });
                return arKw;
            }));
        },
        6440: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var symbolMap = {
                    1: "1",
                    2: "2",
                    3: "3",
                    4: "4",
                    5: "5",
                    6: "6",
                    7: "7",
                    8: "8",
                    9: "9",
                    0: "0"
                }, pluralForm = function(n) {
                    return 0 === n ? 0 : 1 === n ? 1 : 2 === n ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
                }, plurals = {
                    s: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
                    m: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
                    h: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
                    d: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
                    M: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
                    y: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ]
                }, pluralize = function(u) {
                    return function(number, withoutSuffix, string, isFuture) {
                        var f = pluralForm(number), str = plurals[u][pluralForm(number)];
                        if (2 === f) str = str[withoutSuffix ? 0 : 1];
                        return str.replace(/%d/i, number);
                    };
                }, months = [ "", "", "", "", "", "", "", "", "", "", "", "" ];
                var arLy = moment.defineLocale("ar-ly", {
                    months,
                    monthsShort: months,
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "D/M/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    meridiemParse: /|/,
                    isPM: function(input) {
                        return "" === input;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 12) return ""; else return "";
                    },
                    calendar: {
                        sameDay: "[  ] LT",
                        nextDay: "[  ] LT",
                        nextWeek: "dddd [ ] LT",
                        lastDay: "[  ] LT",
                        lastWeek: "dddd [ ] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s",
                        past: " %s",
                        s: pluralize("s"),
                        ss: pluralize("s"),
                        m: pluralize("m"),
                        mm: pluralize("m"),
                        h: pluralize("h"),
                        hh: pluralize("h"),
                        d: pluralize("d"),
                        dd: pluralize("d"),
                        M: pluralize("M"),
                        MM: pluralize("M"),
                        y: pluralize("y"),
                        yy: pluralize("y")
                    },
                    preparse: function(string) {
                        return string.replace(//g, ",");
                    },
                    postformat: function(string) {
                        return string.replace(/\d/g, (function(match) {
                            return symbolMap[match];
                        })).replace(/,/g, "");
                    },
                    week: {
                        dow: 6,
                        doy: 12
                    }
                });
                return arLy;
            }));
        },
        7702: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var arMa = moment.defineLocale("ar-ma", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[  ] LT",
                        nextDay: "[  ] LT",
                        nextWeek: "dddd [ ] LT",
                        lastDay: "[  ] LT",
                        lastWeek: "dddd [ ] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s",
                        past: " %s",
                        s: "",
                        ss: "%d ",
                        m: "",
                        mm: "%d ",
                        h: "",
                        hh: "%d ",
                        d: "",
                        dd: "%d ",
                        M: "",
                        MM: "%d ",
                        y: "",
                        yy: "%d "
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return arMa;
            }));
        },
        6040: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var symbolMap = {
                    1: "",
                    2: "",
                    3: "",
                    4: "",
                    5: "",
                    6: "",
                    7: "",
                    8: "",
                    9: "",
                    0: ""
                }, numberMap = {
                    "": "1",
                    "": "2",
                    "": "3",
                    "": "4",
                    "": "5",
                    "": "6",
                    "": "7",
                    "": "8",
                    "": "9",
                    "": "0"
                };
                var arSa = moment.defineLocale("ar-sa", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    meridiemParse: /|/,
                    isPM: function(input) {
                        return "" === input;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 12) return ""; else return "";
                    },
                    calendar: {
                        sameDay: "[  ] LT",
                        nextDay: "[  ] LT",
                        nextWeek: "dddd [ ] LT",
                        lastDay: "[  ] LT",
                        lastWeek: "dddd [ ] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s",
                        past: " %s",
                        s: "",
                        ss: "%d ",
                        m: "",
                        mm: "%d ",
                        h: "",
                        hh: "%d ",
                        d: "",
                        dd: "%d ",
                        M: "",
                        MM: "%d ",
                        y: "",
                        yy: "%d "
                    },
                    preparse: function(string) {
                        return string.replace(/[]/g, (function(match) {
                            return numberMap[match];
                        })).replace(//g, ",");
                    },
                    postformat: function(string) {
                        return string.replace(/\d/g, (function(match) {
                            return symbolMap[match];
                        })).replace(/,/g, "");
                    },
                    week: {
                        dow: 0,
                        doy: 6
                    }
                });
                return arSa;
            }));
        },
        7100: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var arTn = moment.defineLocale("ar-tn", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[  ] LT",
                        nextDay: "[  ] LT",
                        nextWeek: "dddd [ ] LT",
                        lastDay: "[  ] LT",
                        lastWeek: "dddd [ ] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s",
                        past: " %s",
                        s: "",
                        ss: "%d ",
                        m: "",
                        mm: "%d ",
                        h: "",
                        hh: "%d ",
                        d: "",
                        dd: "%d ",
                        M: "",
                        MM: "%d ",
                        y: "",
                        yy: "%d "
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return arTn;
            }));
        },
        867: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var symbolMap = {
                    1: "",
                    2: "",
                    3: "",
                    4: "",
                    5: "",
                    6: "",
                    7: "",
                    8: "",
                    9: "",
                    0: ""
                }, numberMap = {
                    "": "1",
                    "": "2",
                    "": "3",
                    "": "4",
                    "": "5",
                    "": "6",
                    "": "7",
                    "": "8",
                    "": "9",
                    "": "0"
                }, pluralForm = function(n) {
                    return 0 === n ? 0 : 1 === n ? 1 : 2 === n ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
                }, plurals = {
                    s: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
                    m: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
                    h: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
                    d: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
                    M: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ],
                    y: [ "  ", " ", [ "", "" ], "%d ", "%d ", "%d " ]
                }, pluralize = function(u) {
                    return function(number, withoutSuffix, string, isFuture) {
                        var f = pluralForm(number), str = plurals[u][pluralForm(number)];
                        if (2 === f) str = str[withoutSuffix ? 0 : 1];
                        return str.replace(/%d/i, number);
                    };
                }, months = [ "", "", "", "", "", "", "", "", "", "", "", "" ];
                var ar = moment.defineLocale("ar", {
                    months,
                    monthsShort: months,
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "D/M/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    meridiemParse: /|/,
                    isPM: function(input) {
                        return "" === input;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 12) return ""; else return "";
                    },
                    calendar: {
                        sameDay: "[  ] LT",
                        nextDay: "[  ] LT",
                        nextWeek: "dddd [ ] LT",
                        lastDay: "[  ] LT",
                        lastWeek: "dddd [ ] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s",
                        past: " %s",
                        s: pluralize("s"),
                        ss: pluralize("s"),
                        m: pluralize("m"),
                        mm: pluralize("m"),
                        h: pluralize("h"),
                        hh: pluralize("h"),
                        d: pluralize("d"),
                        dd: pluralize("d"),
                        M: pluralize("M"),
                        MM: pluralize("M"),
                        y: pluralize("y"),
                        yy: pluralize("y")
                    },
                    preparse: function(string) {
                        return string.replace(/[]/g, (function(match) {
                            return numberMap[match];
                        })).replace(//g, ",");
                    },
                    postformat: function(string) {
                        return string.replace(/\d/g, (function(match) {
                            return symbolMap[match];
                        })).replace(/,/g, "");
                    },
                    week: {
                        dow: 6,
                        doy: 12
                    }
                });
                return ar;
            }));
        },
        1083: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var suffixes = {
                    1: "-inci",
                    5: "-inci",
                    8: "-inci",
                    70: "-inci",
                    80: "-inci",
                    2: "-nci",
                    7: "-nci",
                    20: "-nci",
                    50: "-nci",
                    3: "-nc",
                    4: "-nc",
                    100: "-nc",
                    6: "-nc",
                    9: "-uncu",
                    10: "-uncu",
                    30: "-uncu",
                    60: "-nc",
                    90: "-nc"
                };
                var az = moment.defineLocale("az", {
                    months: "yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr".split("_"),
                    monthsShort: "yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek".split("_"),
                    weekdays: "Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb".split("_"),
                    weekdaysShort: "Baz_BzE_Ax_r_CAx_Cm_n".split("_"),
                    weekdaysMin: "Bz_BE_A__CA_C_".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[bugn saat] LT",
                        nextDay: "[sabah saat] LT",
                        nextWeek: "[gln hft] dddd [saat] LT",
                        lastDay: "[dnn] LT",
                        lastWeek: "[ken hft] dddd [saat] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s sonra",
                        past: "%s vvl",
                        s: "bir ne saniy",
                        ss: "%d saniy",
                        m: "bir dqiq",
                        mm: "%d dqiq",
                        h: "bir saat",
                        hh: "%d saat",
                        d: "bir gn",
                        dd: "%d gn",
                        M: "bir ay",
                        MM: "%d ay",
                        y: "bir il",
                        yy: "%d il"
                    },
                    meridiemParse: /gec|shr|gndz|axam/,
                    isPM: function(input) {
                        return /^(gndz|axam)$/.test(input);
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 4) return "gec"; else if (hour < 12) return "shr"; else if (hour < 17) return "gndz"; else return "axam";
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
                    ordinal: function(number) {
                        if (0 === number) return number + "-nc";
                        var a = number % 10, b = number % 100 - a, c = number >= 100 ? 100 : null;
                        return number + (suffixes[a] || suffixes[b] || suffixes[c]);
                    },
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return az;
            }));
        },
        9808: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                function plural(word, num) {
                    var forms = word.split("_");
                    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
                }
                function relativeTimeWithPlural(number, withoutSuffix, key) {
                    var format = {
                        ss: withoutSuffix ? "__" : "__",
                        mm: withoutSuffix ? "__" : "__",
                        hh: withoutSuffix ? "__" : "__",
                        dd: "__",
                        MM: "__",
                        yy: "__"
                    };
                    if ("m" === key) return withoutSuffix ? "" : ""; else if ("h" === key) return withoutSuffix ? "" : ""; else return number + " " + plural(format[key], +number);
                }
                var be = moment.defineLocale("be", {
                    months: {
                        format: "___________".split("_"),
                        standalone: "___________".split("_")
                    },
                    monthsShort: "___________".split("_"),
                    weekdays: {
                        format: "______".split("_"),
                        standalone: "______".split("_"),
                        isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
                    },
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D MMMM YYYY .",
                        LLL: "D MMMM YYYY ., HH:mm",
                        LLLL: "dddd, D MMMM YYYY ., HH:mm"
                    },
                    calendar: {
                        sameDay: "[ ] LT",
                        nextDay: "[ ] LT",
                        lastDay: "[ ] LT",
                        nextWeek: function() {
                            return "[] dddd [] LT";
                        },
                        lastWeek: function() {
                            switch (this.day()) {
                              case 0:
                              case 3:
                              case 5:
                              case 6:
                                return "[ ] dddd [] LT";

                              case 1:
                              case 2:
                              case 4:
                                return "[ ] dddd [] LT";
                            }
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s",
                        past: "%s ",
                        s: " ",
                        m: relativeTimeWithPlural,
                        mm: relativeTimeWithPlural,
                        h: relativeTimeWithPlural,
                        hh: relativeTimeWithPlural,
                        d: "",
                        dd: relativeTimeWithPlural,
                        M: "",
                        MM: relativeTimeWithPlural,
                        y: "",
                        yy: relativeTimeWithPlural
                    },
                    meridiemParse: /|||/,
                    isPM: function(input) {
                        return /^(|)$/.test(input);
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 4) return ""; else if (hour < 12) return ""; else if (hour < 17) return ""; else return "";
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
                    ordinal: function(number, period) {
                        switch (period) {
                          case "M":
                          case "d":
                          case "DDD":
                          case "w":
                          case "W":
                            return (number % 10 === 2 || number % 10 === 3) && number % 100 !== 12 && number % 100 !== 13 ? number + "-" : number + "-";

                          case "D":
                            return number + "-";

                          default:
                            return number;
                        }
                    },
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return be;
            }));
        },
        8338: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var bg = moment.defineLocale("bg", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "D.MM.YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY H:mm",
                        LLLL: "dddd, D MMMM YYYY H:mm"
                    },
                    calendar: {
                        sameDay: "[ ] LT",
                        nextDay: "[ ] LT",
                        nextWeek: "dddd [] LT",
                        lastDay: "[ ] LT",
                        lastWeek: function() {
                            switch (this.day()) {
                              case 0:
                              case 3:
                              case 6:
                                return "[] dddd [] LT";

                              case 1:
                              case 2:
                              case 4:
                              case 5:
                                return "[] dddd [] LT";
                            }
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s",
                        past: " %s",
                        s: " ",
                        ss: "%d ",
                        m: "",
                        mm: "%d ",
                        h: "",
                        hh: "%d ",
                        d: "",
                        dd: "%d ",
                        w: "",
                        ww: "%d ",
                        M: "",
                        MM: "%d ",
                        y: "",
                        yy: "%d "
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
                    ordinal: function(number) {
                        var lastDigit = number % 10, last2Digits = number % 100;
                        if (0 === number) return number + "-"; else if (0 === last2Digits) return number + "-"; else if (last2Digits > 10 && last2Digits < 20) return number + "-"; else if (1 === lastDigit) return number + "-"; else if (2 === lastDigit) return number + "-"; else if (7 === lastDigit || 8 === lastDigit) return number + "-"; else return number + "-";
                    },
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return bg;
            }));
        },
        7438: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var bm = moment.defineLocale("bm", {
                    months: "Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mkalo_Zuwnkalo_Zuluyekalo_Utikalo_Stanburukalo_kutburukalo_Nowanburukalo_Desanburukalo".split("_"),
                    monthsShort: "Zan_Few_Mar_Awi_M_Zuw_Zul_Uti_St_ku_Now_Des".split("_"),
                    weekdays: "Kari_Ntnn_Tarata_Araba_Alamisa_Juma_Sibiri".split("_"),
                    weekdaysShort: "Kar_Nt_Tar_Ara_Ala_Jum_Sib".split("_"),
                    weekdaysMin: "Ka_Nt_Ta_Ar_Al_Ju_Si".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "MMMM [tile] D [san] YYYY",
                        LLL: "MMMM [tile] D [san] YYYY [lr] HH:mm",
                        LLLL: "dddd MMMM [tile] D [san] YYYY [lr] HH:mm"
                    },
                    calendar: {
                        sameDay: "[Bi lr] LT",
                        nextDay: "[Sini lr] LT",
                        nextWeek: "dddd [don lr] LT",
                        lastDay: "[Kunu lr] LT",
                        lastWeek: "dddd [tmnen lr] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s kn",
                        past: "a b %s b",
                        s: "sanga dama dama",
                        ss: "sekondi %d",
                        m: "miniti kelen",
                        mm: "miniti %d",
                        h: "lr kelen",
                        hh: "lr %d",
                        d: "tile kelen",
                        dd: "tile %d",
                        M: "kalo kelen",
                        MM: "kalo %d",
                        y: "san kelen",
                        yy: "san %d"
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return bm;
            }));
        },
        6225: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var symbolMap = {
                    1: "",
                    2: "",
                    3: "",
                    4: "",
                    5: "",
                    6: "",
                    7: "",
                    8: "",
                    9: "",
                    0: ""
                }, numberMap = {
                    "": "1",
                    "": "2",
                    "": "3",
                    "": "4",
                    "": "5",
                    "": "6",
                    "": "7",
                    "": "8",
                    "": "9",
                    "": "0"
                };
                var bnBd = moment.defineLocale("bn-bd", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "A h:mm ",
                        LTS: "A h:mm:ss ",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY, A h:mm ",
                        LLLL: "dddd, D MMMM YYYY, A h:mm "
                    },
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        nextWeek: "dddd, LT",
                        lastDay: "[] LT",
                        lastWeek: "[] dddd, LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s ",
                        past: "%s ",
                        s: " ",
                        ss: "%d ",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    preparse: function(string) {
                        return string.replace(/[]/g, (function(match) {
                            return numberMap[match];
                        }));
                    },
                    postformat: function(string) {
                        return string.replace(/\d/g, (function(match) {
                            return symbolMap[match];
                        }));
                    },
                    meridiemParse: /||||||/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("" === meridiem) return hour < 4 ? hour : hour + 12; else if ("" === meridiem) return hour; else if ("" === meridiem) return hour; else if ("" === meridiem) return hour >= 3 ? hour : hour + 12; else if ("" === meridiem) return hour + 12; else if ("" === meridiem) return hour + 12;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 4) return ""; else if (hour < 6) return ""; else if (hour < 12) return ""; else if (hour < 15) return ""; else if (hour < 18) return ""; else if (hour < 20) return ""; else return "";
                    },
                    week: {
                        dow: 0,
                        doy: 6
                    }
                });
                return bnBd;
            }));
        },
        8905: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var symbolMap = {
                    1: "",
                    2: "",
                    3: "",
                    4: "",
                    5: "",
                    6: "",
                    7: "",
                    8: "",
                    9: "",
                    0: ""
                }, numberMap = {
                    "": "1",
                    "": "2",
                    "": "3",
                    "": "4",
                    "": "5",
                    "": "6",
                    "": "7",
                    "": "8",
                    "": "9",
                    "": "0"
                };
                var bn = moment.defineLocale("bn", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "A h:mm ",
                        LTS: "A h:mm:ss ",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY, A h:mm ",
                        LLLL: "dddd, D MMMM YYYY, A h:mm "
                    },
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        nextWeek: "dddd, LT",
                        lastDay: "[] LT",
                        lastWeek: "[] dddd, LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s ",
                        past: "%s ",
                        s: " ",
                        ss: "%d ",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    preparse: function(string) {
                        return string.replace(/[]/g, (function(match) {
                            return numberMap[match];
                        }));
                    },
                    postformat: function(string) {
                        return string.replace(/\d/g, (function(match) {
                            return symbolMap[match];
                        }));
                    },
                    meridiemParse: /||||/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("" === meridiem && hour >= 4 || "" === meridiem && hour < 5 || "" === meridiem) return hour + 12; else return hour;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 4) return ""; else if (hour < 10) return ""; else if (hour < 17) return ""; else if (hour < 20) return ""; else return "";
                    },
                    week: {
                        dow: 0,
                        doy: 6
                    }
                });
                return bn;
            }));
        },
        1560: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var symbolMap = {
                    1: "",
                    2: "",
                    3: "",
                    4: "",
                    5: "",
                    6: "",
                    7: "",
                    8: "",
                    9: "",
                    0: ""
                }, numberMap = {
                    "": "1",
                    "": "2",
                    "": "3",
                    "": "4",
                    "": "5",
                    "": "6",
                    "": "7",
                    "": "8",
                    "": "9",
                    "": "0"
                };
                var bo = moment.defineLocale("bo", {
                    months: "___________".split("_"),
                    monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
                    monthsShortRegex: /^(\d{1,2})/,
                    monthsParseExact: true,
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "A h:mm",
                        LTS: "A h:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY, A h:mm",
                        LLLL: "dddd, D MMMM YYYY, A h:mm"
                    },
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        nextWeek: "[], LT",
                        lastDay: "[] LT",
                        lastWeek: "[] dddd, LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s ",
                        past: "%s ",
                        s: "",
                        ss: "%d ",
                        m: "",
                        mm: "%d ",
                        h: "",
                        hh: "%d ",
                        d: "",
                        dd: "%d ",
                        M: "",
                        MM: "%d ",
                        y: "",
                        yy: "%d "
                    },
                    preparse: function(string) {
                        return string.replace(/[]/g, (function(match) {
                            return numberMap[match];
                        }));
                    },
                    postformat: function(string) {
                        return string.replace(/\d/g, (function(match) {
                            return symbolMap[match];
                        }));
                    },
                    meridiemParse: /||||/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("" === meridiem && hour >= 4 || "" === meridiem && hour < 5 || "" === meridiem) return hour + 12; else return hour;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 4) return ""; else if (hour < 10) return ""; else if (hour < 17) return ""; else if (hour < 20) return ""; else return "";
                    },
                    week: {
                        dow: 0,
                        doy: 6
                    }
                });
                return bo;
            }));
        },
        1278: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                function relativeTimeWithMutation(number, withoutSuffix, key) {
                    var format = {
                        mm: "munutenn",
                        MM: "miz",
                        dd: "devezh"
                    };
                    return number + " " + mutation(format[key], number);
                }
                function specialMutationForYears(number) {
                    switch (lastNumber(number)) {
                      case 1:
                      case 3:
                      case 4:
                      case 5:
                      case 9:
                        return number + " bloaz";

                      default:
                        return number + " vloaz";
                    }
                }
                function lastNumber(number) {
                    if (number > 9) return lastNumber(number % 10);
                    return number;
                }
                function mutation(text, number) {
                    if (2 === number) return softMutation(text);
                    return text;
                }
                function softMutation(text) {
                    var mutationTable = {
                        m: "v",
                        b: "v",
                        d: "z"
                    };
                    if (void 0 === mutationTable[text.charAt(0)]) return text;
                    return mutationTable[text.charAt(0)] + text.substring(1);
                }
                var monthsParse = [ /^gen/i, /^c[\']hwe/i, /^meu/i, /^ebr/i, /^mae/i, /^(mez|eve)/i, /^gou/i, /^eos/i, /^gwe/i, /^her/i, /^du/i, /^ker/i ], monthsRegex = /^(genver|c[\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu|gen|c[\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i, monthsStrictRegex = /^(genver|c[\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu)/i, monthsShortStrictRegex = /^(gen|c[\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i, fullWeekdaysParse = [ /^sul/i, /^lun/i, /^meurzh/i, /^merc[\']her/i, /^yaou/i, /^gwener/i, /^sadorn/i ], shortWeekdaysParse = [ /^Sul/i, /^Lun/i, /^Meu/i, /^Mer/i, /^Yao/i, /^Gwe/i, /^Sad/i ], minWeekdaysParse = [ /^Su/i, /^Lu/i, /^Me([^r]|$)/i, /^Mer/i, /^Ya/i, /^Gw/i, /^Sa/i ];
                var br = moment.defineLocale("br", {
                    months: "Genver_Chwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split("_"),
                    monthsShort: "Gen_Chwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split("_"),
                    weekdays: "Sul_Lun_Meurzh_Mercher_Yaou_Gwener_Sadorn".split("_"),
                    weekdaysShort: "Sul_Lun_Meu_Mer_Yao_Gwe_Sad".split("_"),
                    weekdaysMin: "Su_Lu_Me_Mer_Ya_Gw_Sa".split("_"),
                    weekdaysParse: minWeekdaysParse,
                    fullWeekdaysParse,
                    shortWeekdaysParse,
                    minWeekdaysParse,
                    monthsRegex,
                    monthsShortRegex: monthsRegex,
                    monthsStrictRegex,
                    monthsShortStrictRegex,
                    monthsParse,
                    longMonthsParse: monthsParse,
                    shortMonthsParse: monthsParse,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D [a viz] MMMM YYYY",
                        LLL: "D [a viz] MMMM YYYY HH:mm",
                        LLLL: "dddd, D [a viz] MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[Hiziv da] LT",
                        nextDay: "[Warchoazh da] LT",
                        nextWeek: "dddd [da] LT",
                        lastDay: "[Dech da] LT",
                        lastWeek: "dddd [paset da] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "a-benn %s",
                        past: "%s zo",
                        s: "un nebeud segondenno",
                        ss: "%d eilenn",
                        m: "ur vunutenn",
                        mm: relativeTimeWithMutation,
                        h: "un eur",
                        hh: "%d eur",
                        d: "un devezh",
                        dd: relativeTimeWithMutation,
                        M: "ur miz",
                        MM: relativeTimeWithMutation,
                        y: "ur bloaz",
                        yy: specialMutationForYears
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(a|vet)/,
                    ordinal: function(number) {
                        var output = 1 === number ? "a" : "vet";
                        return number + output;
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    },
                    meridiemParse: /a.m.|g.m./,
                    isPM: function(token) {
                        return "g.m." === token;
                    },
                    meridiem: function(hour, minute, isLower) {
                        return hour < 12 ? "a.m." : "g.m.";
                    }
                });
                return br;
            }));
        },
        622: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                function translate(number, withoutSuffix, key) {
                    var result = number + " ";
                    switch (key) {
                      case "ss":
                        if (1 === number) result += "sekunda"; else if (2 === number || 3 === number || 4 === number) result += "sekunde"; else result += "sekundi";
                        return result;

                      case "m":
                        return withoutSuffix ? "jedna minuta" : "jedne minute";

                      case "mm":
                        if (1 === number) result += "minuta"; else if (2 === number || 3 === number || 4 === number) result += "minute"; else result += "minuta";
                        return result;

                      case "h":
                        return withoutSuffix ? "jedan sat" : "jednog sata";

                      case "hh":
                        if (1 === number) result += "sat"; else if (2 === number || 3 === number || 4 === number) result += "sata"; else result += "sati";
                        return result;

                      case "dd":
                        if (1 === number) result += "dan"; else result += "dana";
                        return result;

                      case "MM":
                        if (1 === number) result += "mjesec"; else if (2 === number || 3 === number || 4 === number) result += "mjeseca"; else result += "mjeseci";
                        return result;

                      case "yy":
                        if (1 === number) result += "godina"; else if (2 === number || 3 === number || 4 === number) result += "godine"; else result += "godina";
                        return result;
                    }
                }
                var bs = moment.defineLocale("bs", {
                    months: "januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar".split("_"),
                    monthsShort: "jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.".split("_"),
                    monthsParseExact: true,
                    weekdays: "nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota".split("_"),
                    weekdaysShort: "ned._pon._uto._sri._et._pet._sub.".split("_"),
                    weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D. MMMM YYYY",
                        LLL: "D. MMMM YYYY H:mm",
                        LLLL: "dddd, D. MMMM YYYY H:mm"
                    },
                    calendar: {
                        sameDay: "[danas u] LT",
                        nextDay: "[sutra u] LT",
                        nextWeek: function() {
                            switch (this.day()) {
                              case 0:
                                return "[u] [nedjelju] [u] LT";

                              case 3:
                                return "[u] [srijedu] [u] LT";

                              case 6:
                                return "[u] [subotu] [u] LT";

                              case 1:
                              case 2:
                              case 4:
                              case 5:
                                return "[u] dddd [u] LT";
                            }
                        },
                        lastDay: "[juer u] LT",
                        lastWeek: function() {
                            switch (this.day()) {
                              case 0:
                              case 3:
                                return "[prolu] dddd [u] LT";

                              case 6:
                                return "[prole] [subote] [u] LT";

                              case 1:
                              case 2:
                              case 4:
                              case 5:
                                return "[proli] dddd [u] LT";
                            }
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "za %s",
                        past: "prije %s",
                        s: "par sekundi",
                        ss: translate,
                        m: translate,
                        mm: translate,
                        h: translate,
                        hh: translate,
                        d: "dan",
                        dd: translate,
                        M: "mjesec",
                        MM: translate,
                        y: "godinu",
                        yy: translate
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return bs;
            }));
        },
        2468: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var ca = moment.defineLocale("ca", {
                    months: {
                        standalone: "gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre".split("_"),
                        format: "de gener_de febrer_de mar_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split("_"),
                        isFormat: /D[oD]?(\s)+MMMM/
                    },
                    monthsShort: "gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.".split("_"),
                    monthsParseExact: true,
                    weekdays: "diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte".split("_"),
                    weekdaysShort: "dg._dl._dt._dc._dj._dv._ds.".split("_"),
                    weekdaysMin: "dg_dl_dt_dc_dj_dv_ds".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM [de] YYYY",
                        ll: "D MMM YYYY",
                        LLL: "D MMMM [de] YYYY [a les] H:mm",
                        lll: "D MMM YYYY, H:mm",
                        LLLL: "dddd D MMMM [de] YYYY [a les] H:mm",
                        llll: "ddd D MMM YYYY, H:mm"
                    },
                    calendar: {
                        sameDay: function() {
                            return "[avui a " + (1 !== this.hours() ? "les" : "la") + "] LT";
                        },
                        nextDay: function() {
                            return "[dem a " + (1 !== this.hours() ? "les" : "la") + "] LT";
                        },
                        nextWeek: function() {
                            return "dddd [a " + (1 !== this.hours() ? "les" : "la") + "] LT";
                        },
                        lastDay: function() {
                            return "[ahir a " + (1 !== this.hours() ? "les" : "la") + "] LT";
                        },
                        lastWeek: function() {
                            return "[el] dddd [passat a " + (1 !== this.hours() ? "les" : "la") + "] LT";
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "d'aqu %s",
                        past: "fa %s",
                        s: "uns segons",
                        ss: "%d segons",
                        m: "un minut",
                        mm: "%d minuts",
                        h: "una hora",
                        hh: "%d hores",
                        d: "un dia",
                        dd: "%d dies",
                        M: "un mes",
                        MM: "%d mesos",
                        y: "un any",
                        yy: "%d anys"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
                    ordinal: function(number, period) {
                        var output = 1 === number ? "r" : 2 === number ? "n" : 3 === number ? "r" : 4 === number ? "t" : "";
                        if ("w" === period || "W" === period) output = "a";
                        return number + output;
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return ca;
            }));
        },
        5822: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var months = {
                    format: "leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec".split("_"),
                    standalone: "ledna_nora_bezna_dubna_kvtna_ervna_ervence_srpna_z_jna_listopadu_prosince".split("_")
                }, monthsShort = "led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro".split("_"), monthsParse = [ /^led/i, /^no/i, /^be/i, /^dub/i, /^kv/i, /^(vn|erven$|ervna)/i, /^(vc|ervenec|ervence)/i, /^srp/i, /^z/i, /^j/i, /^lis/i, /^pro/i ], monthsRegex = /^(leden|nor|bezen|duben|kvten|ervenec|ervence|erven|ervna|srpen|z|jen|listopad|prosinec|led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i;
                function plural(n) {
                    return n > 1 && n < 5 && 1 !== ~~(n / 10);
                }
                function translate(number, withoutSuffix, key, isFuture) {
                    var result = number + " ";
                    switch (key) {
                      case "s":
                        return withoutSuffix || isFuture ? "pr sekund" : "pr sekundami";

                      case "ss":
                        if (withoutSuffix || isFuture) return result + (plural(number) ? "sekundy" : "sekund"); else return result + "sekundami";

                      case "m":
                        return withoutSuffix ? "minuta" : isFuture ? "minutu" : "minutou";

                      case "mm":
                        if (withoutSuffix || isFuture) return result + (plural(number) ? "minuty" : "minut"); else return result + "minutami";

                      case "h":
                        return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";

                      case "hh":
                        if (withoutSuffix || isFuture) return result + (plural(number) ? "hodiny" : "hodin"); else return result + "hodinami";

                      case "d":
                        return withoutSuffix || isFuture ? "den" : "dnem";

                      case "dd":
                        if (withoutSuffix || isFuture) return result + (plural(number) ? "dny" : "dn"); else return result + "dny";

                      case "M":
                        return withoutSuffix || isFuture ? "msc" : "mscem";

                      case "MM":
                        if (withoutSuffix || isFuture) return result + (plural(number) ? "msce" : "msc"); else return result + "msci";

                      case "y":
                        return withoutSuffix || isFuture ? "rok" : "rokem";

                      case "yy":
                        if (withoutSuffix || isFuture) return result + (plural(number) ? "roky" : "let"); else return result + "lety";
                    }
                }
                var cs = moment.defineLocale("cs", {
                    months,
                    monthsShort,
                    monthsRegex,
                    monthsShortRegex: monthsRegex,
                    monthsStrictRegex: /^(leden|ledna|nora|nor|bezen|bezna|duben|dubna|kvten|kvtna|ervenec|ervence|erven|ervna|srpen|srpna|z|jen|jna|listopadu|listopad|prosinec|prosince)/i,
                    monthsShortStrictRegex: /^(led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i,
                    monthsParse,
                    longMonthsParse: monthsParse,
                    shortMonthsParse: monthsParse,
                    weekdays: "nedle_pondl_ter_steda_tvrtek_ptek_sobota".split("_"),
                    weekdaysShort: "ne_po_t_st_t_p_so".split("_"),
                    weekdaysMin: "ne_po_t_st_t_p_so".split("_"),
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D. MMMM YYYY",
                        LLL: "D. MMMM YYYY H:mm",
                        LLLL: "dddd D. MMMM YYYY H:mm",
                        l: "D. M. YYYY"
                    },
                    calendar: {
                        sameDay: "[dnes v] LT",
                        nextDay: "[ztra v] LT",
                        nextWeek: function() {
                            switch (this.day()) {
                              case 0:
                                return "[v nedli v] LT";

                              case 1:
                              case 2:
                                return "[v] dddd [v] LT";

                              case 3:
                                return "[ve stedu v] LT";

                              case 4:
                                return "[ve tvrtek v] LT";

                              case 5:
                                return "[v ptek v] LT";

                              case 6:
                                return "[v sobotu v] LT";
                            }
                        },
                        lastDay: "[vera v] LT",
                        lastWeek: function() {
                            switch (this.day()) {
                              case 0:
                                return "[minulou nedli v] LT";

                              case 1:
                              case 2:
                                return "[minul] dddd [v] LT";

                              case 3:
                                return "[minulou stedu v] LT";

                              case 4:
                              case 5:
                                return "[minul] dddd [v] LT";

                              case 6:
                                return "[minulou sobotu v] LT";
                            }
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "za %s",
                        past: "ped %s",
                        s: translate,
                        ss: translate,
                        m: translate,
                        mm: translate,
                        h: translate,
                        hh: translate,
                        d: translate,
                        dd: translate,
                        M: translate,
                        MM: translate,
                        y: translate,
                        yy: translate
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return cs;
            }));
        },
        877: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var cv = moment.defineLocale("cv", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD-MM-YYYY",
                        LL: "YYYY [] MMMM [] D[-]",
                        LLL: "YYYY [] MMMM [] D[-], HH:mm",
                        LLLL: "dddd, YYYY [] MMMM [] D[-], HH:mm"
                    },
                    calendar: {
                        sameDay: "[] LT []",
                        nextDay: "[] LT []",
                        lastDay: "[] LT []",
                        nextWeek: "[] dddd LT []",
                        lastWeek: "[] dddd LT []",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: function(output) {
                            var affix = /$/i.exec(output) ? "" : /$/i.exec(output) ? "" : "";
                            return output + affix;
                        },
                        past: "%s ",
                        s: "- ",
                        ss: "%d ",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}-/,
                    ordinal: "%d-",
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return cv;
            }));
        },
        7373: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var cy = moment.defineLocale("cy", {
                    months: "Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr".split("_"),
                    monthsShort: "Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag".split("_"),
                    weekdays: "Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn".split("_"),
                    weekdaysShort: "Sul_Llun_Maw_Mer_Iau_Gwe_Sad".split("_"),
                    weekdaysMin: "Su_Ll_Ma_Me_Ia_Gw_Sa".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[Heddiw am] LT",
                        nextDay: "[Yfory am] LT",
                        nextWeek: "dddd [am] LT",
                        lastDay: "[Ddoe am] LT",
                        lastWeek: "dddd [diwethaf am] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "mewn %s",
                        past: "%s yn l",
                        s: "ychydig eiliadau",
                        ss: "%d eiliad",
                        m: "munud",
                        mm: "%d munud",
                        h: "awr",
                        hh: "%d awr",
                        d: "diwrnod",
                        dd: "%d diwrnod",
                        M: "mis",
                        MM: "%d mis",
                        y: "blwyddyn",
                        yy: "%d flynedd"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
                    ordinal: function(number) {
                        var b = number, output = "", lookup = [ "", "af", "il", "ydd", "ydd", "ed", "ed", "ed", "fed", "fed", "fed", "eg", "fed", "eg", "eg", "fed", "eg", "eg", "fed", "eg", "fed" ];
                        if (b > 20) if (40 === b || 50 === b || 60 === b || 80 === b || 100 === b) output = "fed"; else output = "ain"; else if (b > 0) output = lookup[b];
                        return number + output;
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return cy;
            }));
        },
        4780: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var da = moment.defineLocale("da", {
                    months: "januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split("_"),
                    monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
                    weekdays: "sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag".split("_"),
                    weekdaysShort: "sn_man_tir_ons_tor_fre_lr".split("_"),
                    weekdaysMin: "s_ma_ti_on_to_fr_l".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D. MMMM YYYY",
                        LLL: "D. MMMM YYYY HH:mm",
                        LLLL: "dddd [d.] D. MMMM YYYY [kl.] HH:mm"
                    },
                    calendar: {
                        sameDay: "[i dag kl.] LT",
                        nextDay: "[i morgen kl.] LT",
                        nextWeek: "p dddd [kl.] LT",
                        lastDay: "[i gr kl.] LT",
                        lastWeek: "[i] dddd[s kl.] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "om %s",
                        past: "%s siden",
                        s: "f sekunder",
                        ss: "%d sekunder",
                        m: "et minut",
                        mm: "%d minutter",
                        h: "en time",
                        hh: "%d timer",
                        d: "en dag",
                        dd: "%d dage",
                        M: "en mned",
                        MM: "%d mneder",
                        y: "et r",
                        yy: "%d r"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return da;
            }));
        },
        217: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                function processRelativeTime(number, withoutSuffix, key, isFuture) {
                    var format = {
                        m: [ "eine Minute", "einer Minute" ],
                        h: [ "eine Stunde", "einer Stunde" ],
                        d: [ "ein Tag", "einem Tag" ],
                        dd: [ number + " Tage", number + " Tagen" ],
                        w: [ "eine Woche", "einer Woche" ],
                        M: [ "ein Monat", "einem Monat" ],
                        MM: [ number + " Monate", number + " Monaten" ],
                        y: [ "ein Jahr", "einem Jahr" ],
                        yy: [ number + " Jahre", number + " Jahren" ]
                    };
                    return withoutSuffix ? format[key][0] : format[key][1];
                }
                var deAt = moment.defineLocale("de-at", {
                    months: "Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
                    monthsShort: "Jn._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
                    monthsParseExact: true,
                    weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
                    weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
                    weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D. MMMM YYYY",
                        LLL: "D. MMMM YYYY HH:mm",
                        LLLL: "dddd, D. MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[heute um] LT [Uhr]",
                        sameElse: "L",
                        nextDay: "[morgen um] LT [Uhr]",
                        nextWeek: "dddd [um] LT [Uhr]",
                        lastDay: "[gestern um] LT [Uhr]",
                        lastWeek: "[letzten] dddd [um] LT [Uhr]"
                    },
                    relativeTime: {
                        future: "in %s",
                        past: "vor %s",
                        s: "ein paar Sekunden",
                        ss: "%d Sekunden",
                        m: processRelativeTime,
                        mm: "%d Minuten",
                        h: processRelativeTime,
                        hh: "%d Stunden",
                        d: processRelativeTime,
                        dd: processRelativeTime,
                        w: processRelativeTime,
                        ww: "%d Wochen",
                        M: processRelativeTime,
                        MM: processRelativeTime,
                        y: processRelativeTime,
                        yy: processRelativeTime
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return deAt;
            }));
        },
        894: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                function processRelativeTime(number, withoutSuffix, key, isFuture) {
                    var format = {
                        m: [ "eine Minute", "einer Minute" ],
                        h: [ "eine Stunde", "einer Stunde" ],
                        d: [ "ein Tag", "einem Tag" ],
                        dd: [ number + " Tage", number + " Tagen" ],
                        w: [ "eine Woche", "einer Woche" ],
                        M: [ "ein Monat", "einem Monat" ],
                        MM: [ number + " Monate", number + " Monaten" ],
                        y: [ "ein Jahr", "einem Jahr" ],
                        yy: [ number + " Jahre", number + " Jahren" ]
                    };
                    return withoutSuffix ? format[key][0] : format[key][1];
                }
                var deCh = moment.defineLocale("de-ch", {
                    months: "Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
                    monthsShort: "Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
                    monthsParseExact: true,
                    weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
                    weekdaysShort: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
                    weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D. MMMM YYYY",
                        LLL: "D. MMMM YYYY HH:mm",
                        LLLL: "dddd, D. MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[heute um] LT [Uhr]",
                        sameElse: "L",
                        nextDay: "[morgen um] LT [Uhr]",
                        nextWeek: "dddd [um] LT [Uhr]",
                        lastDay: "[gestern um] LT [Uhr]",
                        lastWeek: "[letzten] dddd [um] LT [Uhr]"
                    },
                    relativeTime: {
                        future: "in %s",
                        past: "vor %s",
                        s: "ein paar Sekunden",
                        ss: "%d Sekunden",
                        m: processRelativeTime,
                        mm: "%d Minuten",
                        h: processRelativeTime,
                        hh: "%d Stunden",
                        d: processRelativeTime,
                        dd: processRelativeTime,
                        w: processRelativeTime,
                        ww: "%d Wochen",
                        M: processRelativeTime,
                        MM: processRelativeTime,
                        y: processRelativeTime,
                        yy: processRelativeTime
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return deCh;
            }));
        },
        9740: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                function processRelativeTime(number, withoutSuffix, key, isFuture) {
                    var format = {
                        m: [ "eine Minute", "einer Minute" ],
                        h: [ "eine Stunde", "einer Stunde" ],
                        d: [ "ein Tag", "einem Tag" ],
                        dd: [ number + " Tage", number + " Tagen" ],
                        w: [ "eine Woche", "einer Woche" ],
                        M: [ "ein Monat", "einem Monat" ],
                        MM: [ number + " Monate", number + " Monaten" ],
                        y: [ "ein Jahr", "einem Jahr" ],
                        yy: [ number + " Jahre", number + " Jahren" ]
                    };
                    return withoutSuffix ? format[key][0] : format[key][1];
                }
                var de = moment.defineLocale("de", {
                    months: "Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
                    monthsShort: "Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
                    monthsParseExact: true,
                    weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
                    weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
                    weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D. MMMM YYYY",
                        LLL: "D. MMMM YYYY HH:mm",
                        LLLL: "dddd, D. MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[heute um] LT [Uhr]",
                        sameElse: "L",
                        nextDay: "[morgen um] LT [Uhr]",
                        nextWeek: "dddd [um] LT [Uhr]",
                        lastDay: "[gestern um] LT [Uhr]",
                        lastWeek: "[letzten] dddd [um] LT [Uhr]"
                    },
                    relativeTime: {
                        future: "in %s",
                        past: "vor %s",
                        s: "ein paar Sekunden",
                        ss: "%d Sekunden",
                        m: processRelativeTime,
                        mm: "%d Minuten",
                        h: processRelativeTime,
                        hh: "%d Stunden",
                        d: processRelativeTime,
                        dd: processRelativeTime,
                        w: processRelativeTime,
                        ww: "%d Wochen",
                        M: processRelativeTime,
                        MM: processRelativeTime,
                        y: processRelativeTime,
                        yy: processRelativeTime
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return de;
            }));
        },
        5300: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var months = [ "", "", "", "", "", "", "", "", "", "", "", "" ], weekdays = [ "", "", "", "", "", "", "" ];
                var dv = moment.defineLocale("dv", {
                    months,
                    monthsShort: months,
                    weekdays,
                    weekdaysShort: weekdays,
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "D/M/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    meridiemParse: /|/,
                    isPM: function(input) {
                        return "" === input;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 12) return ""; else return "";
                    },
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        nextWeek: "dddd LT",
                        lastDay: "[] LT",
                        lastWeek: "[] dddd LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s",
                        past: " %s",
                        s: "",
                        ss: "d% ",
                        m: "",
                        mm: " %d",
                        h: "",
                        hh: " %d",
                        d: "",
                        dd: " %d",
                        M: "",
                        MM: " %d",
                        y: "",
                        yy: " %d"
                    },
                    preparse: function(string) {
                        return string.replace(//g, ",");
                    },
                    postformat: function(string) {
                        return string.replace(/,/g, "");
                    },
                    week: {
                        dow: 7,
                        doy: 12
                    }
                });
                return dv;
            }));
        },
        837: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                function isFunction(input) {
                    return "undefined" !== typeof Function && input instanceof Function || "[object Function]" === Object.prototype.toString.call(input);
                }
                var el = moment.defineLocale("el", {
                    monthsNominativeEl: "___________".split("_"),
                    monthsGenitiveEl: "___________".split("_"),
                    months: function(momentToFormat, format) {
                        if (!momentToFormat) return this._monthsNominativeEl; else if ("string" === typeof format && /D/.test(format.substring(0, format.indexOf("MMMM")))) return this._monthsGenitiveEl[momentToFormat.month()]; else return this._monthsNominativeEl[momentToFormat.month()];
                    },
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    meridiem: function(hours, minutes, isLower) {
                        if (hours > 11) return isLower ? "" : ""; else return isLower ? "" : "";
                    },
                    isPM: function(input) {
                        return "" === (input + "").toLowerCase()[0];
                    },
                    meridiemParse: /[]\.??\.?/i,
                    longDateFormat: {
                        LT: "h:mm A",
                        LTS: "h:mm:ss A",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY h:mm A",
                        LLLL: "dddd, D MMMM YYYY h:mm A"
                    },
                    calendarEl: {
                        sameDay: "[ {}] LT",
                        nextDay: "[ {}] LT",
                        nextWeek: "dddd [{}] LT",
                        lastDay: "[ {}] LT",
                        lastWeek: function() {
                            switch (this.day()) {
                              case 6:
                                return "[ ] dddd [{}] LT";

                              default:
                                return "[ ] dddd [{}] LT";
                            }
                        },
                        sameElse: "L"
                    },
                    calendar: function(key, mom) {
                        var output = this._calendarEl[key], hours = mom && mom.hours();
                        if (isFunction(output)) output = output.apply(mom);
                        return output.replace("{}", hours % 12 === 1 ? "" : "");
                    },
                    relativeTime: {
                        future: " %s",
                        past: "%s ",
                        s: " ",
                        ss: "%d ",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: "%d",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return el;
            }));
        },
        8348: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var enAu = moment.defineLocale("en-au", {
                    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                    monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                    weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                    weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                    weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                    longDateFormat: {
                        LT: "h:mm A",
                        LTS: "h:mm:ss A",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY h:mm A",
                        LLLL: "dddd, D MMMM YYYY h:mm A"
                    },
                    calendar: {
                        sameDay: "[Today at] LT",
                        nextDay: "[Tomorrow at] LT",
                        nextWeek: "dddd [at] LT",
                        lastDay: "[Yesterday at] LT",
                        lastWeek: "[Last] dddd [at] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "in %s",
                        past: "%s ago",
                        s: "a few seconds",
                        ss: "%d seconds",
                        m: "a minute",
                        mm: "%d minutes",
                        h: "an hour",
                        hh: "%d hours",
                        d: "a day",
                        dd: "%d days",
                        M: "a month",
                        MM: "%d months",
                        y: "a year",
                        yy: "%d years"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
                    ordinal: function(number) {
                        var b = number % 10, output = 1 === ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th";
                        return number + output;
                    },
                    week: {
                        dow: 0,
                        doy: 4
                    }
                });
                return enAu;
            }));
        },
        7925: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var enCa = moment.defineLocale("en-ca", {
                    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                    monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                    weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                    weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                    weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                    longDateFormat: {
                        LT: "h:mm A",
                        LTS: "h:mm:ss A",
                        L: "YYYY-MM-DD",
                        LL: "MMMM D, YYYY",
                        LLL: "MMMM D, YYYY h:mm A",
                        LLLL: "dddd, MMMM D, YYYY h:mm A"
                    },
                    calendar: {
                        sameDay: "[Today at] LT",
                        nextDay: "[Tomorrow at] LT",
                        nextWeek: "dddd [at] LT",
                        lastDay: "[Yesterday at] LT",
                        lastWeek: "[Last] dddd [at] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "in %s",
                        past: "%s ago",
                        s: "a few seconds",
                        ss: "%d seconds",
                        m: "a minute",
                        mm: "%d minutes",
                        h: "an hour",
                        hh: "%d hours",
                        d: "a day",
                        dd: "%d days",
                        M: "a month",
                        MM: "%d months",
                        y: "a year",
                        yy: "%d years"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
                    ordinal: function(number) {
                        var b = number % 10, output = 1 === ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th";
                        return number + output;
                    }
                });
                return enCa;
            }));
        },
        2243: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var enGb = moment.defineLocale("en-gb", {
                    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                    monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                    weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                    weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                    weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[Today at] LT",
                        nextDay: "[Tomorrow at] LT",
                        nextWeek: "dddd [at] LT",
                        lastDay: "[Yesterday at] LT",
                        lastWeek: "[Last] dddd [at] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "in %s",
                        past: "%s ago",
                        s: "a few seconds",
                        ss: "%d seconds",
                        m: "a minute",
                        mm: "%d minutes",
                        h: "an hour",
                        hh: "%d hours",
                        d: "a day",
                        dd: "%d days",
                        M: "a month",
                        MM: "%d months",
                        y: "a year",
                        yy: "%d years"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
                    ordinal: function(number) {
                        var b = number % 10, output = 1 === ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th";
                        return number + output;
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return enGb;
            }));
        },
        6436: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var enIe = moment.defineLocale("en-ie", {
                    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                    monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                    weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                    weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                    weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[Today at] LT",
                        nextDay: "[Tomorrow at] LT",
                        nextWeek: "dddd [at] LT",
                        lastDay: "[Yesterday at] LT",
                        lastWeek: "[Last] dddd [at] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "in %s",
                        past: "%s ago",
                        s: "a few seconds",
                        ss: "%d seconds",
                        m: "a minute",
                        mm: "%d minutes",
                        h: "an hour",
                        hh: "%d hours",
                        d: "a day",
                        dd: "%d days",
                        M: "a month",
                        MM: "%d months",
                        y: "a year",
                        yy: "%d years"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
                    ordinal: function(number) {
                        var b = number % 10, output = 1 === ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th";
                        return number + output;
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return enIe;
            }));
        },
        7207: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var enIl = moment.defineLocale("en-il", {
                    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                    monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                    weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                    weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                    weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[Today at] LT",
                        nextDay: "[Tomorrow at] LT",
                        nextWeek: "dddd [at] LT",
                        lastDay: "[Yesterday at] LT",
                        lastWeek: "[Last] dddd [at] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "in %s",
                        past: "%s ago",
                        s: "a few seconds",
                        ss: "%d seconds",
                        m: "a minute",
                        mm: "%d minutes",
                        h: "an hour",
                        hh: "%d hours",
                        d: "a day",
                        dd: "%d days",
                        M: "a month",
                        MM: "%d months",
                        y: "a year",
                        yy: "%d years"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
                    ordinal: function(number) {
                        var b = number % 10, output = 1 === ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th";
                        return number + output;
                    }
                });
                return enIl;
            }));
        },
        4175: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var enIn = moment.defineLocale("en-in", {
                    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                    monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                    weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                    weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                    weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                    longDateFormat: {
                        LT: "h:mm A",
                        LTS: "h:mm:ss A",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY h:mm A",
                        LLLL: "dddd, D MMMM YYYY h:mm A"
                    },
                    calendar: {
                        sameDay: "[Today at] LT",
                        nextDay: "[Tomorrow at] LT",
                        nextWeek: "dddd [at] LT",
                        lastDay: "[Yesterday at] LT",
                        lastWeek: "[Last] dddd [at] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "in %s",
                        past: "%s ago",
                        s: "a few seconds",
                        ss: "%d seconds",
                        m: "a minute",
                        mm: "%d minutes",
                        h: "an hour",
                        hh: "%d hours",
                        d: "a day",
                        dd: "%d days",
                        M: "a month",
                        MM: "%d months",
                        y: "a year",
                        yy: "%d years"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
                    ordinal: function(number) {
                        var b = number % 10, output = 1 === ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th";
                        return number + output;
                    },
                    week: {
                        dow: 0,
                        doy: 6
                    }
                });
                return enIn;
            }));
        },
        6319: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var enNz = moment.defineLocale("en-nz", {
                    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                    monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                    weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                    weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                    weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                    longDateFormat: {
                        LT: "h:mm A",
                        LTS: "h:mm:ss A",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY h:mm A",
                        LLLL: "dddd, D MMMM YYYY h:mm A"
                    },
                    calendar: {
                        sameDay: "[Today at] LT",
                        nextDay: "[Tomorrow at] LT",
                        nextWeek: "dddd [at] LT",
                        lastDay: "[Yesterday at] LT",
                        lastWeek: "[Last] dddd [at] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "in %s",
                        past: "%s ago",
                        s: "a few seconds",
                        ss: "%d seconds",
                        m: "a minute",
                        mm: "%d minutes",
                        h: "an hour",
                        hh: "%d hours",
                        d: "a day",
                        dd: "%d days",
                        M: "a month",
                        MM: "%d months",
                        y: "a year",
                        yy: "%d years"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
                    ordinal: function(number) {
                        var b = number % 10, output = 1 === ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th";
                        return number + output;
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return enNz;
            }));
        },
        1662: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var enSg = moment.defineLocale("en-sg", {
                    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                    monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                    weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                    weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                    weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[Today at] LT",
                        nextDay: "[Tomorrow at] LT",
                        nextWeek: "dddd [at] LT",
                        lastDay: "[Yesterday at] LT",
                        lastWeek: "[Last] dddd [at] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "in %s",
                        past: "%s ago",
                        s: "a few seconds",
                        ss: "%d seconds",
                        m: "a minute",
                        mm: "%d minutes",
                        h: "an hour",
                        hh: "%d hours",
                        d: "a day",
                        dd: "%d days",
                        M: "a month",
                        MM: "%d months",
                        y: "a year",
                        yy: "%d years"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
                    ordinal: function(number) {
                        var b = number % 10, output = 1 === ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th";
                        return number + output;
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return enSg;
            }));
        },
        2915: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var eo = moment.defineLocale("eo", {
                    months: "januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro".split("_"),
                    monthsShort: "jan_feb_mart_apr_maj_jun_jul_ag_sept_okt_nov_dec".split("_"),
                    weekdays: "dimano_lundo_mardo_merkredo_ado_vendredo_sabato".split("_"),
                    weekdaysShort: "dim_lun_mard_merk_a_ven_sab".split("_"),
                    weekdaysMin: "di_lu_ma_me_a_ve_sa".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "YYYY-MM-DD",
                        LL: "[la] D[-an de] MMMM, YYYY",
                        LLL: "[la] D[-an de] MMMM, YYYY HH:mm",
                        LLLL: "dddd[n], [la] D[-an de] MMMM, YYYY HH:mm",
                        llll: "ddd, [la] D[-an de] MMM, YYYY HH:mm"
                    },
                    meridiemParse: /[ap]\.t\.m/i,
                    isPM: function(input) {
                        return "p" === input.charAt(0).toLowerCase();
                    },
                    meridiem: function(hours, minutes, isLower) {
                        if (hours > 11) return isLower ? "p.t.m." : "P.T.M."; else return isLower ? "a.t.m." : "A.T.M.";
                    },
                    calendar: {
                        sameDay: "[Hodia je] LT",
                        nextDay: "[Morga je] LT",
                        nextWeek: "dddd[n je] LT",
                        lastDay: "[Hiera je] LT",
                        lastWeek: "[pasintan] dddd[n je] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "post %s",
                        past: "anta %s",
                        s: "kelkaj sekundoj",
                        ss: "%d sekundoj",
                        m: "unu minuto",
                        mm: "%d minutoj",
                        h: "unu horo",
                        hh: "%d horoj",
                        d: "unu tago",
                        dd: "%d tagoj",
                        M: "unu monato",
                        MM: "%d monatoj",
                        y: "unu jaro",
                        yy: "%d jaroj"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}a/,
                    ordinal: "%da",
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return eo;
            }));
        },
        5251: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), monthsShort = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse = [ /^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i ], monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
                var esDo = moment.defineLocale("es-do", {
                    months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
                    monthsShort: function(m, format) {
                        if (!m) return monthsShortDot; else if (/-MMM-/.test(format)) return monthsShort[m.month()]; else return monthsShortDot[m.month()];
                    },
                    monthsRegex,
                    monthsShortRegex: monthsRegex,
                    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
                    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
                    monthsParse,
                    longMonthsParse: monthsParse,
                    shortMonthsParse: monthsParse,
                    weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"),
                    weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"),
                    weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "h:mm A",
                        LTS: "h:mm:ss A",
                        L: "DD/MM/YYYY",
                        LL: "D [de] MMMM [de] YYYY",
                        LLL: "D [de] MMMM [de] YYYY h:mm A",
                        LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A"
                    },
                    calendar: {
                        sameDay: function() {
                            return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        nextDay: function() {
                            return "[maana a la" + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        nextWeek: function() {
                            return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        lastDay: function() {
                            return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        lastWeek: function() {
                            return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "en %s",
                        past: "hace %s",
                        s: "unos segundos",
                        ss: "%d segundos",
                        m: "un minuto",
                        mm: "%d minutos",
                        h: "una hora",
                        hh: "%d horas",
                        d: "un da",
                        dd: "%d das",
                        w: "una semana",
                        ww: "%d semanas",
                        M: "un mes",
                        MM: "%d meses",
                        y: "un ao",
                        yy: "%d aos"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: "%d",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return esDo;
            }));
        },
        6112: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), monthsShort = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse = [ /^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i ], monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
                var esMx = moment.defineLocale("es-mx", {
                    months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
                    monthsShort: function(m, format) {
                        if (!m) return monthsShortDot; else if (/-MMM-/.test(format)) return monthsShort[m.month()]; else return monthsShortDot[m.month()];
                    },
                    monthsRegex,
                    monthsShortRegex: monthsRegex,
                    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
                    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
                    monthsParse,
                    longMonthsParse: monthsParse,
                    shortMonthsParse: monthsParse,
                    weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"),
                    weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"),
                    weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D [de] MMMM [de] YYYY",
                        LLL: "D [de] MMMM [de] YYYY H:mm",
                        LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
                    },
                    calendar: {
                        sameDay: function() {
                            return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        nextDay: function() {
                            return "[maana a la" + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        nextWeek: function() {
                            return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        lastDay: function() {
                            return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        lastWeek: function() {
                            return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "en %s",
                        past: "hace %s",
                        s: "unos segundos",
                        ss: "%d segundos",
                        m: "un minuto",
                        mm: "%d minutos",
                        h: "una hora",
                        hh: "%d horas",
                        d: "un da",
                        dd: "%d das",
                        w: "una semana",
                        ww: "%d semanas",
                        M: "un mes",
                        MM: "%d meses",
                        y: "un ao",
                        yy: "%d aos"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: "%d",
                    week: {
                        dow: 0,
                        doy: 4
                    },
                    invalidDate: "Fecha invlida"
                });
                return esMx;
            }));
        },
        1146: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), monthsShort = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse = [ /^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i ], monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
                var esUs = moment.defineLocale("es-us", {
                    months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
                    monthsShort: function(m, format) {
                        if (!m) return monthsShortDot; else if (/-MMM-/.test(format)) return monthsShort[m.month()]; else return monthsShortDot[m.month()];
                    },
                    monthsRegex,
                    monthsShortRegex: monthsRegex,
                    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
                    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
                    monthsParse,
                    longMonthsParse: monthsParse,
                    shortMonthsParse: monthsParse,
                    weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"),
                    weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"),
                    weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "h:mm A",
                        LTS: "h:mm:ss A",
                        L: "MM/DD/YYYY",
                        LL: "D [de] MMMM [de] YYYY",
                        LLL: "D [de] MMMM [de] YYYY h:mm A",
                        LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A"
                    },
                    calendar: {
                        sameDay: function() {
                            return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        nextDay: function() {
                            return "[maana a la" + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        nextWeek: function() {
                            return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        lastDay: function() {
                            return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        lastWeek: function() {
                            return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "en %s",
                        past: "hace %s",
                        s: "unos segundos",
                        ss: "%d segundos",
                        m: "un minuto",
                        mm: "%d minutos",
                        h: "una hora",
                        hh: "%d horas",
                        d: "un da",
                        dd: "%d das",
                        w: "una semana",
                        ww: "%d semanas",
                        M: "un mes",
                        MM: "%d meses",
                        y: "un ao",
                        yy: "%d aos"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: "%d",
                    week: {
                        dow: 0,
                        doy: 6
                    }
                });
                return esUs;
            }));
        },
        5655: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), monthsShort = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse = [ /^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i ], monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
                var es = moment.defineLocale("es", {
                    months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
                    monthsShort: function(m, format) {
                        if (!m) return monthsShortDot; else if (/-MMM-/.test(format)) return monthsShort[m.month()]; else return monthsShortDot[m.month()];
                    },
                    monthsRegex,
                    monthsShortRegex: monthsRegex,
                    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
                    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
                    monthsParse,
                    longMonthsParse: monthsParse,
                    shortMonthsParse: monthsParse,
                    weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"),
                    weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"),
                    weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D [de] MMMM [de] YYYY",
                        LLL: "D [de] MMMM [de] YYYY H:mm",
                        LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
                    },
                    calendar: {
                        sameDay: function() {
                            return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        nextDay: function() {
                            return "[maana a la" + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        nextWeek: function() {
                            return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        lastDay: function() {
                            return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        lastWeek: function() {
                            return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "en %s",
                        past: "hace %s",
                        s: "unos segundos",
                        ss: "%d segundos",
                        m: "un minuto",
                        mm: "%d minutos",
                        h: "una hora",
                        hh: "%d horas",
                        d: "un da",
                        dd: "%d das",
                        w: "una semana",
                        ww: "%d semanas",
                        M: "un mes",
                        MM: "%d meses",
                        y: "un ao",
                        yy: "%d aos"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: "%d",
                    week: {
                        dow: 1,
                        doy: 4
                    },
                    invalidDate: "Fecha invlida"
                });
                return es;
            }));
        },
        5603: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                function processRelativeTime(number, withoutSuffix, key, isFuture) {
                    var format = {
                        s: [ "mne sekundi", "mni sekund", "paar sekundit" ],
                        ss: [ number + "sekundi", number + "sekundit" ],
                        m: [ "he minuti", "ks minut" ],
                        mm: [ number + " minuti", number + " minutit" ],
                        h: [ "he tunni", "tund aega", "ks tund" ],
                        hh: [ number + " tunni", number + " tundi" ],
                        d: [ "he peva", "ks pev" ],
                        M: [ "kuu aja", "kuu aega", "ks kuu" ],
                        MM: [ number + " kuu", number + " kuud" ],
                        y: [ "he aasta", "aasta", "ks aasta" ],
                        yy: [ number + " aasta", number + " aastat" ]
                    };
                    if (withoutSuffix) return format[key][2] ? format[key][2] : format[key][1];
                    return isFuture ? format[key][0] : format[key][1];
                }
                var et = moment.defineLocale("et", {
                    months: "jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember".split("_"),
                    monthsShort: "jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets".split("_"),
                    weekdays: "phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev".split("_"),
                    weekdaysShort: "P_E_T_K_N_R_L".split("_"),
                    weekdaysMin: "P_E_T_K_N_R_L".split("_"),
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D. MMMM YYYY",
                        LLL: "D. MMMM YYYY H:mm",
                        LLLL: "dddd, D. MMMM YYYY H:mm"
                    },
                    calendar: {
                        sameDay: "[Tna,] LT",
                        nextDay: "[Homme,] LT",
                        nextWeek: "[Jrgmine] dddd LT",
                        lastDay: "[Eile,] LT",
                        lastWeek: "[Eelmine] dddd LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s prast",
                        past: "%s tagasi",
                        s: processRelativeTime,
                        ss: processRelativeTime,
                        m: processRelativeTime,
                        mm: processRelativeTime,
                        h: processRelativeTime,
                        hh: processRelativeTime,
                        d: processRelativeTime,
                        dd: "%d peva",
                        M: processRelativeTime,
                        MM: processRelativeTime,
                        y: processRelativeTime,
                        yy: processRelativeTime
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return et;
            }));
        },
        7763: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var eu = moment.defineLocale("eu", {
                    months: "urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split("_"),
                    monthsShort: "urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split("_"),
                    monthsParseExact: true,
                    weekdays: "igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split("_"),
                    weekdaysShort: "ig._al._ar._az._og._ol._lr.".split("_"),
                    weekdaysMin: "ig_al_ar_az_og_ol_lr".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "YYYY-MM-DD",
                        LL: "YYYY[ko] MMMM[ren] D[a]",
                        LLL: "YYYY[ko] MMMM[ren] D[a] HH:mm",
                        LLLL: "dddd, YYYY[ko] MMMM[ren] D[a] HH:mm",
                        l: "YYYY-M-D",
                        ll: "YYYY[ko] MMM D[a]",
                        lll: "YYYY[ko] MMM D[a] HH:mm",
                        llll: "ddd, YYYY[ko] MMM D[a] HH:mm"
                    },
                    calendar: {
                        sameDay: "[gaur] LT[etan]",
                        nextDay: "[bihar] LT[etan]",
                        nextWeek: "dddd LT[etan]",
                        lastDay: "[atzo] LT[etan]",
                        lastWeek: "[aurreko] dddd LT[etan]",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s barru",
                        past: "duela %s",
                        s: "segundo batzuk",
                        ss: "%d segundo",
                        m: "minutu bat",
                        mm: "%d minutu",
                        h: "ordu bat",
                        hh: "%d ordu",
                        d: "egun bat",
                        dd: "%d egun",
                        M: "hilabete bat",
                        MM: "%d hilabete",
                        y: "urte bat",
                        yy: "%d urte"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return eu;
            }));
        },
        6959: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var symbolMap = {
                    1: "",
                    2: "",
                    3: "",
                    4: "",
                    5: "",
                    6: "",
                    7: "",
                    8: "",
                    9: "",
                    0: ""
                }, numberMap = {
                    "": "1",
                    "": "2",
                    "": "3",
                    "": "4",
                    "": "5",
                    "": "6",
                    "": "7",
                    "": "8",
                    "": "9",
                    "": "0"
                };
                var fa = moment.defineLocale("fa", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    meridiemParse: /  |  /,
                    isPM: function(input) {
                        return /  /.test(input);
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 12) return "  "; else return "  ";
                    },
                    calendar: {
                        sameDay: "[ ] LT",
                        nextDay: "[ ] LT",
                        nextWeek: "dddd [] LT",
                        lastDay: "[ ] LT",
                        lastWeek: "dddd [] [] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s",
                        past: "%s ",
                        s: " ",
                        ss: "%d ",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    preparse: function(string) {
                        return string.replace(/[-]/g, (function(match) {
                            return numberMap[match];
                        })).replace(//g, ",");
                    },
                    postformat: function(string) {
                        return string.replace(/\d/g, (function(match) {
                            return symbolMap[match];
                        })).replace(/,/g, "");
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: "%d",
                    week: {
                        dow: 6,
                        doy: 12
                    }
                });
                return fa;
            }));
        },
        1897: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var numbersPast = "nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn".split(" "), numbersFuture = [ "nolla", "yhden", "kahden", "kolmen", "neljn", "viiden", "kuuden", numbersPast[7], numbersPast[8], numbersPast[9] ];
                function translate(number, withoutSuffix, key, isFuture) {
                    var result = "";
                    switch (key) {
                      case "s":
                        return isFuture ? "muutaman sekunnin" : "muutama sekunti";

                      case "ss":
                        result = isFuture ? "sekunnin" : "sekuntia";
                        break;

                      case "m":
                        return isFuture ? "minuutin" : "minuutti";

                      case "mm":
                        result = isFuture ? "minuutin" : "minuuttia";
                        break;

                      case "h":
                        return isFuture ? "tunnin" : "tunti";

                      case "hh":
                        result = isFuture ? "tunnin" : "tuntia";
                        break;

                      case "d":
                        return isFuture ? "pivn" : "piv";

                      case "dd":
                        result = isFuture ? "pivn" : "piv";
                        break;

                      case "M":
                        return isFuture ? "kuukauden" : "kuukausi";

                      case "MM":
                        result = isFuture ? "kuukauden" : "kuukautta";
                        break;

                      case "y":
                        return isFuture ? "vuoden" : "vuosi";

                      case "yy":
                        result = isFuture ? "vuoden" : "vuotta";
                        break;
                    }
                    result = verbalNumber(number, isFuture) + " " + result;
                    return result;
                }
                function verbalNumber(number, isFuture) {
                    return number < 10 ? isFuture ? numbersFuture[number] : numbersPast[number] : number;
                }
                var fi = moment.defineLocale("fi", {
                    months: "tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split("_"),
                    monthsShort: "tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu".split("_"),
                    weekdays: "sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split("_"),
                    weekdaysShort: "su_ma_ti_ke_to_pe_la".split("_"),
                    weekdaysMin: "su_ma_ti_ke_to_pe_la".split("_"),
                    longDateFormat: {
                        LT: "HH.mm",
                        LTS: "HH.mm.ss",
                        L: "DD.MM.YYYY",
                        LL: "Do MMMM[ta] YYYY",
                        LLL: "Do MMMM[ta] YYYY, [klo] HH.mm",
                        LLLL: "dddd, Do MMMM[ta] YYYY, [klo] HH.mm",
                        l: "D.M.YYYY",
                        ll: "Do MMM YYYY",
                        lll: "Do MMM YYYY, [klo] HH.mm",
                        llll: "ddd, Do MMM YYYY, [klo] HH.mm"
                    },
                    calendar: {
                        sameDay: "[tnn] [klo] LT",
                        nextDay: "[huomenna] [klo] LT",
                        nextWeek: "dddd [klo] LT",
                        lastDay: "[eilen] [klo] LT",
                        lastWeek: "[viime] dddd[na] [klo] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s pst",
                        past: "%s sitten",
                        s: translate,
                        ss: translate,
                        m: translate,
                        mm: translate,
                        h: translate,
                        hh: translate,
                        d: translate,
                        dd: translate,
                        M: translate,
                        MM: translate,
                        y: translate,
                        yy: translate
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return fi;
            }));
        },
        2549: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var fil = moment.defineLocale("fil", {
                    months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"),
                    monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),
                    weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"),
                    weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),
                    weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "MM/D/YYYY",
                        LL: "MMMM D, YYYY",
                        LLL: "MMMM D, YYYY HH:mm",
                        LLLL: "dddd, MMMM DD, YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "LT [ngayong araw]",
                        nextDay: "[Bukas ng] LT",
                        nextWeek: "LT [sa susunod na] dddd",
                        lastDay: "LT [kahapon]",
                        lastWeek: "LT [noong nakaraang] dddd",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "sa loob ng %s",
                        past: "%s ang nakalipas",
                        s: "ilang segundo",
                        ss: "%d segundo",
                        m: "isang minuto",
                        mm: "%d minuto",
                        h: "isang oras",
                        hh: "%d oras",
                        d: "isang araw",
                        dd: "%d araw",
                        M: "isang buwan",
                        MM: "%d buwan",
                        y: "isang taon",
                        yy: "%d taon"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: function(number) {
                        return number;
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return fil;
            }));
        },
        4694: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var fo = moment.defineLocale("fo", {
                    months: "januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember".split("_"),
                    monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),
                    weekdays: "sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur".split("_"),
                    weekdaysShort: "sun_mn_ts_mik_hs_fr_ley".split("_"),
                    weekdaysMin: "su_m_t_mi_h_fr_le".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D. MMMM, YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[ dag kl.] LT",
                        nextDay: "[ morgin kl.] LT",
                        nextWeek: "dddd [kl.] LT",
                        lastDay: "[ gjr kl.] LT",
                        lastWeek: "[sstu] dddd [kl] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "um %s",
                        past: "%s sani",
                        s: "f sekund",
                        ss: "%d sekundir",
                        m: "ein minuttur",
                        mm: "%d minuttir",
                        h: "ein tmi",
                        hh: "%d tmar",
                        d: "ein dagur",
                        dd: "%d dagar",
                        M: "ein mnaur",
                        MM: "%d mnair",
                        y: "eitt r",
                        yy: "%d r"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return fo;
            }));
        },
        3049: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var frCa = moment.defineLocale("fr-ca", {
                    months: "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split("_"),
                    monthsShort: "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split("_"),
                    monthsParseExact: true,
                    weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
                    weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
                    weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "YYYY-MM-DD",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[Aujourdhui ] LT",
                        nextDay: "[Demain ] LT",
                        nextWeek: "dddd [] LT",
                        lastDay: "[Hier ] LT",
                        lastWeek: "dddd [dernier ] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "dans %s",
                        past: "il y a %s",
                        s: "quelques secondes",
                        ss: "%d secondes",
                        m: "une minute",
                        mm: "%d minutes",
                        h: "une heure",
                        hh: "%d heures",
                        d: "un jour",
                        dd: "%d jours",
                        M: "un mois",
                        MM: "%d mois",
                        y: "un an",
                        yy: "%d ans"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
                    ordinal: function(number, period) {
                        switch (period) {
                          default:
                          case "M":
                          case "Q":
                          case "D":
                          case "DDD":
                          case "d":
                            return number + (1 === number ? "er" : "e");

                          case "w":
                          case "W":
                            return number + (1 === number ? "re" : "e");
                        }
                    }
                });
                return frCa;
            }));
        },
        2330: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var frCh = moment.defineLocale("fr-ch", {
                    months: "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split("_"),
                    monthsShort: "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split("_"),
                    monthsParseExact: true,
                    weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
                    weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
                    weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[Aujourdhui ] LT",
                        nextDay: "[Demain ] LT",
                        nextWeek: "dddd [] LT",
                        lastDay: "[Hier ] LT",
                        lastWeek: "dddd [dernier ] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "dans %s",
                        past: "il y a %s",
                        s: "quelques secondes",
                        ss: "%d secondes",
                        m: "une minute",
                        mm: "%d minutes",
                        h: "une heure",
                        hh: "%d heures",
                        d: "un jour",
                        dd: "%d jours",
                        M: "un mois",
                        MM: "%d mois",
                        y: "un an",
                        yy: "%d ans"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
                    ordinal: function(number, period) {
                        switch (period) {
                          default:
                          case "M":
                          case "Q":
                          case "D":
                          case "DDD":
                          case "d":
                            return number + (1 === number ? "er" : "e");

                          case "w":
                          case "W":
                            return number + (1 === number ? "re" : "e");
                        }
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return frCh;
            }));
        },
        4470: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var monthsStrictRegex = /^(janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i, monthsShortStrictRegex = /(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?)/i, monthsRegex = /(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?|janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i, monthsParse = [ /^janv/i, /^fvr/i, /^mars/i, /^avr/i, /^mai/i, /^juin/i, /^juil/i, /^aot/i, /^sept/i, /^oct/i, /^nov/i, /^dc/i ];
                var fr = moment.defineLocale("fr", {
                    months: "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split("_"),
                    monthsShort: "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split("_"),
                    monthsRegex,
                    monthsShortRegex: monthsRegex,
                    monthsStrictRegex,
                    monthsShortStrictRegex,
                    monthsParse,
                    longMonthsParse: monthsParse,
                    shortMonthsParse: monthsParse,
                    weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
                    weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
                    weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[Aujourdhui ] LT",
                        nextDay: "[Demain ] LT",
                        nextWeek: "dddd [] LT",
                        lastDay: "[Hier ] LT",
                        lastWeek: "dddd [dernier ] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "dans %s",
                        past: "il y a %s",
                        s: "quelques secondes",
                        ss: "%d secondes",
                        m: "une minute",
                        mm: "%d minutes",
                        h: "une heure",
                        hh: "%d heures",
                        d: "un jour",
                        dd: "%d jours",
                        w: "une semaine",
                        ww: "%d semaines",
                        M: "un mois",
                        MM: "%d mois",
                        y: "un an",
                        yy: "%d ans"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
                    ordinal: function(number, period) {
                        switch (period) {
                          case "D":
                            return number + (1 === number ? "er" : "");

                          default:
                          case "M":
                          case "Q":
                          case "DDD":
                          case "d":
                            return number + (1 === number ? "er" : "e");

                          case "w":
                          case "W":
                            return number + (1 === number ? "re" : "e");
                        }
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return fr;
            }));
        },
        5044: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var monthsShortWithDots = "jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.".split("_"), monthsShortWithoutDots = "jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_");
                var fy = moment.defineLocale("fy", {
                    months: "jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber".split("_"),
                    monthsShort: function(m, format) {
                        if (!m) return monthsShortWithDots; else if (/-MMM-/.test(format)) return monthsShortWithoutDots[m.month()]; else return monthsShortWithDots[m.month()];
                    },
                    monthsParseExact: true,
                    weekdays: "snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon".split("_"),
                    weekdaysShort: "si._mo._ti._wo._to._fr._so.".split("_"),
                    weekdaysMin: "Si_Mo_Ti_Wo_To_Fr_So".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD-MM-YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[hjoed om] LT",
                        nextDay: "[moarn om] LT",
                        nextWeek: "dddd [om] LT",
                        lastDay: "[juster om] LT",
                        lastWeek: "[frne] dddd [om] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "oer %s",
                        past: "%s lyn",
                        s: "in pear sekonden",
                        ss: "%d sekonden",
                        m: "ien mint",
                        mm: "%d minuten",
                        h: "ien oere",
                        hh: "%d oeren",
                        d: "ien dei",
                        dd: "%d dagen",
                        M: "ien moanne",
                        MM: "%d moannen",
                        y: "ien jier",
                        yy: "%d jierren"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
                    ordinal: function(number) {
                        return number + (1 === number || 8 === number || number >= 20 ? "ste" : "de");
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return fy;
            }));
        },
        9295: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var months = [ "Eanir", "Feabhra", "Mrta", "Aibren", "Bealtaine", "Meitheamh", "Iil", "Lnasa", "Men Fmhair", "Deireadh Fmhair", "Samhain", "Nollaig" ], monthsShort = [ "Ean", "Feabh", "Mrt", "Aib", "Beal", "Meith", "Iil", "Ln", "M.F.", "D.F.", "Samh", "Noll" ], weekdays = [ "D Domhnaigh", "D Luain", "D Mirt", "D Cadaoin", "Dardaoin", "D hAoine", "D Sathairn" ], weekdaysShort = [ "Domh", "Luan", "Mirt", "Cad", "Dar", "Aoine", "Sath" ], weekdaysMin = [ "Do", "Lu", "M", "C", "D", "A", "Sa" ];
                var ga = moment.defineLocale("ga", {
                    months,
                    monthsShort,
                    monthsParseExact: true,
                    weekdays,
                    weekdaysShort,
                    weekdaysMin,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[Inniu ag] LT",
                        nextDay: "[Amrach ag] LT",
                        nextWeek: "dddd [ag] LT",
                        lastDay: "[Inn ag] LT",
                        lastWeek: "dddd [seo caite] [ag] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "i %s",
                        past: "%s  shin",
                        s: "cpla soicind",
                        ss: "%d soicind",
                        m: "nimad",
                        mm: "%d nimad",
                        h: "uair an chloig",
                        hh: "%d uair an chloig",
                        d: "l",
                        dd: "%d l",
                        M: "m",
                        MM: "%d monna",
                        y: "bliain",
                        yy: "%d bliain"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
                    ordinal: function(number) {
                        var output = 1 === number ? "d" : number % 10 === 2 ? "na" : "mh";
                        return number + output;
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return ga;
            }));
        },
        2101: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var months = [ "Am Faoilleach", "An Gearran", "Am Mrt", "An Giblean", "An Citean", "An t-gmhios", "An t-Iuchar", "An Lnastal", "An t-Sultain", "An Dmhair", "An t-Samhain", "An Dbhlachd" ], monthsShort = [ "Faoi", "Gear", "Mrt", "Gibl", "Cit", "gmh", "Iuch", "Ln", "Sult", "Dmh", "Samh", "Dbh" ], weekdays = [ "Didmhnaich", "Diluain", "Dimirt", "Diciadain", "Diardaoin", "Dihaoine", "Disathairne" ], weekdaysShort = [ "Did", "Dil", "Dim", "Dic", "Dia", "Dih", "Dis" ], weekdaysMin = [ "D", "Lu", "M", "Ci", "Ar", "Ha", "Sa" ];
                var gd = moment.defineLocale("gd", {
                    months,
                    monthsShort,
                    monthsParseExact: true,
                    weekdays,
                    weekdaysShort,
                    weekdaysMin,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[An-diugh aig] LT",
                        nextDay: "[A-mireach aig] LT",
                        nextWeek: "dddd [aig] LT",
                        lastDay: "[An-d aig] LT",
                        lastWeek: "dddd [seo chaidh] [aig] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "ann an %s",
                        past: "bho chionn %s",
                        s: "beagan diogan",
                        ss: "%d diogan",
                        m: "mionaid",
                        mm: "%d mionaidean",
                        h: "uair",
                        hh: "%d uairean",
                        d: "latha",
                        dd: "%d latha",
                        M: "mos",
                        MM: "%d mosan",
                        y: "bliadhna",
                        yy: "%d bliadhna"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
                    ordinal: function(number) {
                        var output = 1 === number ? "d" : number % 10 === 2 ? "na" : "mh";
                        return number + output;
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return gd;
            }));
        },
        8794: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var gl = moment.defineLocale("gl", {
                    months: "xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro".split("_"),
                    monthsShort: "xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.".split("_"),
                    monthsParseExact: true,
                    weekdays: "domingo_luns_martes_mrcores_xoves_venres_sbado".split("_"),
                    weekdaysShort: "dom._lun._mar._mr._xov._ven._sb.".split("_"),
                    weekdaysMin: "do_lu_ma_m_xo_ve_s".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D [de] MMMM [de] YYYY",
                        LLL: "D [de] MMMM [de] YYYY H:mm",
                        LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
                    },
                    calendar: {
                        sameDay: function() {
                            return "[hoxe " + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        nextDay: function() {
                            return "[ma " + (1 !== this.hours() ? "s" : "") + "] LT";
                        },
                        nextWeek: function() {
                            return "dddd [" + (1 !== this.hours() ? "s" : "a") + "] LT";
                        },
                        lastDay: function() {
                            return "[onte " + (1 !== this.hours() ? "" : "a") + "] LT";
                        },
                        lastWeek: function() {
                            return "[o] dddd [pasado " + (1 !== this.hours() ? "s" : "a") + "] LT";
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: function(str) {
                            if (0 === str.indexOf("un")) return "n" + str;
                            return "en " + str;
                        },
                        past: "hai %s",
                        s: "uns segundos",
                        ss: "%d segundos",
                        m: "un minuto",
                        mm: "%d minutos",
                        h: "unha hora",
                        hh: "%d horas",
                        d: "un da",
                        dd: "%d das",
                        M: "un mes",
                        MM: "%d meses",
                        y: "un ano",
                        yy: "%d anos"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: "%d",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return gl;
            }));
        },
        7884: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                function processRelativeTime(number, withoutSuffix, key, isFuture) {
                    var format = {
                        s: [ " ", " " ],
                        ss: [ number + " ", number + " " ],
                        m: [ " ", " " ],
                        mm: [ number + " ", number + " " ],
                        h: [ " ", " " ],
                        hh: [ number + " ", number + " " ],
                        d: [ " ", " " ],
                        dd: [ number + " ", number + " " ],
                        M: [ " ", " " ],
                        MM: [ number + " ", number + " " ],
                        y: [ " ", " " ],
                        yy: [ number + " ", number + " " ]
                    };
                    return isFuture ? format[key][0] : format[key][1];
                }
                var gomDeva = moment.defineLocale("gom-deva", {
                    months: {
                        standalone: "___________".split("_"),
                        format: "___________".split("_"),
                        isFormat: /MMMM(\s)+D[oD]?/
                    },
                    monthsShort: "._.__.___._._._._._.".split("_"),
                    monthsParseExact: true,
                    weekdays: "______".split("_"),
                    weekdaysShort: "._._._._._._.".split("_"),
                    weekdaysMin: "______".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "A h:mm []",
                        LTS: "A h:mm:ss []",
                        L: "DD-MM-YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY A h:mm []",
                        LLLL: "dddd, MMMM Do, YYYY, A h:mm []",
                        llll: "ddd, D MMM YYYY, A h:mm []"
                    },
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        nextWeek: "[] dddd[,] LT",
                        lastDay: "[] LT",
                        lastWeek: "[] dddd[,] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s",
                        past: "%s ",
                        s: processRelativeTime,
                        ss: processRelativeTime,
                        m: processRelativeTime,
                        mm: processRelativeTime,
                        h: processRelativeTime,
                        hh: processRelativeTime,
                        d: processRelativeTime,
                        dd: processRelativeTime,
                        M: processRelativeTime,
                        MM: processRelativeTime,
                        y: processRelativeTime,
                        yy: processRelativeTime
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}()/,
                    ordinal: function(number, period) {
                        switch (period) {
                          case "D":
                            return number + "";

                          default:
                          case "M":
                          case "Q":
                          case "DDD":
                          case "d":
                          case "w":
                          case "W":
                            return number;
                        }
                    },
                    week: {
                        dow: 0,
                        doy: 3
                    },
                    meridiemParse: /|||/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("" === meridiem) return hour < 4 ? hour : hour + 12; else if ("" === meridiem) return hour; else if ("" === meridiem) return hour > 12 ? hour : hour + 12; else if ("" === meridiem) return hour + 12;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 4) return ""; else if (hour < 12) return ""; else if (hour < 16) return ""; else if (hour < 20) return ""; else return "";
                    }
                });
                return gomDeva;
            }));
        },
        3168: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                function processRelativeTime(number, withoutSuffix, key, isFuture) {
                    var format = {
                        s: [ "thoddea sekondamni", "thodde sekond" ],
                        ss: [ number + " sekondamni", number + " sekond" ],
                        m: [ "eka mintan", "ek minut" ],
                        mm: [ number + " mintamni", number + " mintam" ],
                        h: [ "eka voran", "ek vor" ],
                        hh: [ number + " voramni", number + " voram" ],
                        d: [ "eka disan", "ek dis" ],
                        dd: [ number + " disamni", number + " dis" ],
                        M: [ "eka mhoinean", "ek mhoino" ],
                        MM: [ number + " mhoineamni", number + " mhoine" ],
                        y: [ "eka vorsan", "ek voros" ],
                        yy: [ number + " vorsamni", number + " vorsam" ]
                    };
                    return isFuture ? format[key][0] : format[key][1];
                }
                var gomLatn = moment.defineLocale("gom-latn", {
                    months: {
                        standalone: "Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr".split("_"),
                        format: "Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea".split("_"),
                        isFormat: /MMMM(\s)+D[oD]?/
                    },
                    monthsShort: "Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.".split("_"),
                    monthsParseExact: true,
                    weekdays: "Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split("_"),
                    weekdaysShort: "Ait._Som._Mon._Bud._Bre._Suk._Son.".split("_"),
                    weekdaysMin: "Ai_Sm_Mo_Bu_Br_Su_Sn".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "A h:mm [vazta]",
                        LTS: "A h:mm:ss [vazta]",
                        L: "DD-MM-YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY A h:mm [vazta]",
                        LLLL: "dddd, MMMM Do, YYYY, A h:mm [vazta]",
                        llll: "ddd, D MMM YYYY, A h:mm [vazta]"
                    },
                    calendar: {
                        sameDay: "[Aiz] LT",
                        nextDay: "[Faleam] LT",
                        nextWeek: "[Fuddlo] dddd[,] LT",
                        lastDay: "[Kal] LT",
                        lastWeek: "[Fattlo] dddd[,] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s",
                        past: "%s adim",
                        s: processRelativeTime,
                        ss: processRelativeTime,
                        m: processRelativeTime,
                        mm: processRelativeTime,
                        h: processRelativeTime,
                        hh: processRelativeTime,
                        d: processRelativeTime,
                        dd: processRelativeTime,
                        M: processRelativeTime,
                        MM: processRelativeTime,
                        y: processRelativeTime,
                        yy: processRelativeTime
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(er)/,
                    ordinal: function(number, period) {
                        switch (period) {
                          case "D":
                            return number + "er";

                          default:
                          case "M":
                          case "Q":
                          case "DDD":
                          case "d":
                          case "w":
                          case "W":
                            return number;
                        }
                    },
                    week: {
                        dow: 0,
                        doy: 3
                    },
                    meridiemParse: /rati|sokallim|donparam|sanje/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("rati" === meridiem) return hour < 4 ? hour : hour + 12; else if ("sokallim" === meridiem) return hour; else if ("donparam" === meridiem) return hour > 12 ? hour : hour + 12; else if ("sanje" === meridiem) return hour + 12;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 4) return "rati"; else if (hour < 12) return "sokallim"; else if (hour < 16) return "donparam"; else if (hour < 20) return "sanje"; else return "rati";
                    }
                });
                return gomLatn;
            }));
        },
        5349: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var symbolMap = {
                    1: "",
                    2: "",
                    3: "",
                    4: "",
                    5: "",
                    6: "",
                    7: "",
                    8: "",
                    9: "",
                    0: ""
                }, numberMap = {
                    "": "1",
                    "": "2",
                    "": "3",
                    "": "4",
                    "": "5",
                    "": "6",
                    "": "7",
                    "": "8",
                    "": "9",
                    "": "0"
                };
                var gu = moment.defineLocale("gu", {
                    months: "___________".split("_"),
                    monthsShort: "._.__.___._._._._._.".split("_"),
                    monthsParseExact: true,
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "A h:mm ",
                        LTS: "A h:mm:ss ",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY, A h:mm ",
                        LLLL: "dddd, D MMMM YYYY, A h:mm "
                    },
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        nextWeek: "dddd, LT",
                        lastDay: "[] LT",
                        lastWeek: "[] dddd, LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s ",
                        past: "%s ",
                        s: " ",
                        ss: "%d ",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    preparse: function(string) {
                        return string.replace(/[]/g, (function(match) {
                            return numberMap[match];
                        }));
                    },
                    postformat: function(string) {
                        return string.replace(/\d/g, (function(match) {
                            return symbolMap[match];
                        }));
                    },
                    meridiemParse: /|||/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("" === meridiem) return hour < 4 ? hour : hour + 12; else if ("" === meridiem) return hour; else if ("" === meridiem) return hour >= 10 ? hour : hour + 12; else if ("" === meridiem) return hour + 12;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 4) return ""; else if (hour < 10) return ""; else if (hour < 17) return ""; else if (hour < 20) return ""; else return "";
                    },
                    week: {
                        dow: 0,
                        doy: 6
                    }
                });
                return gu;
            }));
        },
        4206: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var he = moment.defineLocale("he", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D []MMMM YYYY",
                        LLL: "D []MMMM YYYY HH:mm",
                        LLLL: "dddd, D []MMMM YYYY HH:mm",
                        l: "D/M/YYYY",
                        ll: "D MMM YYYY",
                        lll: "D MMM YYYY HH:mm",
                        llll: "ddd, D MMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[ ]LT",
                        nextDay: "[ ]LT",
                        nextWeek: "dddd [] LT",
                        lastDay: "[ ]LT",
                        lastWeek: "[] dddd [ ] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s",
                        past: " %s",
                        s: " ",
                        ss: "%d ",
                        m: "",
                        mm: "%d ",
                        h: "",
                        hh: function(number) {
                            if (2 === number) return "";
                            return number + " ";
                        },
                        d: "",
                        dd: function(number) {
                            if (2 === number) return "";
                            return number + " ";
                        },
                        M: "",
                        MM: function(number) {
                            if (2 === number) return "";
                            return number + " ";
                        },
                        y: "",
                        yy: function(number) {
                            if (2 === number) return ""; else if (number % 10 === 0 && 10 !== number) return number + " ";
                            return number + " ";
                        }
                    },
                    meridiemParse: /"|"| | | ||/i,
                    isPM: function(input) {
                        return /^("| |)$/.test(input);
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 5) return " "; else if (hour < 10) return ""; else if (hour < 12) return isLower ? '"' : " "; else if (hour < 18) return isLower ? '"' : " "; else return "";
                    }
                });
                return he;
            }));
        },
        94: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var symbolMap = {
                    1: "",
                    2: "",
                    3: "",
                    4: "",
                    5: "",
                    6: "",
                    7: "",
                    8: "",
                    9: "",
                    0: ""
                }, numberMap = {
                    "": "1",
                    "": "2",
                    "": "3",
                    "": "4",
                    "": "5",
                    "": "6",
                    "": "7",
                    "": "8",
                    "": "9",
                    "": "0"
                }, monthsParse = [ /^/i, /^|/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^|/i, /^/i, /^|/i, /^|/i ], shortMonthsParse = [ /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i ];
                var hi = moment.defineLocale("hi", {
                    months: {
                        format: "___________".split("_"),
                        standalone: "___________".split("_")
                    },
                    monthsShort: "._.__.___._._._._._.".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "A h:mm ",
                        LTS: "A h:mm:ss ",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY, A h:mm ",
                        LLLL: "dddd, D MMMM YYYY, A h:mm "
                    },
                    monthsParse,
                    longMonthsParse: monthsParse,
                    shortMonthsParse,
                    monthsRegex: /^(|\.?|||\.?|?||\.?|?|?||\.?||\.?|||\.?||\.?|||\.?|||\.?)/i,
                    monthsShortRegex: /^(|\.?|||\.?|?||\.?|?|?||\.?||\.?|||\.?||\.?|||\.?|||\.?)/i,
                    monthsStrictRegex: /^(?||?|?|?|?|?|?|?|||?\.?||\.?||?||?)/i,
                    monthsShortStrictRegex: /^(\.?|\.?|?|\.?|?|?|\.?|\.?|\.?|\.?|\.?|\.?)/i,
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        nextWeek: "dddd, LT",
                        lastDay: "[] LT",
                        lastWeek: "[] dddd, LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s ",
                        past: "%s ",
                        s: "  ",
                        ss: "%d ",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    preparse: function(string) {
                        return string.replace(/[]/g, (function(match) {
                            return numberMap[match];
                        }));
                    },
                    postformat: function(string) {
                        return string.replace(/\d/g, (function(match) {
                            return symbolMap[match];
                        }));
                    },
                    meridiemParse: /|||/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("" === meridiem) return hour < 4 ? hour : hour + 12; else if ("" === meridiem) return hour; else if ("" === meridiem) return hour >= 10 ? hour : hour + 12; else if ("" === meridiem) return hour + 12;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 4) return ""; else if (hour < 10) return ""; else if (hour < 17) return ""; else if (hour < 20) return ""; else return "";
                    },
                    week: {
                        dow: 0,
                        doy: 6
                    }
                });
                return hi;
            }));
        },
        316: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                function translate(number, withoutSuffix, key) {
                    var result = number + " ";
                    switch (key) {
                      case "ss":
                        if (1 === number) result += "sekunda"; else if (2 === number || 3 === number || 4 === number) result += "sekunde"; else result += "sekundi";
                        return result;

                      case "m":
                        return withoutSuffix ? "jedna minuta" : "jedne minute";

                      case "mm":
                        if (1 === number) result += "minuta"; else if (2 === number || 3 === number || 4 === number) result += "minute"; else result += "minuta";
                        return result;

                      case "h":
                        return withoutSuffix ? "jedan sat" : "jednog sata";

                      case "hh":
                        if (1 === number) result += "sat"; else if (2 === number || 3 === number || 4 === number) result += "sata"; else result += "sati";
                        return result;

                      case "dd":
                        if (1 === number) result += "dan"; else result += "dana";
                        return result;

                      case "MM":
                        if (1 === number) result += "mjesec"; else if (2 === number || 3 === number || 4 === number) result += "mjeseca"; else result += "mjeseci";
                        return result;

                      case "yy":
                        if (1 === number) result += "godina"; else if (2 === number || 3 === number || 4 === number) result += "godine"; else result += "godina";
                        return result;
                    }
                }
                var hr = moment.defineLocale("hr", {
                    months: {
                        format: "sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca".split("_"),
                        standalone: "sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac".split("_")
                    },
                    monthsShort: "sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.".split("_"),
                    monthsParseExact: true,
                    weekdays: "nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota".split("_"),
                    weekdaysShort: "ned._pon._uto._sri._et._pet._sub.".split("_"),
                    weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "Do MMMM YYYY",
                        LLL: "Do MMMM YYYY H:mm",
                        LLLL: "dddd, Do MMMM YYYY H:mm"
                    },
                    calendar: {
                        sameDay: "[danas u] LT",
                        nextDay: "[sutra u] LT",
                        nextWeek: function() {
                            switch (this.day()) {
                              case 0:
                                return "[u] [nedjelju] [u] LT";

                              case 3:
                                return "[u] [srijedu] [u] LT";

                              case 6:
                                return "[u] [subotu] [u] LT";

                              case 1:
                              case 2:
                              case 4:
                              case 5:
                                return "[u] dddd [u] LT";
                            }
                        },
                        lastDay: "[juer u] LT",
                        lastWeek: function() {
                            switch (this.day()) {
                              case 0:
                                return "[prolu] [nedjelju] [u] LT";

                              case 3:
                                return "[prolu] [srijedu] [u] LT";

                              case 6:
                                return "[prole] [subote] [u] LT";

                              case 1:
                              case 2:
                              case 4:
                              case 5:
                                return "[proli] dddd [u] LT";
                            }
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "za %s",
                        past: "prije %s",
                        s: "par sekundi",
                        ss: translate,
                        m: translate,
                        mm: translate,
                        h: translate,
                        hh: translate,
                        d: "dan",
                        dd: translate,
                        M: "mjesec",
                        MM: translate,
                        y: "godinu",
                        yy: translate
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return hr;
            }));
        },
        2138: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var weekEndings = "vasrnap htfn kedden szerdn cstrtkn pnteken szombaton".split(" ");
                function translate(number, withoutSuffix, key, isFuture) {
                    var num = number;
                    switch (key) {
                      case "s":
                        return isFuture || withoutSuffix ? "nhny msodperc" : "nhny msodperce";

                      case "ss":
                        return num + (isFuture || withoutSuffix) ? " msodperc" : " msodperce";

                      case "m":
                        return "egy" + (isFuture || withoutSuffix ? " perc" : " perce");

                      case "mm":
                        return num + (isFuture || withoutSuffix ? " perc" : " perce");

                      case "h":
                        return "egy" + (isFuture || withoutSuffix ? " ra" : " rja");

                      case "hh":
                        return num + (isFuture || withoutSuffix ? " ra" : " rja");

                      case "d":
                        return "egy" + (isFuture || withoutSuffix ? " nap" : " napja");

                      case "dd":
                        return num + (isFuture || withoutSuffix ? " nap" : " napja");

                      case "M":
                        return "egy" + (isFuture || withoutSuffix ? " hnap" : " hnapja");

                      case "MM":
                        return num + (isFuture || withoutSuffix ? " hnap" : " hnapja");

                      case "y":
                        return "egy" + (isFuture || withoutSuffix ? " v" : " ve");

                      case "yy":
                        return num + (isFuture || withoutSuffix ? " v" : " ve");
                    }
                    return "";
                }
                function week(isFuture) {
                    return (isFuture ? "" : "[mlt] ") + "[" + weekEndings[this.day()] + "] LT[-kor]";
                }
                var hu = moment.defineLocale("hu", {
                    months: "janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december".split("_"),
                    monthsShort: "jan._feb._mrc._pr._mj._jn._jl._aug._szept._okt._nov._dec.".split("_"),
                    monthsParseExact: true,
                    weekdays: "vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat".split("_"),
                    weekdaysShort: "vas_ht_kedd_sze_cst_pn_szo".split("_"),
                    weekdaysMin: "v_h_k_sze_cs_p_szo".split("_"),
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "YYYY.MM.DD.",
                        LL: "YYYY. MMMM D.",
                        LLL: "YYYY. MMMM D. H:mm",
                        LLLL: "YYYY. MMMM D., dddd H:mm"
                    },
                    meridiemParse: /de|du/i,
                    isPM: function(input) {
                        return "u" === input.charAt(1).toLowerCase();
                    },
                    meridiem: function(hours, minutes, isLower) {
                        if (hours < 12) return true === isLower ? "de" : "DE"; else return true === isLower ? "du" : "DU";
                    },
                    calendar: {
                        sameDay: "[ma] LT[-kor]",
                        nextDay: "[holnap] LT[-kor]",
                        nextWeek: function() {
                            return week.call(this, true);
                        },
                        lastDay: "[tegnap] LT[-kor]",
                        lastWeek: function() {
                            return week.call(this, false);
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s mlva",
                        past: "%s",
                        s: translate,
                        ss: translate,
                        m: translate,
                        mm: translate,
                        h: translate,
                        hh: translate,
                        d: translate,
                        dd: translate,
                        M: translate,
                        MM: translate,
                        y: translate,
                        yy: translate
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return hu;
            }));
        },
        1423: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var hyAm = moment.defineLocale("hy-am", {
                    months: {
                        format: "___________".split("_"),
                        standalone: "___________".split("_")
                    },
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D MMMM YYYY .",
                        LLL: "D MMMM YYYY ., HH:mm",
                        LLLL: "dddd, D MMMM YYYY ., HH:mm"
                    },
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        lastDay: "[] LT",
                        nextWeek: function() {
                            return "dddd [ ] LT";
                        },
                        lastWeek: function() {
                            return "[] dddd [ ] LT";
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s ",
                        past: "%s ",
                        s: "  ",
                        ss: "%d ",
                        m: "",
                        mm: "%d ",
                        h: "",
                        hh: "%d ",
                        d: "",
                        dd: "%d ",
                        M: "",
                        MM: "%d ",
                        y: "",
                        yy: "%d "
                    },
                    meridiemParse: /|||/,
                    isPM: function(input) {
                        return /^(|)$/.test(input);
                    },
                    meridiem: function(hour) {
                        if (hour < 4) return ""; else if (hour < 12) return ""; else if (hour < 17) return ""; else return "";
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(|)/,
                    ordinal: function(number, period) {
                        switch (period) {
                          case "DDD":
                          case "w":
                          case "W":
                          case "DDDo":
                            if (1 === number) return number + "-";
                            return number + "-";

                          default:
                            return number;
                        }
                    },
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return hyAm;
            }));
        },
        9218: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var id = moment.defineLocale("id", {
                    months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split("_"),
                    monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des".split("_"),
                    weekdays: "Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"),
                    weekdaysShort: "Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"),
                    weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"),
                    longDateFormat: {
                        LT: "HH.mm",
                        LTS: "HH.mm.ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY [pukul] HH.mm",
                        LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
                    },
                    meridiemParse: /pagi|siang|sore|malam/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("pagi" === meridiem) return hour; else if ("siang" === meridiem) return hour >= 11 ? hour : hour + 12; else if ("sore" === meridiem || "malam" === meridiem) return hour + 12;
                    },
                    meridiem: function(hours, minutes, isLower) {
                        if (hours < 11) return "pagi"; else if (hours < 15) return "siang"; else if (hours < 19) return "sore"; else return "malam";
                    },
                    calendar: {
                        sameDay: "[Hari ini pukul] LT",
                        nextDay: "[Besok pukul] LT",
                        nextWeek: "dddd [pukul] LT",
                        lastDay: "[Kemarin pukul] LT",
                        lastWeek: "dddd [lalu pukul] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "dalam %s",
                        past: "%s yang lalu",
                        s: "beberapa detik",
                        ss: "%d detik",
                        m: "semenit",
                        mm: "%d menit",
                        h: "sejam",
                        hh: "%d jam",
                        d: "sehari",
                        dd: "%d hari",
                        M: "sebulan",
                        MM: "%d bulan",
                        y: "setahun",
                        yy: "%d tahun"
                    },
                    week: {
                        dow: 0,
                        doy: 6
                    }
                });
                return id;
            }));
        },
        135: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                function plural(n) {
                    if (n % 100 === 11) return true; else if (n % 10 === 1) return false;
                    return true;
                }
                function translate(number, withoutSuffix, key, isFuture) {
                    var result = number + " ";
                    switch (key) {
                      case "s":
                        return withoutSuffix || isFuture ? "nokkrar sekndur" : "nokkrum sekndum";

                      case "ss":
                        if (plural(number)) return result + (withoutSuffix || isFuture ? "sekndur" : "sekndum");
                        return result + "seknda";

                      case "m":
                        return withoutSuffix ? "mnta" : "mntu";

                      case "mm":
                        if (plural(number)) return result + (withoutSuffix || isFuture ? "mntur" : "mntum"); else if (withoutSuffix) return result + "mnta";
                        return result + "mntu";

                      case "hh":
                        if (plural(number)) return result + (withoutSuffix || isFuture ? "klukkustundir" : "klukkustundum");
                        return result + "klukkustund";

                      case "d":
                        if (withoutSuffix) return "dagur";
                        return isFuture ? "dag" : "degi";

                      case "dd":
                        if (plural(number)) {
                            if (withoutSuffix) return result + "dagar";
                            return result + (isFuture ? "daga" : "dgum");
                        } else if (withoutSuffix) return result + "dagur";
                        return result + (isFuture ? "dag" : "degi");

                      case "M":
                        if (withoutSuffix) return "mnuur";
                        return isFuture ? "mnu" : "mnui";

                      case "MM":
                        if (plural(number)) {
                            if (withoutSuffix) return result + "mnuir";
                            return result + (isFuture ? "mnui" : "mnuum");
                        } else if (withoutSuffix) return result + "mnuur";
                        return result + (isFuture ? "mnu" : "mnui");

                      case "y":
                        return withoutSuffix || isFuture ? "r" : "ri";

                      case "yy":
                        if (plural(number)) return result + (withoutSuffix || isFuture ? "r" : "rum");
                        return result + (withoutSuffix || isFuture ? "r" : "ri");
                    }
                }
                var is = moment.defineLocale("is", {
                    months: "janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember".split("_"),
                    monthsShort: "jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des".split("_"),
                    weekdays: "sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur".split("_"),
                    weekdaysShort: "sun_mn_ri_mi_fim_fs_lau".split("_"),
                    weekdaysMin: "Su_M_r_Mi_Fi_F_La".split("_"),
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D. MMMM YYYY",
                        LLL: "D. MMMM YYYY [kl.] H:mm",
                        LLLL: "dddd, D. MMMM YYYY [kl.] H:mm"
                    },
                    calendar: {
                        sameDay: "[ dag kl.] LT",
                        nextDay: "[ morgun kl.] LT",
                        nextWeek: "dddd [kl.] LT",
                        lastDay: "[ gr kl.] LT",
                        lastWeek: "[sasta] dddd [kl.] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "eftir %s",
                        past: "fyrir %s san",
                        s: translate,
                        ss: translate,
                        m: translate,
                        mm: translate,
                        h: "klukkustund",
                        hh: translate,
                        d: translate,
                        dd: translate,
                        M: translate,
                        MM: translate,
                        y: translate,
                        yy: translate
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return is;
            }));
        },
        150: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var itCh = moment.defineLocale("it-ch", {
                    months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),
                    monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),
                    weekdays: "domenica_luned_marted_mercoled_gioved_venerd_sabato".split("_"),
                    weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"),
                    weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[Oggi alle] LT",
                        nextDay: "[Domani alle] LT",
                        nextWeek: "dddd [alle] LT",
                        lastDay: "[Ieri alle] LT",
                        lastWeek: function() {
                            switch (this.day()) {
                              case 0:
                                return "[la scorsa] dddd [alle] LT";

                              default:
                                return "[lo scorso] dddd [alle] LT";
                            }
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: function(s) {
                            return (/^[0-9].+$/.test(s) ? "tra" : "in") + " " + s;
                        },
                        past: "%s fa",
                        s: "alcuni secondi",
                        ss: "%d secondi",
                        m: "un minuto",
                        mm: "%d minuti",
                        h: "un'ora",
                        hh: "%d ore",
                        d: "un giorno",
                        dd: "%d giorni",
                        M: "un mese",
                        MM: "%d mesi",
                        y: "un anno",
                        yy: "%d anni"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: "%d",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return itCh;
            }));
        },
        626: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var it = moment.defineLocale("it", {
                    months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),
                    monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),
                    weekdays: "domenica_luned_marted_mercoled_gioved_venerd_sabato".split("_"),
                    weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"),
                    weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: function() {
                            return "[Oggi a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT";
                        },
                        nextDay: function() {
                            return "[Domani a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT";
                        },
                        nextWeek: function() {
                            return "dddd [a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT";
                        },
                        lastDay: function() {
                            return "[Ieri a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT";
                        },
                        lastWeek: function() {
                            switch (this.day()) {
                              case 0:
                                return "[La scorsa] dddd [a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT";

                              default:
                                return "[Lo scorso] dddd [a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT";
                            }
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "tra %s",
                        past: "%s fa",
                        s: "alcuni secondi",
                        ss: "%d secondi",
                        m: "un minuto",
                        mm: "%d minuti",
                        h: "un'ora",
                        hh: "%d ore",
                        d: "un giorno",
                        dd: "%d giorni",
                        w: "una settimana",
                        ww: "%d settimane",
                        M: "un mese",
                        MM: "%d mesi",
                        y: "un anno",
                        yy: "%d anni"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: "%d",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return it;
            }));
        },
        9183: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var ja = moment.defineLocale("ja", {
                    eras: [ {
                        since: "2019-05-01",
                        offset: 1,
                        name: "",
                        narrow: "",
                        abbr: "R"
                    }, {
                        since: "1989-01-08",
                        until: "2019-04-30",
                        offset: 1,
                        name: "",
                        narrow: "",
                        abbr: "H"
                    }, {
                        since: "1926-12-25",
                        until: "1989-01-07",
                        offset: 1,
                        name: "",
                        narrow: "",
                        abbr: "S"
                    }, {
                        since: "1912-07-30",
                        until: "1926-12-24",
                        offset: 1,
                        name: "",
                        narrow: "",
                        abbr: "T"
                    }, {
                        since: "1873-01-01",
                        until: "1912-07-29",
                        offset: 6,
                        name: "",
                        narrow: "",
                        abbr: "M"
                    }, {
                        since: "0001-01-01",
                        until: "1873-12-31",
                        offset: 1,
                        name: "",
                        narrow: "AD",
                        abbr: "AD"
                    }, {
                        since: "0000-12-31",
                        until: -1 / 0,
                        offset: 1,
                        name: "",
                        narrow: "BC",
                        abbr: "BC"
                    } ],
                    eraYearOrdinalRegex: /(|\d+)/,
                    eraYearOrdinalParse: function(input, match) {
                        return "" === match[1] ? 1 : parseInt(match[1] || input, 10);
                    },
                    months: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
                    monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "YYYY/MM/DD",
                        LL: "YYYYMD",
                        LLL: "YYYYMD HH:mm",
                        LLLL: "YYYYMD dddd HH:mm",
                        l: "YYYY/MM/DD",
                        ll: "YYYYMD",
                        lll: "YYYYMD HH:mm",
                        llll: "YYYYMD(ddd) HH:mm"
                    },
                    meridiemParse: /|/i,
                    isPM: function(input) {
                        return "" === input;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 12) return ""; else return "";
                    },
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        nextWeek: function(now) {
                            if (now.week() !== this.week()) return "[]dddd LT"; else return "dddd LT";
                        },
                        lastDay: "[] LT",
                        lastWeek: function(now) {
                            if (this.week() !== now.week()) return "[]dddd LT"; else return "dddd LT";
                        },
                        sameElse: "L"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: function(number, period) {
                        switch (period) {
                          case "y":
                            return 1 === number ? "" : number + "";

                          case "d":
                          case "D":
                          case "DDD":
                            return number + "";

                          default:
                            return number;
                        }
                    },
                    relativeTime: {
                        future: "%s",
                        past: "%s",
                        s: "",
                        ss: "%d",
                        m: "1",
                        mm: "%d",
                        h: "1",
                        hh: "%d",
                        d: "1",
                        dd: "%d",
                        M: "1",
                        MM: "%d",
                        y: "1",
                        yy: "%d"
                    }
                });
                return ja;
            }));
        },
        4286: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var jv = moment.defineLocale("jv", {
                    months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember".split("_"),
                    monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des".split("_"),
                    weekdays: "Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu".split("_"),
                    weekdaysShort: "Min_Sen_Sel_Reb_Kem_Jem_Sep".split("_"),
                    weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sp".split("_"),
                    longDateFormat: {
                        LT: "HH.mm",
                        LTS: "HH.mm.ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY [pukul] HH.mm",
                        LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
                    },
                    meridiemParse: /enjing|siyang|sonten|ndalu/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("enjing" === meridiem) return hour; else if ("siyang" === meridiem) return hour >= 11 ? hour : hour + 12; else if ("sonten" === meridiem || "ndalu" === meridiem) return hour + 12;
                    },
                    meridiem: function(hours, minutes, isLower) {
                        if (hours < 11) return "enjing"; else if (hours < 15) return "siyang"; else if (hours < 19) return "sonten"; else return "ndalu";
                    },
                    calendar: {
                        sameDay: "[Dinten puniko pukul] LT",
                        nextDay: "[Mbenjang pukul] LT",
                        nextWeek: "dddd [pukul] LT",
                        lastDay: "[Kala wingi pukul] LT",
                        lastWeek: "dddd [kepengker pukul] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "wonten ing %s",
                        past: "%s ingkang kepengker",
                        s: "sawetawis detik",
                        ss: "%d detik",
                        m: "setunggal menit",
                        mm: "%d menit",
                        h: "setunggal jam",
                        hh: "%d jam",
                        d: "sedinten",
                        dd: "%d dinten",
                        M: "sewulan",
                        MM: "%d wulan",
                        y: "setaun",
                        yy: "%d taun"
                    },
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return jv;
            }));
        },
        2105: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var ka = moment.defineLocale("ka", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: {
                        standalone: "______".split("_"),
                        format: "______".split("_"),
                        isFormat: /(|)/
                    },
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[] LT[-]",
                        nextDay: "[] LT[-]",
                        lastDay: "[] LT[-]",
                        nextWeek: "[] dddd LT[-]",
                        lastWeek: "[] dddd LT-",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: function(s) {
                            return s.replace(/(|||||)(|)/, (function($0, $1, $2) {
                                return "" === $2 ? $1 + "" : $1 + $2 + "";
                            }));
                        },
                        past: function(s) {
                            if (/(||||)/.test(s)) return s.replace(/(|)$/, " ");
                            if (//.test(s)) return s.replace(/$/, " ");
                            return s;
                        },
                        s: " ",
                        ss: "%d ",
                        m: "",
                        mm: "%d ",
                        h: "",
                        hh: "%d ",
                        d: "",
                        dd: "%d ",
                        M: "",
                        MM: "%d ",
                        y: "",
                        yy: "%d "
                    },
                    dayOfMonthOrdinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
                    ordinal: function(number) {
                        if (0 === number) return number;
                        if (1 === number) return number + "-";
                        if (number < 20 || number <= 100 && number % 20 === 0 || number % 100 === 0) return "-" + number;
                        return number + "-";
                    },
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return ka;
            }));
        },
        7772: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var suffixes = {
                    0: "-",
                    1: "-",
                    2: "-",
                    3: "-",
                    4: "-",
                    5: "-",
                    6: "-",
                    7: "-",
                    8: "-",
                    9: "-",
                    10: "-",
                    20: "-",
                    30: "-",
                    40: "-",
                    50: "-",
                    60: "-",
                    70: "-",
                    80: "-",
                    90: "-",
                    100: "-"
                };
                var kk = moment.defineLocale("kk", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[ ] LT",
                        nextDay: "[ ] LT",
                        nextWeek: "dddd [] LT",
                        lastDay: "[ ] LT",
                        lastWeek: "[ ] dddd [] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s ",
                        past: "%s ",
                        s: " ",
                        ss: "%d ",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
                    ordinal: function(number) {
                        var a = number % 10, b = number >= 100 ? 100 : null;
                        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
                    },
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return kk;
            }));
        },
        8758: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var symbolMap = {
                    1: "",
                    2: "",
                    3: "",
                    4: "",
                    5: "",
                    6: "",
                    7: "",
                    8: "",
                    9: "",
                    0: ""
                }, numberMap = {
                    "": "1",
                    "": "2",
                    "": "3",
                    "": "4",
                    "": "5",
                    "": "6",
                    "": "7",
                    "": "8",
                    "": "9",
                    "": "0"
                };
                var km = moment.defineLocale("km", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    meridiemParse: /|/,
                    isPM: function(input) {
                        return "" === input;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 12) return ""; else return "";
                    },
                    calendar: {
                        sameDay: "[ ] LT",
                        nextDay: "[ ] LT",
                        nextWeek: "dddd [] LT",
                        lastDay: "[ ] LT",
                        lastWeek: "dddd [] [] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s",
                        past: "%s",
                        s: "",
                        ss: "%d ",
                        m: "",
                        mm: "%d ",
                        h: "",
                        hh: "%d ",
                        d: "",
                        dd: "%d ",
                        M: "",
                        MM: "%d ",
                        y: "",
                        yy: "%d "
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: "%d",
                    preparse: function(string) {
                        return string.replace(/[]/g, (function(match) {
                            return numberMap[match];
                        }));
                    },
                    postformat: function(string) {
                        return string.replace(/\d/g, (function(match) {
                            return symbolMap[match];
                        }));
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return km;
            }));
        },
        9282: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var symbolMap = {
                    1: "",
                    2: "",
                    3: "",
                    4: "",
                    5: "",
                    6: "",
                    7: "",
                    8: "",
                    9: "",
                    0: ""
                }, numberMap = {
                    "": "1",
                    "": "2",
                    "": "3",
                    "": "4",
                    "": "5",
                    "": "6",
                    "": "7",
                    "": "8",
                    "": "9",
                    "": "0"
                };
                var kn = moment.defineLocale("kn", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    monthsParseExact: true,
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "A h:mm",
                        LTS: "A h:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY, A h:mm",
                        LLLL: "dddd, D MMMM YYYY, A h:mm"
                    },
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        nextWeek: "dddd, LT",
                        lastDay: "[] LT",
                        lastWeek: "[] dddd, LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s ",
                        past: "%s ",
                        s: " ",
                        ss: "%d ",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    preparse: function(string) {
                        return string.replace(/[]/g, (function(match) {
                            return numberMap[match];
                        }));
                    },
                    postformat: function(string) {
                        return string.replace(/\d/g, (function(match) {
                            return symbolMap[match];
                        }));
                    },
                    meridiemParse: /|||/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("" === meridiem) return hour < 4 ? hour : hour + 12; else if ("" === meridiem) return hour; else if ("" === meridiem) return hour >= 10 ? hour : hour + 12; else if ("" === meridiem) return hour + 12;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 4) return ""; else if (hour < 10) return ""; else if (hour < 17) return ""; else if (hour < 20) return ""; else return "";
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}()/,
                    ordinal: function(number) {
                        return number + "";
                    },
                    week: {
                        dow: 0,
                        doy: 6
                    }
                });
                return kn;
            }));
        },
        3730: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var ko = moment.defineLocale("ko", {
                    months: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
                    monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "A h:mm",
                        LTS: "A h:mm:ss",
                        L: "YYYY.MM.DD.",
                        LL: "YYYY MMMM D",
                        LLL: "YYYY MMMM D A h:mm",
                        LLLL: "YYYY MMMM D dddd A h:mm",
                        l: "YYYY.MM.DD.",
                        ll: "YYYY MMMM D",
                        lll: "YYYY MMMM D A h:mm",
                        llll: "YYYY MMMM D dddd A h:mm"
                    },
                    calendar: {
                        sameDay: " LT",
                        nextDay: " LT",
                        nextWeek: "dddd LT",
                        lastDay: " LT",
                        lastWeek: " dddd LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s ",
                        past: "%s ",
                        s: " ",
                        ss: "%d",
                        m: "1",
                        mm: "%d",
                        h: " ",
                        hh: "%d",
                        d: "",
                        dd: "%d",
                        M: " ",
                        MM: "%d",
                        y: " ",
                        yy: "%d"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
                    ordinal: function(number, period) {
                        switch (period) {
                          case "d":
                          case "D":
                          case "DDD":
                            return number + "";

                          case "M":
                            return number + "";

                          case "w":
                          case "W":
                            return number + "";

                          default:
                            return number;
                        }
                    },
                    meridiemParse: /|/,
                    isPM: function(token) {
                        return "" === token;
                    },
                    meridiem: function(hour, minute, isUpper) {
                        return hour < 12 ? "" : "";
                    }
                });
                return ko;
            }));
        },
        1408: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var symbolMap = {
                    1: "",
                    2: "",
                    3: "",
                    4: "",
                    5: "",
                    6: "",
                    7: "",
                    8: "",
                    9: "",
                    0: ""
                }, numberMap = {
                    "": "1",
                    "": "2",
                    "": "3",
                    "": "4",
                    "": "5",
                    "": "6",
                    "": "7",
                    "": "8",
                    "": "9",
                    "": "0"
                }, months = [ " ", "", "", "", "", "", "", "", "", " ", " ", " " ];
                var ku = moment.defineLocale("ku", {
                    months,
                    monthsShort: months,
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    meridiemParse: /|/,
                    isPM: function(input) {
                        return //.test(input);
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 12) return ""; else return "";
                    },
                    calendar: {
                        sameDay: "[ ] LT",
                        nextDay: "[ ] LT",
                        nextWeek: "dddd [] LT",
                        lastDay: "[ ] LT",
                        lastWeek: "dddd [] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s",
                        past: "%s",
                        s: " ",
                        ss: " %d",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    preparse: function(string) {
                        return string.replace(/[]/g, (function(match) {
                            return numberMap[match];
                        })).replace(//g, ",");
                    },
                    postformat: function(string) {
                        return string.replace(/\d/g, (function(match) {
                            return symbolMap[match];
                        })).replace(/,/g, "");
                    },
                    week: {
                        dow: 6,
                        doy: 12
                    }
                });
                return ku;
            }));
        },
        3291: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var suffixes = {
                    0: "-",
                    1: "-",
                    2: "-",
                    3: "-",
                    4: "-",
                    5: "-",
                    6: "-",
                    7: "-",
                    8: "-",
                    9: "-",
                    10: "-",
                    20: "-",
                    30: "-",
                    40: "-",
                    50: "-",
                    60: "-",
                    70: "-",
                    80: "-",
                    90: "-",
                    100: "-"
                };
                var ky = moment.defineLocale("ky", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[ ] LT",
                        nextDay: "[ ] LT",
                        nextWeek: "dddd [] LT",
                        lastDay: "[ ] LT",
                        lastWeek: "[ ] dddd [] [] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s ",
                        past: "%s ",
                        s: " ",
                        ss: "%d ",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}-(|||)/,
                    ordinal: function(number) {
                        var a = number % 10, b = number >= 100 ? 100 : null;
                        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
                    },
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return ky;
            }));
        },
        6841: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                function processRelativeTime(number, withoutSuffix, key, isFuture) {
                    var format = {
                        m: [ "eng Minutt", "enger Minutt" ],
                        h: [ "eng Stonn", "enger Stonn" ],
                        d: [ "een Dag", "engem Dag" ],
                        M: [ "ee Mount", "engem Mount" ],
                        y: [ "ee Joer", "engem Joer" ]
                    };
                    return withoutSuffix ? format[key][0] : format[key][1];
                }
                function processFutureTime(string) {
                    var number = string.substr(0, string.indexOf(" "));
                    if (eifelerRegelAppliesToNumber(number)) return "a " + string;
                    return "an " + string;
                }
                function processPastTime(string) {
                    var number = string.substr(0, string.indexOf(" "));
                    if (eifelerRegelAppliesToNumber(number)) return "viru " + string;
                    return "virun " + string;
                }
                function eifelerRegelAppliesToNumber(number) {
                    number = parseInt(number, 10);
                    if (isNaN(number)) return false;
                    if (number < 0) return true; else if (number < 10) {
                        if (4 <= number && number <= 7) return true;
                        return false;
                    } else if (number < 100) {
                        var lastDigit = number % 10, firstDigit = number / 10;
                        if (0 === lastDigit) return eifelerRegelAppliesToNumber(firstDigit);
                        return eifelerRegelAppliesToNumber(lastDigit);
                    } else if (number < 1e4) {
                        while (number >= 10) number /= 10;
                        return eifelerRegelAppliesToNumber(number);
                    } else {
                        number /= 1e3;
                        return eifelerRegelAppliesToNumber(number);
                    }
                }
                var lb = moment.defineLocale("lb", {
                    months: "Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
                    monthsShort: "Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),
                    monthsParseExact: true,
                    weekdays: "Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg".split("_"),
                    weekdaysShort: "So._M._D._M._Do._Fr._Sa.".split("_"),
                    weekdaysMin: "So_M_D_M_Do_Fr_Sa".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "H:mm [Auer]",
                        LTS: "H:mm:ss [Auer]",
                        L: "DD.MM.YYYY",
                        LL: "D. MMMM YYYY",
                        LLL: "D. MMMM YYYY H:mm [Auer]",
                        LLLL: "dddd, D. MMMM YYYY H:mm [Auer]"
                    },
                    calendar: {
                        sameDay: "[Haut um] LT",
                        sameElse: "L",
                        nextDay: "[Muer um] LT",
                        nextWeek: "dddd [um] LT",
                        lastDay: "[Gschter um] LT",
                        lastWeek: function() {
                            switch (this.day()) {
                              case 2:
                              case 4:
                                return "[Leschten] dddd [um] LT";

                              default:
                                return "[Leschte] dddd [um] LT";
                            }
                        }
                    },
                    relativeTime: {
                        future: processFutureTime,
                        past: processPastTime,
                        s: "e puer Sekonnen",
                        ss: "%d Sekonnen",
                        m: processRelativeTime,
                        mm: "%d Minutten",
                        h: processRelativeTime,
                        hh: "%d Stonnen",
                        d: processRelativeTime,
                        dd: "%d Deeg",
                        M: processRelativeTime,
                        MM: "%d Mint",
                        y: processRelativeTime,
                        yy: "%d Joer"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return lb;
            }));
        },
        5466: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var lo = moment.defineLocale("lo", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    meridiemParse: /|/,
                    isPM: function(input) {
                        return "" === input;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 12) return ""; else return "";
                    },
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        nextWeek: "[]dddd[] LT",
                        lastDay: "[] LT",
                        lastWeek: "[]dddd[] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s",
                        past: "%s",
                        s: "",
                        ss: "%d ",
                        m: "1 ",
                        mm: "%d ",
                        h: "1 ",
                        hh: "%d ",
                        d: "1 ",
                        dd: "%d ",
                        M: "1 ",
                        MM: "%d ",
                        y: "1 ",
                        yy: "%d "
                    },
                    dayOfMonthOrdinalParse: /()\d{1,2}/,
                    ordinal: function(number) {
                        return "" + number;
                    }
                });
                return lo;
            }));
        },
        7010: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var units = {
                    ss: "sekund_sekundi_sekundes",
                    m: "minut_minuts_minut",
                    mm: "minuts_minui_minutes",
                    h: "valanda_valandos_valand",
                    hh: "valandos_valand_valandas",
                    d: "diena_dienos_dien",
                    dd: "dienos_dien_dienas",
                    M: "mnuo_mnesio_mnes",
                    MM: "mnesiai_mnesi_mnesius",
                    y: "metai_met_metus",
                    yy: "metai_met_metus"
                };
                function translateSeconds(number, withoutSuffix, key, isFuture) {
                    if (withoutSuffix) return "kelios sekunds"; else return isFuture ? "keli sekundi" : "kelias sekundes";
                }
                function translateSingular(number, withoutSuffix, key, isFuture) {
                    return withoutSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
                }
                function special(number) {
                    return number % 10 === 0 || number > 10 && number < 20;
                }
                function forms(key) {
                    return units[key].split("_");
                }
                function translate(number, withoutSuffix, key, isFuture) {
                    var result = number + " ";
                    if (1 === number) return result + translateSingular(number, withoutSuffix, key[0], isFuture); else if (withoutSuffix) return result + (special(number) ? forms(key)[1] : forms(key)[0]); else if (isFuture) return result + forms(key)[1]; else return result + (special(number) ? forms(key)[1] : forms(key)[2]);
                }
                var lt = moment.defineLocale("lt", {
                    months: {
                        format: "sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio".split("_"),
                        standalone: "sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis".split("_"),
                        isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
                    },
                    monthsShort: "sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd".split("_"),
                    weekdays: {
                        format: "sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien".split("_"),
                        standalone: "sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis".split("_"),
                        isFormat: /dddd HH:mm/
                    },
                    weekdaysShort: "Sek_Pir_Ant_Tre_Ket_Pen_e".split("_"),
                    weekdaysMin: "S_P_A_T_K_Pn_".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "YYYY-MM-DD",
                        LL: "YYYY [m.] MMMM D [d.]",
                        LLL: "YYYY [m.] MMMM D [d.], HH:mm [val.]",
                        LLLL: "YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]",
                        l: "YYYY-MM-DD",
                        ll: "YYYY [m.] MMMM D [d.]",
                        lll: "YYYY [m.] MMMM D [d.], HH:mm [val.]",
                        llll: "YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]"
                    },
                    calendar: {
                        sameDay: "[iandien] LT",
                        nextDay: "[Rytoj] LT",
                        nextWeek: "dddd LT",
                        lastDay: "[Vakar] LT",
                        lastWeek: "[Prajus] dddd LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "po %s",
                        past: "prie %s",
                        s: translateSeconds,
                        ss: translate,
                        m: translateSingular,
                        mm: translate,
                        h: translateSingular,
                        hh: translate,
                        d: translateSingular,
                        dd: translate,
                        M: translateSingular,
                        MM: translate,
                        y: translateSingular,
                        yy: translate
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}-oji/,
                    ordinal: function(number) {
                        return number + "-oji";
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return lt;
            }));
        },
        7595: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var units = {
                    ss: "sekundes_sekundm_sekunde_sekundes".split("_"),
                    m: "mintes_mintm_minte_mintes".split("_"),
                    mm: "mintes_mintm_minte_mintes".split("_"),
                    h: "stundas_stundm_stunda_stundas".split("_"),
                    hh: "stundas_stundm_stunda_stundas".split("_"),
                    d: "dienas_dienm_diena_dienas".split("_"),
                    dd: "dienas_dienm_diena_dienas".split("_"),
                    M: "mnea_mneiem_mnesis_mnei".split("_"),
                    MM: "mnea_mneiem_mnesis_mnei".split("_"),
                    y: "gada_gadiem_gads_gadi".split("_"),
                    yy: "gada_gadiem_gads_gadi".split("_")
                };
                function format(forms, number, withoutSuffix) {
                    if (withoutSuffix) return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3]; else return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
                }
                function relativeTimeWithPlural(number, withoutSuffix, key) {
                    return number + " " + format(units[key], number, withoutSuffix);
                }
                function relativeTimeWithSingular(number, withoutSuffix, key) {
                    return format(units[key], number, withoutSuffix);
                }
                function relativeSeconds(number, withoutSuffix) {
                    return withoutSuffix ? "daas sekundes" : "dam sekundm";
                }
                var lv = moment.defineLocale("lv", {
                    months: "janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris".split("_"),
                    monthsShort: "jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec".split("_"),
                    weekdays: "svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena".split("_"),
                    weekdaysShort: "Sv_P_O_T_C_Pk_S".split("_"),
                    weekdaysMin: "Sv_P_O_T_C_Pk_S".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY.",
                        LL: "YYYY. [gada] D. MMMM",
                        LLL: "YYYY. [gada] D. MMMM, HH:mm",
                        LLLL: "YYYY. [gada] D. MMMM, dddd, HH:mm"
                    },
                    calendar: {
                        sameDay: "[odien pulksten] LT",
                        nextDay: "[Rt pulksten] LT",
                        nextWeek: "dddd [pulksten] LT",
                        lastDay: "[Vakar pulksten] LT",
                        lastWeek: "[Pagju] dddd [pulksten] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "pc %s",
                        past: "pirms %s",
                        s: relativeSeconds,
                        ss: relativeTimeWithPlural,
                        m: relativeTimeWithSingular,
                        mm: relativeTimeWithPlural,
                        h: relativeTimeWithSingular,
                        hh: relativeTimeWithPlural,
                        d: relativeTimeWithSingular,
                        dd: relativeTimeWithPlural,
                        M: relativeTimeWithSingular,
                        MM: relativeTimeWithPlural,
                        y: relativeTimeWithSingular,
                        yy: relativeTimeWithPlural
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return lv;
            }));
        },
        9861: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var translator = {
                    words: {
                        ss: [ "sekund", "sekunda", "sekundi" ],
                        m: [ "jedan minut", "jednog minuta" ],
                        mm: [ "minut", "minuta", "minuta" ],
                        h: [ "jedan sat", "jednog sata" ],
                        hh: [ "sat", "sata", "sati" ],
                        dd: [ "dan", "dana", "dana" ],
                        MM: [ "mjesec", "mjeseca", "mjeseci" ],
                        yy: [ "godina", "godine", "godina" ]
                    },
                    correctGrammaticalCase: function(number, wordKey) {
                        return 1 === number ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
                    },
                    translate: function(number, withoutSuffix, key) {
                        var wordKey = translator.words[key];
                        if (1 === key.length) return withoutSuffix ? wordKey[0] : wordKey[1]; else return number + " " + translator.correctGrammaticalCase(number, wordKey);
                    }
                };
                var me = moment.defineLocale("me", {
                    months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"),
                    monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),
                    monthsParseExact: true,
                    weekdays: "nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota".split("_"),
                    weekdaysShort: "ned._pon._uto._sri._et._pet._sub.".split("_"),
                    weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D. MMMM YYYY",
                        LLL: "D. MMMM YYYY H:mm",
                        LLLL: "dddd, D. MMMM YYYY H:mm"
                    },
                    calendar: {
                        sameDay: "[danas u] LT",
                        nextDay: "[sjutra u] LT",
                        nextWeek: function() {
                            switch (this.day()) {
                              case 0:
                                return "[u] [nedjelju] [u] LT";

                              case 3:
                                return "[u] [srijedu] [u] LT";

                              case 6:
                                return "[u] [subotu] [u] LT";

                              case 1:
                              case 2:
                              case 4:
                              case 5:
                                return "[u] dddd [u] LT";
                            }
                        },
                        lastDay: "[jue u] LT",
                        lastWeek: function() {
                            var lastWeekDays = [ "[prole] [nedjelje] [u] LT", "[prolog] [ponedjeljka] [u] LT", "[prolog] [utorka] [u] LT", "[prole] [srijede] [u] LT", "[prolog] [etvrtka] [u] LT", "[prolog] [petka] [u] LT", "[prole] [subote] [u] LT" ];
                            return lastWeekDays[this.day()];
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "za %s",
                        past: "prije %s",
                        s: "nekoliko sekundi",
                        ss: translator.translate,
                        m: translator.translate,
                        mm: translator.translate,
                        h: translator.translate,
                        hh: translator.translate,
                        d: "dan",
                        dd: translator.translate,
                        M: "mjesec",
                        MM: translator.translate,
                        y: "godinu",
                        yy: translator.translate
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return me;
            }));
        },
        5493: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var mi = moment.defineLocale("mi", {
                    months: "Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea".split("_"),
                    monthsShort: "Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki".split("_"),
                    monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
                    monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
                    monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
                    monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
                    weekdays: "Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei".split("_"),
                    weekdaysShort: "Ta_Ma_T_We_Ti_Pa_H".split("_"),
                    weekdaysMin: "Ta_Ma_T_We_Ti_Pa_H".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY [i] HH:mm",
                        LLLL: "dddd, D MMMM YYYY [i] HH:mm"
                    },
                    calendar: {
                        sameDay: "[i teie mahana, i] LT",
                        nextDay: "[apopo i] LT",
                        nextWeek: "dddd [i] LT",
                        lastDay: "[inanahi i] LT",
                        lastWeek: "dddd [whakamutunga i] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "i roto i %s",
                        past: "%s i mua",
                        s: "te hkona ruarua",
                        ss: "%d hkona",
                        m: "he meneti",
                        mm: "%d meneti",
                        h: "te haora",
                        hh: "%d haora",
                        d: "he ra",
                        dd: "%d ra",
                        M: "he marama",
                        MM: "%d marama",
                        y: "he tau",
                        yy: "%d tau"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: "%d",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return mi;
            }));
        },
        5966: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var mk = moment.defineLocale("mk", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "e_o_____a".split("_"),
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "D.MM.YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY H:mm",
                        LLLL: "dddd, D MMMM YYYY H:mm"
                    },
                    calendar: {
                        sameDay: "[ ] LT",
                        nextDay: "[ ] LT",
                        nextWeek: "[] dddd [] LT",
                        lastDay: "[ ] LT",
                        lastWeek: function() {
                            switch (this.day()) {
                              case 0:
                              case 3:
                              case 6:
                                return "[] dddd [] LT";

                              case 1:
                              case 2:
                              case 4:
                              case 5:
                                return "[] dddd [] LT";
                            }
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s",
                        past: " %s",
                        s: " ",
                        ss: "%d ",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
                    ordinal: function(number) {
                        var lastDigit = number % 10, last2Digits = number % 100;
                        if (0 === number) return number + "-"; else if (0 === last2Digits) return number + "-"; else if (last2Digits > 10 && last2Digits < 20) return number + "-"; else if (1 === lastDigit) return number + "-"; else if (2 === lastDigit) return number + "-"; else if (7 === lastDigit || 8 === lastDigit) return number + "-"; else return number + "-";
                    },
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return mk;
            }));
        },
        7341: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var ml = moment.defineLocale("ml", {
                    months: "___________".split("_"),
                    monthsShort: "._._._.___._._._._._.".split("_"),
                    monthsParseExact: true,
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "A h:mm -",
                        LTS: "A h:mm:ss -",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY, A h:mm -",
                        LLLL: "dddd, D MMMM YYYY, A h:mm -"
                    },
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        nextWeek: "dddd, LT",
                        lastDay: "[] LT",
                        lastWeek: "[] dddd, LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s ",
                        past: "%s ",
                        s: " ",
                        ss: "%d ",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    meridiemParse: /|| ||/i,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("" === meridiem && hour >= 4 || " " === meridiem || "" === meridiem) return hour + 12; else return hour;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 4) return ""; else if (hour < 12) return ""; else if (hour < 17) return " "; else if (hour < 20) return ""; else return "";
                    }
                });
                return ml;
            }));
        },
        5115: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                function translate(number, withoutSuffix, key, isFuture) {
                    switch (key) {
                      case "s":
                        return withoutSuffix ? " " : " ";

                      case "ss":
                        return number + (withoutSuffix ? " " : " ");

                      case "m":
                      case "mm":
                        return number + (withoutSuffix ? " " : " ");

                      case "h":
                      case "hh":
                        return number + (withoutSuffix ? " " : " ");

                      case "d":
                      case "dd":
                        return number + (withoutSuffix ? " " : " ");

                      case "M":
                      case "MM":
                        return number + (withoutSuffix ? " " : " ");

                      case "y":
                      case "yy":
                        return number + (withoutSuffix ? " " : " ");

                      default:
                        return number;
                    }
                }
                var mn = moment.defineLocale("mn", {
                    months: " _ _ _ _ _ _ _ _ _ _  _  ".split("_"),
                    monthsShort: "1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11 _12 ".split("_"),
                    monthsParseExact: true,
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "YYYY-MM-DD",
                        LL: "YYYY  MMMM D",
                        LLL: "YYYY  MMMM D HH:mm",
                        LLLL: "dddd, YYYY  MMMM D HH:mm"
                    },
                    meridiemParse: /|/i,
                    isPM: function(input) {
                        return "" === input;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 12) return ""; else return "";
                    },
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        nextWeek: "[] dddd LT",
                        lastDay: "[] LT",
                        lastWeek: "[] dddd LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s ",
                        past: "%s ",
                        s: translate,
                        ss: translate,
                        m: translate,
                        mm: translate,
                        h: translate,
                        hh: translate,
                        d: translate,
                        dd: translate,
                        M: translate,
                        MM: translate,
                        y: translate,
                        yy: translate
                    },
                    dayOfMonthOrdinalParse: /\d{1,2} /,
                    ordinal: function(number, period) {
                        switch (period) {
                          case "d":
                          case "D":
                          case "DDD":
                            return number + " ";

                          default:
                            return number;
                        }
                    }
                });
                return mn;
            }));
        },
        370: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var symbolMap = {
                    1: "",
                    2: "",
                    3: "",
                    4: "",
                    5: "",
                    6: "",
                    7: "",
                    8: "",
                    9: "",
                    0: ""
                }, numberMap = {
                    "": "1",
                    "": "2",
                    "": "3",
                    "": "4",
                    "": "5",
                    "": "6",
                    "": "7",
                    "": "8",
                    "": "9",
                    "": "0"
                };
                function relativeTimeMr(number, withoutSuffix, string, isFuture) {
                    var output = "";
                    if (withoutSuffix) switch (string) {
                      case "s":
                        output = " ";
                        break;

                      case "ss":
                        output = "%d ";
                        break;

                      case "m":
                        output = " ";
                        break;

                      case "mm":
                        output = "%d ";
                        break;

                      case "h":
                        output = " ";
                        break;

                      case "hh":
                        output = "%d ";
                        break;

                      case "d":
                        output = " ";
                        break;

                      case "dd":
                        output = "%d ";
                        break;

                      case "M":
                        output = " ";
                        break;

                      case "MM":
                        output = "%d ";
                        break;

                      case "y":
                        output = " ";
                        break;

                      case "yy":
                        output = "%d ";
                        break;
                    } else switch (string) {
                      case "s":
                        output = " ";
                        break;

                      case "ss":
                        output = "%d ";
                        break;

                      case "m":
                        output = " ";
                        break;

                      case "mm":
                        output = "%d ";
                        break;

                      case "h":
                        output = " ";
                        break;

                      case "hh":
                        output = "%d ";
                        break;

                      case "d":
                        output = " ";
                        break;

                      case "dd":
                        output = "%d ";
                        break;

                      case "M":
                        output = " ";
                        break;

                      case "MM":
                        output = "%d ";
                        break;

                      case "y":
                        output = " ";
                        break;

                      case "yy":
                        output = "%d ";
                        break;
                    }
                    return output.replace(/%d/i, number);
                }
                var mr = moment.defineLocale("mr", {
                    months: "___________".split("_"),
                    monthsShort: "._._._._._._._._._._._.".split("_"),
                    monthsParseExact: true,
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "A h:mm ",
                        LTS: "A h:mm:ss ",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY, A h:mm ",
                        LLLL: "dddd, D MMMM YYYY, A h:mm "
                    },
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        nextWeek: "dddd, LT",
                        lastDay: "[] LT",
                        lastWeek: "[] dddd, LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s",
                        past: "%s",
                        s: relativeTimeMr,
                        ss: relativeTimeMr,
                        m: relativeTimeMr,
                        mm: relativeTimeMr,
                        h: relativeTimeMr,
                        hh: relativeTimeMr,
                        d: relativeTimeMr,
                        dd: relativeTimeMr,
                        M: relativeTimeMr,
                        MM: relativeTimeMr,
                        y: relativeTimeMr,
                        yy: relativeTimeMr
                    },
                    preparse: function(string) {
                        return string.replace(/[]/g, (function(match) {
                            return numberMap[match];
                        }));
                    },
                    postformat: function(string) {
                        return string.replace(/\d/g, (function(match) {
                            return symbolMap[match];
                        }));
                    },
                    meridiemParse: /||||/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("" === meridiem || "" === meridiem) return hour; else if ("" === meridiem || "" === meridiem || "" === meridiem) return hour >= 12 ? hour : hour + 12;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour >= 0 && hour < 6) return ""; else if (hour < 12) return ""; else if (hour < 17) return ""; else if (hour < 20) return ""; else return "";
                    },
                    week: {
                        dow: 0,
                        doy: 6
                    }
                });
                return mr;
            }));
        },
        1237: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var msMy = moment.defineLocale("ms-my", {
                    months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),
                    monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
                    weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
                    weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
                    weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
                    longDateFormat: {
                        LT: "HH.mm",
                        LTS: "HH.mm.ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY [pukul] HH.mm",
                        LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
                    },
                    meridiemParse: /pagi|tengahari|petang|malam/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("pagi" === meridiem) return hour; else if ("tengahari" === meridiem) return hour >= 11 ? hour : hour + 12; else if ("petang" === meridiem || "malam" === meridiem) return hour + 12;
                    },
                    meridiem: function(hours, minutes, isLower) {
                        if (hours < 11) return "pagi"; else if (hours < 15) return "tengahari"; else if (hours < 19) return "petang"; else return "malam";
                    },
                    calendar: {
                        sameDay: "[Hari ini pukul] LT",
                        nextDay: "[Esok pukul] LT",
                        nextWeek: "dddd [pukul] LT",
                        lastDay: "[Kelmarin pukul] LT",
                        lastWeek: "dddd [lepas pukul] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "dalam %s",
                        past: "%s yang lepas",
                        s: "beberapa saat",
                        ss: "%d saat",
                        m: "seminit",
                        mm: "%d minit",
                        h: "sejam",
                        hh: "%d jam",
                        d: "sehari",
                        dd: "%d hari",
                        M: "sebulan",
                        MM: "%d bulan",
                        y: "setahun",
                        yy: "%d tahun"
                    },
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return msMy;
            }));
        },
        9847: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var ms = moment.defineLocale("ms", {
                    months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),
                    monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
                    weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
                    weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
                    weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
                    longDateFormat: {
                        LT: "HH.mm",
                        LTS: "HH.mm.ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY [pukul] HH.mm",
                        LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
                    },
                    meridiemParse: /pagi|tengahari|petang|malam/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("pagi" === meridiem) return hour; else if ("tengahari" === meridiem) return hour >= 11 ? hour : hour + 12; else if ("petang" === meridiem || "malam" === meridiem) return hour + 12;
                    },
                    meridiem: function(hours, minutes, isLower) {
                        if (hours < 11) return "pagi"; else if (hours < 15) return "tengahari"; else if (hours < 19) return "petang"; else return "malam";
                    },
                    calendar: {
                        sameDay: "[Hari ini pukul] LT",
                        nextDay: "[Esok pukul] LT",
                        nextWeek: "dddd [pukul] LT",
                        lastDay: "[Kelmarin pukul] LT",
                        lastWeek: "dddd [lepas pukul] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "dalam %s",
                        past: "%s yang lepas",
                        s: "beberapa saat",
                        ss: "%d saat",
                        m: "seminit",
                        mm: "%d minit",
                        h: "sejam",
                        hh: "%d jam",
                        d: "sehari",
                        dd: "%d hari",
                        M: "sebulan",
                        MM: "%d bulan",
                        y: "setahun",
                        yy: "%d tahun"
                    },
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return ms;
            }));
        },
        2126: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var mt = moment.defineLocale("mt", {
                    months: "Jannar_Frar_Marzu_April_Mejju_unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diembru".split("_"),
                    monthsShort: "Jan_Fra_Mar_Apr_Mej_un_Lul_Aww_Set_Ott_Nov_Di".split("_"),
                    weekdays: "Il-add_It-Tnejn_It-Tlieta_L-Erbga_Il-amis_Il-imga_Is-Sibt".split("_"),
                    weekdaysShort: "ad_Tne_Tli_Erb_am_im_Sib".split("_"),
                    weekdaysMin: "a_Tn_Tl_Er_a_i_Si".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[Illum fil-]LT",
                        nextDay: "[Gada fil-]LT",
                        nextWeek: "dddd [fil-]LT",
                        lastDay: "[Il-biera fil-]LT",
                        lastWeek: "dddd [li gadda] [fil-]LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "f %s",
                        past: "%s ilu",
                        s: "ftit sekondi",
                        ss: "%d sekondi",
                        m: "minuta",
                        mm: "%d minuti",
                        h: "siega",
                        hh: "%d siegat",
                        d: "urnata",
                        dd: "%d ranet",
                        M: "xahar",
                        MM: "%d xhur",
                        y: "sena",
                        yy: "%d sni"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: "%d",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return mt;
            }));
        },
        6165: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var symbolMap = {
                    1: "",
                    2: "",
                    3: "",
                    4: "",
                    5: "",
                    6: "",
                    7: "",
                    8: "",
                    9: "",
                    0: ""
                }, numberMap = {
                    "": "1",
                    "": "2",
                    "": "3",
                    "": "4",
                    "": "5",
                    "": "6",
                    "": "7",
                    "": "8",
                    "": "9",
                    "": "0"
                };
                var my = moment.defineLocale("my", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[.] LT []",
                        nextDay: "[] LT []",
                        nextWeek: "dddd LT []",
                        lastDay: "[.] LT []",
                        lastWeek: "[] dddd LT []",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s ",
                        past: " %s ",
                        s: ".",
                        ss: "%d ",
                        m: "",
                        mm: "%d ",
                        h: "",
                        hh: "%d ",
                        d: "",
                        dd: "%d ",
                        M: "",
                        MM: "%d ",
                        y: "",
                        yy: "%d "
                    },
                    preparse: function(string) {
                        return string.replace(/[]/g, (function(match) {
                            return numberMap[match];
                        }));
                    },
                    postformat: function(string) {
                        return string.replace(/\d/g, (function(match) {
                            return symbolMap[match];
                        }));
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return my;
            }));
        },
        4924: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var nb = moment.defineLocale("nb", {
                    months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),
                    monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"),
                    monthsParseExact: true,
                    weekdays: "sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag".split("_"),
                    weekdaysShort: "s._ma._ti._on._to._fr._l.".split("_"),
                    weekdaysMin: "s_ma_ti_on_to_fr_l".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D. MMMM YYYY",
                        LLL: "D. MMMM YYYY [kl.] HH:mm",
                        LLLL: "dddd D. MMMM YYYY [kl.] HH:mm"
                    },
                    calendar: {
                        sameDay: "[i dag kl.] LT",
                        nextDay: "[i morgen kl.] LT",
                        nextWeek: "dddd [kl.] LT",
                        lastDay: "[i gr kl.] LT",
                        lastWeek: "[forrige] dddd [kl.] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "om %s",
                        past: "%s siden",
                        s: "noen sekunder",
                        ss: "%d sekunder",
                        m: "ett minutt",
                        mm: "%d minutter",
                        h: "en time",
                        hh: "%d timer",
                        d: "en dag",
                        dd: "%d dager",
                        w: "en uke",
                        ww: "%d uker",
                        M: "en mned",
                        MM: "%d mneder",
                        y: "ett r",
                        yy: "%d r"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return nb;
            }));
        },
        6744: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var symbolMap = {
                    1: "",
                    2: "",
                    3: "",
                    4: "",
                    5: "",
                    6: "",
                    7: "",
                    8: "",
                    9: "",
                    0: ""
                }, numberMap = {
                    "": "1",
                    "": "2",
                    "": "3",
                    "": "4",
                    "": "5",
                    "": "6",
                    "": "7",
                    "": "8",
                    "": "9",
                    "": "0"
                };
                var ne = moment.defineLocale("ne", {
                    months: "___________".split("_"),
                    monthsShort: "._.__.___._._._._._.".split("_"),
                    monthsParseExact: true,
                    weekdays: "______".split("_"),
                    weekdaysShort: "._._._._._._.".split("_"),
                    weekdaysMin: "._._._._._._.".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "A h:mm ",
                        LTS: "A h:mm:ss ",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY, A h:mm ",
                        LLLL: "dddd, D MMMM YYYY, A h:mm "
                    },
                    preparse: function(string) {
                        return string.replace(/[]/g, (function(match) {
                            return numberMap[match];
                        }));
                    },
                    postformat: function(string) {
                        return string.replace(/\d/g, (function(match) {
                            return symbolMap[match];
                        }));
                    },
                    meridiemParse: /|||/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("" === meridiem) return hour < 4 ? hour : hour + 12; else if ("" === meridiem) return hour; else if ("" === meridiem) return hour >= 10 ? hour : hour + 12; else if ("" === meridiem) return hour + 12;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 3) return ""; else if (hour < 12) return ""; else if (hour < 16) return ""; else if (hour < 20) return ""; else return "";
                    },
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        nextWeek: "[] dddd[,] LT",
                        lastDay: "[] LT",
                        lastWeek: "[] dddd[,] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s",
                        past: "%s ",
                        s: " ",
                        ss: "%d ",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    week: {
                        dow: 0,
                        doy: 6
                    }
                });
                return ne;
            }));
        },
        9814: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var monthsShortWithDots = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), monthsShortWithoutDots = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), monthsParse = [ /^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i ], monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
                var nlBe = moment.defineLocale("nl-be", {
                    months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),
                    monthsShort: function(m, format) {
                        if (!m) return monthsShortWithDots; else if (/-MMM-/.test(format)) return monthsShortWithoutDots[m.month()]; else return monthsShortWithDots[m.month()];
                    },
                    monthsRegex,
                    monthsShortRegex: monthsRegex,
                    monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
                    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
                    monthsParse,
                    longMonthsParse: monthsParse,
                    shortMonthsParse: monthsParse,
                    weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
                    weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
                    weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[vandaag om] LT",
                        nextDay: "[morgen om] LT",
                        nextWeek: "dddd [om] LT",
                        lastDay: "[gisteren om] LT",
                        lastWeek: "[afgelopen] dddd [om] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "over %s",
                        past: "%s geleden",
                        s: "een paar seconden",
                        ss: "%d seconden",
                        m: "n minuut",
                        mm: "%d minuten",
                        h: "n uur",
                        hh: "%d uur",
                        d: "n dag",
                        dd: "%d dagen",
                        M: "n maand",
                        MM: "%d maanden",
                        y: "n jaar",
                        yy: "%d jaar"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
                    ordinal: function(number) {
                        return number + (1 === number || 8 === number || number >= 20 ? "ste" : "de");
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return nlBe;
            }));
        },
        3901: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var monthsShortWithDots = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), monthsShortWithoutDots = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), monthsParse = [ /^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i ], monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
                var nl = moment.defineLocale("nl", {
                    months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),
                    monthsShort: function(m, format) {
                        if (!m) return monthsShortWithDots; else if (/-MMM-/.test(format)) return monthsShortWithoutDots[m.month()]; else return monthsShortWithDots[m.month()];
                    },
                    monthsRegex,
                    monthsShortRegex: monthsRegex,
                    monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
                    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
                    monthsParse,
                    longMonthsParse: monthsParse,
                    shortMonthsParse: monthsParse,
                    weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
                    weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
                    weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD-MM-YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[vandaag om] LT",
                        nextDay: "[morgen om] LT",
                        nextWeek: "dddd [om] LT",
                        lastDay: "[gisteren om] LT",
                        lastWeek: "[afgelopen] dddd [om] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "over %s",
                        past: "%s geleden",
                        s: "een paar seconden",
                        ss: "%d seconden",
                        m: "n minuut",
                        mm: "%d minuten",
                        h: "n uur",
                        hh: "%d uur",
                        d: "n dag",
                        dd: "%d dagen",
                        w: "n week",
                        ww: "%d weken",
                        M: "n maand",
                        MM: "%d maanden",
                        y: "n jaar",
                        yy: "%d jaar"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
                    ordinal: function(number) {
                        return number + (1 === number || 8 === number || number >= 20 ? "ste" : "de");
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return nl;
            }));
        },
        3877: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var nn = moment.defineLocale("nn", {
                    months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),
                    monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"),
                    monthsParseExact: true,
                    weekdays: "sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag".split("_"),
                    weekdaysShort: "su._m._ty._on._to._fr._lau.".split("_"),
                    weekdaysMin: "su_m_ty_on_to_fr_la".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D. MMMM YYYY",
                        LLL: "D. MMMM YYYY [kl.] H:mm",
                        LLLL: "dddd D. MMMM YYYY [kl.] HH:mm"
                    },
                    calendar: {
                        sameDay: "[I dag klokka] LT",
                        nextDay: "[I morgon klokka] LT",
                        nextWeek: "dddd [klokka] LT",
                        lastDay: "[I gr klokka] LT",
                        lastWeek: "[Fregande] dddd [klokka] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "om %s",
                        past: "%s sidan",
                        s: "nokre sekund",
                        ss: "%d sekund",
                        m: "eit minutt",
                        mm: "%d minutt",
                        h: "ein time",
                        hh: "%d timar",
                        d: "ein dag",
                        dd: "%d dagar",
                        w: "ei veke",
                        ww: "%d veker",
                        M: "ein mnad",
                        MM: "%d mnader",
                        y: "eit r",
                        yy: "%d r"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return nn;
            }));
        },
        2135: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var ocLnc = moment.defineLocale("oc-lnc", {
                    months: {
                        standalone: "genir_febrir_mar_abril_mai_junh_julhet_agost_setembre_octbre_novembre_decembre".split("_"),
                        format: "de genir_de febrir_de mar_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'octbre_de novembre_de decembre".split("_"),
                        isFormat: /D[oD]?(\s)+MMMM/
                    },
                    monthsShort: "gen._febr._mar_abr._mai_junh_julh._ago._set._oct._nov._dec.".split("_"),
                    monthsParseExact: true,
                    weekdays: "dimenge_diluns_dimars_dimcres_dijus_divendres_dissabte".split("_"),
                    weekdaysShort: "dg._dl._dm._dc._dj._dv._ds.".split("_"),
                    weekdaysMin: "dg_dl_dm_dc_dj_dv_ds".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM [de] YYYY",
                        ll: "D MMM YYYY",
                        LLL: "D MMMM [de] YYYY [a] H:mm",
                        lll: "D MMM YYYY, H:mm",
                        LLLL: "dddd D MMMM [de] YYYY [a] H:mm",
                        llll: "ddd D MMM YYYY, H:mm"
                    },
                    calendar: {
                        sameDay: "[ui a] LT",
                        nextDay: "[deman a] LT",
                        nextWeek: "dddd [a] LT",
                        lastDay: "[ir a] LT",
                        lastWeek: "dddd [passat a] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "d'aqu %s",
                        past: "fa %s",
                        s: "unas segondas",
                        ss: "%d segondas",
                        m: "una minuta",
                        mm: "%d minutas",
                        h: "una ora",
                        hh: "%d oras",
                        d: "un jorn",
                        dd: "%d jorns",
                        M: "un mes",
                        MM: "%d meses",
                        y: "un an",
                        yy: "%d ans"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
                    ordinal: function(number, period) {
                        var output = 1 === number ? "r" : 2 === number ? "n" : 3 === number ? "r" : 4 === number ? "t" : "";
                        if ("w" === period || "W" === period) output = "a";
                        return number + output;
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return ocLnc;
            }));
        },
        5858: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var symbolMap = {
                    1: "",
                    2: "",
                    3: "",
                    4: "",
                    5: "",
                    6: "",
                    7: "",
                    8: "",
                    9: "",
                    0: ""
                }, numberMap = {
                    "": "1",
                    "": "2",
                    "": "3",
                    "": "4",
                    "": "5",
                    "": "6",
                    "": "7",
                    "": "8",
                    "": "9",
                    "": "0"
                };
                var paIn = moment.defineLocale("pa-in", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "A h:mm ",
                        LTS: "A h:mm:ss ",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY, A h:mm ",
                        LLLL: "dddd, D MMMM YYYY, A h:mm "
                    },
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        nextWeek: "[] dddd, LT",
                        lastDay: "[] LT",
                        lastWeek: "[] dddd, LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s ",
                        past: "%s ",
                        s: " ",
                        ss: "%d ",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    preparse: function(string) {
                        return string.replace(/[]/g, (function(match) {
                            return numberMap[match];
                        }));
                    },
                    postformat: function(string) {
                        return string.replace(/\d/g, (function(match) {
                            return symbolMap[match];
                        }));
                    },
                    meridiemParse: /|||/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("" === meridiem) return hour < 4 ? hour : hour + 12; else if ("" === meridiem) return hour; else if ("" === meridiem) return hour >= 10 ? hour : hour + 12; else if ("" === meridiem) return hour + 12;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 4) return ""; else if (hour < 10) return ""; else if (hour < 17) return ""; else if (hour < 20) return ""; else return "";
                    },
                    week: {
                        dow: 0,
                        doy: 6
                    }
                });
                return paIn;
            }));
        },
        4495: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var monthsNominative = "stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie".split("_"), monthsSubjective = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia".split("_"), monthsParse = [ /^sty/i, /^lut/i, /^mar/i, /^kwi/i, /^maj/i, /^cze/i, /^lip/i, /^sie/i, /^wrz/i, /^pa/i, /^lis/i, /^gru/i ];
                function plural(n) {
                    return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1;
                }
                function translate(number, withoutSuffix, key) {
                    var result = number + " ";
                    switch (key) {
                      case "ss":
                        return result + (plural(number) ? "sekundy" : "sekund");

                      case "m":
                        return withoutSuffix ? "minuta" : "minut";

                      case "mm":
                        return result + (plural(number) ? "minuty" : "minut");

                      case "h":
                        return withoutSuffix ? "godzina" : "godzin";

                      case "hh":
                        return result + (plural(number) ? "godziny" : "godzin");

                      case "ww":
                        return result + (plural(number) ? "tygodnie" : "tygodni");

                      case "MM":
                        return result + (plural(number) ? "miesice" : "miesicy");

                      case "yy":
                        return result + (plural(number) ? "lata" : "lat");
                    }
                }
                var pl = moment.defineLocale("pl", {
                    months: function(momentToFormat, format) {
                        if (!momentToFormat) return monthsNominative; else if (/D MMMM/.test(format)) return monthsSubjective[momentToFormat.month()]; else return monthsNominative[momentToFormat.month()];
                    },
                    monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru".split("_"),
                    monthsParse,
                    longMonthsParse: monthsParse,
                    shortMonthsParse: monthsParse,
                    weekdays: "niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota".split("_"),
                    weekdaysShort: "ndz_pon_wt_r_czw_pt_sob".split("_"),
                    weekdaysMin: "Nd_Pn_Wt_r_Cz_Pt_So".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[Dzi o] LT",
                        nextDay: "[Jutro o] LT",
                        nextWeek: function() {
                            switch (this.day()) {
                              case 0:
                                return "[W niedziel o] LT";

                              case 2:
                                return "[We wtorek o] LT";

                              case 3:
                                return "[W rod o] LT";

                              case 6:
                                return "[W sobot o] LT";

                              default:
                                return "[W] dddd [o] LT";
                            }
                        },
                        lastDay: "[Wczoraj o] LT",
                        lastWeek: function() {
                            switch (this.day()) {
                              case 0:
                                return "[W zesz niedziel o] LT";

                              case 3:
                                return "[W zesz rod o] LT";

                              case 6:
                                return "[W zesz sobot o] LT";

                              default:
                                return "[W zeszy] dddd [o] LT";
                            }
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "za %s",
                        past: "%s temu",
                        s: "kilka sekund",
                        ss: translate,
                        m: translate,
                        mm: translate,
                        h: translate,
                        hh: translate,
                        d: "1 dzie",
                        dd: "%d dni",
                        w: "tydzie",
                        ww: translate,
                        M: "miesic",
                        MM: translate,
                        y: "rok",
                        yy: translate
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return pl;
            }));
        },
        7971: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var ptBr = moment.defineLocale("pt-br", {
                    months: "janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),
                    monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
                    weekdays: "domingo_segunda-feira_tera-feira_quarta-feira_quinta-feira_sexta-feira_sbado".split("_"),
                    weekdaysShort: "dom_seg_ter_qua_qui_sex_sb".split("_"),
                    weekdaysMin: "do_2_3_4_5_6_s".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D [de] MMMM [de] YYYY",
                        LLL: "D [de] MMMM [de] YYYY [s] HH:mm",
                        LLLL: "dddd, D [de] MMMM [de] YYYY [s] HH:mm"
                    },
                    calendar: {
                        sameDay: "[Hoje s] LT",
                        nextDay: "[Amanh s] LT",
                        nextWeek: "dddd [s] LT",
                        lastDay: "[Ontem s] LT",
                        lastWeek: function() {
                            return 0 === this.day() || 6 === this.day() ? "[ltimo] dddd [s] LT" : "[ltima] dddd [s] LT";
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "em %s",
                        past: "h %s",
                        s: "poucos segundos",
                        ss: "%d segundos",
                        m: "um minuto",
                        mm: "%d minutos",
                        h: "uma hora",
                        hh: "%d horas",
                        d: "um dia",
                        dd: "%d dias",
                        M: "um ms",
                        MM: "%d meses",
                        y: "um ano",
                        yy: "%d anos"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: "%d",
                    invalidDate: "Data invlida"
                });
                return ptBr;
            }));
        },
        9520: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var pt = moment.defineLocale("pt", {
                    months: "janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),
                    monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
                    weekdays: "Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado".split("_"),
                    weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_Sb".split("_"),
                    weekdaysMin: "Do_2_3_4_5_6_S".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D [de] MMMM [de] YYYY",
                        LLL: "D [de] MMMM [de] YYYY HH:mm",
                        LLLL: "dddd, D [de] MMMM [de] YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[Hoje s] LT",
                        nextDay: "[Amanh s] LT",
                        nextWeek: "dddd [s] LT",
                        lastDay: "[Ontem s] LT",
                        lastWeek: function() {
                            return 0 === this.day() || 6 === this.day() ? "[ltimo] dddd [s] LT" : "[ltima] dddd [s] LT";
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "em %s",
                        past: "h %s",
                        s: "segundos",
                        ss: "%d segundos",
                        m: "um minuto",
                        mm: "%d minutos",
                        h: "uma hora",
                        hh: "%d horas",
                        d: "um dia",
                        dd: "%d dias",
                        w: "uma semana",
                        ww: "%d semanas",
                        M: "um ms",
                        MM: "%d meses",
                        y: "um ano",
                        yy: "%d anos"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: "%d",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return pt;
            }));
        },
        6459: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                function relativeTimeWithPlural(number, withoutSuffix, key) {
                    var format = {
                        ss: "secunde",
                        mm: "minute",
                        hh: "ore",
                        dd: "zile",
                        ww: "sptmni",
                        MM: "luni",
                        yy: "ani"
                    }, separator = " ";
                    if (number % 100 >= 20 || number >= 100 && number % 100 === 0) separator = " de ";
                    return number + separator + format[key];
                }
                var ro = moment.defineLocale("ro", {
                    months: "ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie".split("_"),
                    monthsShort: "ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.".split("_"),
                    monthsParseExact: true,
                    weekdays: "duminic_luni_mari_miercuri_joi_vineri_smbt".split("_"),
                    weekdaysShort: "Dum_Lun_Mar_Mie_Joi_Vin_Sm".split("_"),
                    weekdaysMin: "Du_Lu_Ma_Mi_Jo_Vi_S".split("_"),
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY H:mm",
                        LLLL: "dddd, D MMMM YYYY H:mm"
                    },
                    calendar: {
                        sameDay: "[azi la] LT",
                        nextDay: "[mine la] LT",
                        nextWeek: "dddd [la] LT",
                        lastDay: "[ieri la] LT",
                        lastWeek: "[fosta] dddd [la] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "peste %s",
                        past: "%s n urm",
                        s: "cteva secunde",
                        ss: relativeTimeWithPlural,
                        m: "un minut",
                        mm: relativeTimeWithPlural,
                        h: "o or",
                        hh: relativeTimeWithPlural,
                        d: "o zi",
                        dd: relativeTimeWithPlural,
                        w: "o sptmn",
                        ww: relativeTimeWithPlural,
                        M: "o lun",
                        MM: relativeTimeWithPlural,
                        y: "un an",
                        yy: relativeTimeWithPlural
                    },
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return ro;
            }));
        },
        1793: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                function plural(word, num) {
                    var forms = word.split("_");
                    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
                }
                function relativeTimeWithPlural(number, withoutSuffix, key) {
                    var format = {
                        ss: withoutSuffix ? "__" : "__",
                        mm: withoutSuffix ? "__" : "__",
                        hh: "__",
                        dd: "__",
                        ww: "__",
                        MM: "__",
                        yy: "__"
                    };
                    if ("m" === key) return withoutSuffix ? "" : ""; else return number + " " + plural(format[key], +number);
                }
                var monthsParse = [ /^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i ];
                var ru = moment.defineLocale("ru", {
                    months: {
                        format: "___________".split("_"),
                        standalone: "___________".split("_")
                    },
                    monthsShort: {
                        format: "._._._.____._._._._.".split("_"),
                        standalone: "._.__.____._._._._.".split("_")
                    },
                    weekdays: {
                        standalone: "______".split("_"),
                        format: "______".split("_"),
                        isFormat: /\[ ?[] ?(?:||)? ?] ?dddd/
                    },
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    monthsParse,
                    longMonthsParse: monthsParse,
                    shortMonthsParse: monthsParse,
                    monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
                    monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
                    monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,
                    monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D MMMM YYYY .",
                        LLL: "D MMMM YYYY ., H:mm",
                        LLLL: "dddd, D MMMM YYYY ., H:mm"
                    },
                    calendar: {
                        sameDay: "[, ] LT",
                        nextDay: "[, ] LT",
                        lastDay: "[, ] LT",
                        nextWeek: function(now) {
                            if (now.week() !== this.week()) switch (this.day()) {
                              case 0:
                                return "[ ] dddd, [] LT";

                              case 1:
                              case 2:
                              case 4:
                                return "[ ] dddd, [] LT";

                              case 3:
                              case 5:
                              case 6:
                                return "[ ] dddd, [] LT";
                            } else if (2 === this.day()) return "[] dddd, [] LT"; else return "[] dddd, [] LT";
                        },
                        lastWeek: function(now) {
                            if (now.week() !== this.week()) switch (this.day()) {
                              case 0:
                                return "[ ] dddd, [] LT";

                              case 1:
                              case 2:
                              case 4:
                                return "[ ] dddd, [] LT";

                              case 3:
                              case 5:
                              case 6:
                                return "[ ] dddd, [] LT";
                            } else if (2 === this.day()) return "[] dddd, [] LT"; else return "[] dddd, [] LT";
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s",
                        past: "%s ",
                        s: " ",
                        ss: relativeTimeWithPlural,
                        m: relativeTimeWithPlural,
                        mm: relativeTimeWithPlural,
                        h: "",
                        hh: relativeTimeWithPlural,
                        d: "",
                        dd: relativeTimeWithPlural,
                        w: "",
                        ww: relativeTimeWithPlural,
                        M: "",
                        MM: relativeTimeWithPlural,
                        y: "",
                        yy: relativeTimeWithPlural
                    },
                    meridiemParse: /|||/i,
                    isPM: function(input) {
                        return /^(|)$/.test(input);
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 4) return ""; else if (hour < 12) return ""; else if (hour < 17) return ""; else return "";
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
                    ordinal: function(number, period) {
                        switch (period) {
                          case "M":
                          case "d":
                          case "DDD":
                            return number + "-";

                          case "D":
                            return number + "-";

                          case "w":
                          case "W":
                            return number + "-";

                          default:
                            return number;
                        }
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return ru;
            }));
        },
        950: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var months = [ "", "", "", "", "", "", "", "", "", "", "", "" ], days = [ "", "", "", "", "", "", "" ];
                var sd = moment.defineLocale("sd", {
                    months,
                    monthsShort: months,
                    weekdays: days,
                    weekdaysShort: days,
                    weekdaysMin: days,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    meridiemParse: /|/,
                    isPM: function(input) {
                        return "" === input;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 12) return "";
                        return "";
                    },
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        nextWeek: "dddd [  ] LT",
                        lastDay: "[] LT",
                        lastWeek: "[ ] dddd [] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s ",
                        past: "%s ",
                        s: " ",
                        ss: "%d ",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    preparse: function(string) {
                        return string.replace(//g, ",");
                    },
                    postformat: function(string) {
                        return string.replace(/,/g, "");
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return sd;
            }));
        },
        490: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var se = moment.defineLocale("se", {
                    months: "oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu".split("_"),
                    monthsShort: "oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov".split("_"),
                    weekdays: "sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat".split("_"),
                    weekdaysShort: "sotn_vuos_ma_gask_duor_bear_lv".split("_"),
                    weekdaysMin: "s_v_m_g_d_b_L".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "MMMM D. [b.] YYYY",
                        LLL: "MMMM D. [b.] YYYY [ti.] HH:mm",
                        LLLL: "dddd, MMMM D. [b.] YYYY [ti.] HH:mm"
                    },
                    calendar: {
                        sameDay: "[otne ti] LT",
                        nextDay: "[ihttin ti] LT",
                        nextWeek: "dddd [ti] LT",
                        lastDay: "[ikte ti] LT",
                        lastWeek: "[ovddit] dddd [ti] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s geaes",
                        past: "mait %s",
                        s: "moadde sekunddat",
                        ss: "%d sekunddat",
                        m: "okta minuhta",
                        mm: "%d minuhtat",
                        h: "okta diimmu",
                        hh: "%d diimmut",
                        d: "okta beaivi",
                        dd: "%d beaivvit",
                        M: "okta mnnu",
                        MM: "%d mnut",
                        y: "okta jahki",
                        yy: "%d jagit"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return se;
            }));
        },
        124: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var si = moment.defineLocale("si", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "a h:mm",
                        LTS: "a h:mm:ss",
                        L: "YYYY/MM/DD",
                        LL: "YYYY MMMM D",
                        LLL: "YYYY MMMM D, a h:mm",
                        LLLL: "YYYY MMMM D [] dddd, a h:mm:ss"
                    },
                    calendar: {
                        sameDay: "[] LT[]",
                        nextDay: "[] LT[]",
                        nextWeek: "dddd LT[]",
                        lastDay: "[] LT[]",
                        lastWeek: "[] dddd LT[]",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s",
                        past: "%s ",
                        s: " ",
                        ss: " %d",
                        m: "",
                        mm: " %d",
                        h: "",
                        hh: " %d",
                        d: "",
                        dd: " %d",
                        M: "",
                        MM: " %d",
                        y: "",
                        yy: " %d"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2} /,
                    ordinal: function(number) {
                        return number + " ";
                    },
                    meridiemParse: / | |.|../,
                    isPM: function(input) {
                        return ".." === input || " " === input;
                    },
                    meridiem: function(hours, minutes, isLower) {
                        if (hours > 11) return isLower ? ".." : " "; else return isLower ? ".." : " ";
                    }
                });
                return si;
            }));
        },
        4249: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var months = "janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december".split("_"), monthsShort = "jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec".split("_");
                function plural(n) {
                    return n > 1 && n < 5;
                }
                function translate(number, withoutSuffix, key, isFuture) {
                    var result = number + " ";
                    switch (key) {
                      case "s":
                        return withoutSuffix || isFuture ? "pr seknd" : "pr sekundami";

                      case "ss":
                        if (withoutSuffix || isFuture) return result + (plural(number) ? "sekundy" : "seknd"); else return result + "sekundami";

                      case "m":
                        return withoutSuffix ? "minta" : isFuture ? "mintu" : "mintou";

                      case "mm":
                        if (withoutSuffix || isFuture) return result + (plural(number) ? "minty" : "mint"); else return result + "mintami";

                      case "h":
                        return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";

                      case "hh":
                        if (withoutSuffix || isFuture) return result + (plural(number) ? "hodiny" : "hodn"); else return result + "hodinami";

                      case "d":
                        return withoutSuffix || isFuture ? "de" : "dom";

                      case "dd":
                        if (withoutSuffix || isFuture) return result + (plural(number) ? "dni" : "dn"); else return result + "dami";

                      case "M":
                        return withoutSuffix || isFuture ? "mesiac" : "mesiacom";

                      case "MM":
                        if (withoutSuffix || isFuture) return result + (plural(number) ? "mesiace" : "mesiacov"); else return result + "mesiacmi";

                      case "y":
                        return withoutSuffix || isFuture ? "rok" : "rokom";

                      case "yy":
                        if (withoutSuffix || isFuture) return result + (plural(number) ? "roky" : "rokov"); else return result + "rokmi";
                    }
                }
                var sk = moment.defineLocale("sk", {
                    months,
                    monthsShort,
                    weekdays: "nedea_pondelok_utorok_streda_tvrtok_piatok_sobota".split("_"),
                    weekdaysShort: "ne_po_ut_st_t_pi_so".split("_"),
                    weekdaysMin: "ne_po_ut_st_t_pi_so".split("_"),
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D. MMMM YYYY",
                        LLL: "D. MMMM YYYY H:mm",
                        LLLL: "dddd D. MMMM YYYY H:mm"
                    },
                    calendar: {
                        sameDay: "[dnes o] LT",
                        nextDay: "[zajtra o] LT",
                        nextWeek: function() {
                            switch (this.day()) {
                              case 0:
                                return "[v nedeu o] LT";

                              case 1:
                              case 2:
                                return "[v] dddd [o] LT";

                              case 3:
                                return "[v stredu o] LT";

                              case 4:
                                return "[vo tvrtok o] LT";

                              case 5:
                                return "[v piatok o] LT";

                              case 6:
                                return "[v sobotu o] LT";
                            }
                        },
                        lastDay: "[vera o] LT",
                        lastWeek: function() {
                            switch (this.day()) {
                              case 0:
                                return "[minul nedeu o] LT";

                              case 1:
                              case 2:
                                return "[minul] dddd [o] LT";

                              case 3:
                                return "[minul stredu o] LT";

                              case 4:
                              case 5:
                                return "[minul] dddd [o] LT";

                              case 6:
                                return "[minul sobotu o] LT";
                            }
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "za %s",
                        past: "pred %s",
                        s: translate,
                        ss: translate,
                        m: translate,
                        mm: translate,
                        h: translate,
                        hh: translate,
                        d: translate,
                        dd: translate,
                        M: translate,
                        MM: translate,
                        y: translate,
                        yy: translate
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return sk;
            }));
        },
        4985: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                function processRelativeTime(number, withoutSuffix, key, isFuture) {
                    var result = number + " ";
                    switch (key) {
                      case "s":
                        return withoutSuffix || isFuture ? "nekaj sekund" : "nekaj sekundami";

                      case "ss":
                        if (1 === number) result += withoutSuffix ? "sekundo" : "sekundi"; else if (2 === number) result += withoutSuffix || isFuture ? "sekundi" : "sekundah"; else if (number < 5) result += withoutSuffix || isFuture ? "sekunde" : "sekundah"; else result += "sekund";
                        return result;

                      case "m":
                        return withoutSuffix ? "ena minuta" : "eno minuto";

                      case "mm":
                        if (1 === number) result += withoutSuffix ? "minuta" : "minuto"; else if (2 === number) result += withoutSuffix || isFuture ? "minuti" : "minutama"; else if (number < 5) result += withoutSuffix || isFuture ? "minute" : "minutami"; else result += withoutSuffix || isFuture ? "minut" : "minutami";
                        return result;

                      case "h":
                        return withoutSuffix ? "ena ura" : "eno uro";

                      case "hh":
                        if (1 === number) result += withoutSuffix ? "ura" : "uro"; else if (2 === number) result += withoutSuffix || isFuture ? "uri" : "urama"; else if (number < 5) result += withoutSuffix || isFuture ? "ure" : "urami"; else result += withoutSuffix || isFuture ? "ur" : "urami";
                        return result;

                      case "d":
                        return withoutSuffix || isFuture ? "en dan" : "enim dnem";

                      case "dd":
                        if (1 === number) result += withoutSuffix || isFuture ? "dan" : "dnem"; else if (2 === number) result += withoutSuffix || isFuture ? "dni" : "dnevoma"; else result += withoutSuffix || isFuture ? "dni" : "dnevi";
                        return result;

                      case "M":
                        return withoutSuffix || isFuture ? "en mesec" : "enim mesecem";

                      case "MM":
                        if (1 === number) result += withoutSuffix || isFuture ? "mesec" : "mesecem"; else if (2 === number) result += withoutSuffix || isFuture ? "meseca" : "mesecema"; else if (number < 5) result += withoutSuffix || isFuture ? "mesece" : "meseci"; else result += withoutSuffix || isFuture ? "mesecev" : "meseci";
                        return result;

                      case "y":
                        return withoutSuffix || isFuture ? "eno leto" : "enim letom";

                      case "yy":
                        if (1 === number) result += withoutSuffix || isFuture ? "leto" : "letom"; else if (2 === number) result += withoutSuffix || isFuture ? "leti" : "letoma"; else if (number < 5) result += withoutSuffix || isFuture ? "leta" : "leti"; else result += withoutSuffix || isFuture ? "let" : "leti";
                        return result;
                    }
                }
                var sl = moment.defineLocale("sl", {
                    months: "januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december".split("_"),
                    monthsShort: "jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split("_"),
                    monthsParseExact: true,
                    weekdays: "nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota".split("_"),
                    weekdaysShort: "ned._pon._tor._sre._et._pet._sob.".split("_"),
                    weekdaysMin: "ne_po_to_sr_e_pe_so".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "DD. MM. YYYY",
                        LL: "D. MMMM YYYY",
                        LLL: "D. MMMM YYYY H:mm",
                        LLLL: "dddd, D. MMMM YYYY H:mm"
                    },
                    calendar: {
                        sameDay: "[danes ob] LT",
                        nextDay: "[jutri ob] LT",
                        nextWeek: function() {
                            switch (this.day()) {
                              case 0:
                                return "[v] [nedeljo] [ob] LT";

                              case 3:
                                return "[v] [sredo] [ob] LT";

                              case 6:
                                return "[v] [soboto] [ob] LT";

                              case 1:
                              case 2:
                              case 4:
                              case 5:
                                return "[v] dddd [ob] LT";
                            }
                        },
                        lastDay: "[veraj ob] LT",
                        lastWeek: function() {
                            switch (this.day()) {
                              case 0:
                                return "[prejnjo] [nedeljo] [ob] LT";

                              case 3:
                                return "[prejnjo] [sredo] [ob] LT";

                              case 6:
                                return "[prejnjo] [soboto] [ob] LT";

                              case 1:
                              case 2:
                              case 4:
                              case 5:
                                return "[prejnji] dddd [ob] LT";
                            }
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "ez %s",
                        past: "pred %s",
                        s: processRelativeTime,
                        ss: processRelativeTime,
                        m: processRelativeTime,
                        mm: processRelativeTime,
                        h: processRelativeTime,
                        hh: processRelativeTime,
                        d: processRelativeTime,
                        dd: processRelativeTime,
                        M: processRelativeTime,
                        MM: processRelativeTime,
                        y: processRelativeTime,
                        yy: processRelativeTime
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return sl;
            }));
        },
        1104: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var sq = moment.defineLocale("sq", {
                    months: "Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor".split("_"),
                    monthsShort: "Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj".split("_"),
                    weekdays: "E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun".split("_"),
                    weekdaysShort: "Die_Hn_Mar_Mr_Enj_Pre_Sht".split("_"),
                    weekdaysMin: "D_H_Ma_M_E_P_Sh".split("_"),
                    weekdaysParseExact: true,
                    meridiemParse: /PD|MD/,
                    isPM: function(input) {
                        return "M" === input.charAt(0);
                    },
                    meridiem: function(hours, minutes, isLower) {
                        return hours < 12 ? "PD" : "MD";
                    },
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[Sot n] LT",
                        nextDay: "[Nesr n] LT",
                        nextWeek: "dddd [n] LT",
                        lastDay: "[Dje n] LT",
                        lastWeek: "dddd [e kaluar n] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "n %s",
                        past: "%s m par",
                        s: "disa sekonda",
                        ss: "%d sekonda",
                        m: "nj minut",
                        mm: "%d minuta",
                        h: "nj or",
                        hh: "%d or",
                        d: "nj dit",
                        dd: "%d dit",
                        M: "nj muaj",
                        MM: "%d muaj",
                        y: "nj vit",
                        yy: "%d vite"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return sq;
            }));
        },
        9915: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var translator = {
                    words: {
                        ss: [ "", "", "" ],
                        m: [ " ", " " ],
                        mm: [ "", "", "" ],
                        h: [ " ", " " ],
                        hh: [ "", "", "" ],
                        d: [ " ", " " ],
                        dd: [ "", "", "" ],
                        M: [ " ", " " ],
                        MM: [ "", "", "" ],
                        y: [ " ", " " ],
                        yy: [ "", "", "" ]
                    },
                    correctGrammaticalCase: function(number, wordKey) {
                        if (number % 10 >= 1 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) return number % 10 === 1 ? wordKey[0] : wordKey[1];
                        return wordKey[2];
                    },
                    translate: function(number, withoutSuffix, key, isFuture) {
                        var word, wordKey = translator.words[key];
                        if (1 === key.length) {
                            if ("y" === key && withoutSuffix) return " ";
                            return isFuture || withoutSuffix ? wordKey[0] : wordKey[1];
                        }
                        word = translator.correctGrammaticalCase(number, wordKey);
                        if ("yy" === key && withoutSuffix && "" === word) return number + " ";
                        return number + " " + word;
                    }
                };
                var srCyrl = moment.defineLocale("sr-cyrl", {
                    months: "___________".split("_"),
                    monthsShort: "._._._.____._._._._.".split("_"),
                    monthsParseExact: true,
                    weekdays: "______".split("_"),
                    weekdaysShort: "._._._._._._.".split("_"),
                    weekdaysMin: "______".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "D. M. YYYY.",
                        LL: "D. MMMM YYYY.",
                        LLL: "D. MMMM YYYY. H:mm",
                        LLLL: "dddd, D. MMMM YYYY. H:mm"
                    },
                    calendar: {
                        sameDay: "[ ] LT",
                        nextDay: "[ ] LT",
                        nextWeek: function() {
                            switch (this.day()) {
                              case 0:
                                return "[] [] [] LT";

                              case 3:
                                return "[] [] [] LT";

                              case 6:
                                return "[] [] [] LT";

                              case 1:
                              case 2:
                              case 4:
                              case 5:
                                return "[] dddd [] LT";
                            }
                        },
                        lastDay: "[ ] LT",
                        lastWeek: function() {
                            var lastWeekDays = [ "[] [] [] LT", "[] [] [] LT", "[] [] [] LT", "[] [] [] LT", "[] [] [] LT", "[] [] [] LT", "[] [] [] LT" ];
                            return lastWeekDays[this.day()];
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s",
                        past: " %s",
                        s: " ",
                        ss: translator.translate,
                        m: translator.translate,
                        mm: translator.translate,
                        h: translator.translate,
                        hh: translator.translate,
                        d: translator.translate,
                        dd: translator.translate,
                        M: translator.translate,
                        MM: translator.translate,
                        y: translator.translate,
                        yy: translator.translate
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return srCyrl;
            }));
        },
        9131: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var translator = {
                    words: {
                        ss: [ "sekunda", "sekunde", "sekundi" ],
                        m: [ "jedan minut", "jednog minuta" ],
                        mm: [ "minut", "minuta", "minuta" ],
                        h: [ "jedan sat", "jednog sata" ],
                        hh: [ "sat", "sata", "sati" ],
                        d: [ "jedan dan", "jednog dana" ],
                        dd: [ "dan", "dana", "dana" ],
                        M: [ "jedan mesec", "jednog meseca" ],
                        MM: [ "mesec", "meseca", "meseci" ],
                        y: [ "jednu godinu", "jedne godine" ],
                        yy: [ "godinu", "godine", "godina" ]
                    },
                    correctGrammaticalCase: function(number, wordKey) {
                        if (number % 10 >= 1 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) return number % 10 === 1 ? wordKey[0] : wordKey[1];
                        return wordKey[2];
                    },
                    translate: function(number, withoutSuffix, key, isFuture) {
                        var word, wordKey = translator.words[key];
                        if (1 === key.length) {
                            if ("y" === key && withoutSuffix) return "jedna godina";
                            return isFuture || withoutSuffix ? wordKey[0] : wordKey[1];
                        }
                        word = translator.correctGrammaticalCase(number, wordKey);
                        if ("yy" === key && withoutSuffix && "godinu" === word) return number + " godina";
                        return number + " " + word;
                    }
                };
                var sr = moment.defineLocale("sr", {
                    months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"),
                    monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),
                    monthsParseExact: true,
                    weekdays: "nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota".split("_"),
                    weekdaysShort: "ned._pon._uto._sre._et._pet._sub.".split("_"),
                    weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "D. M. YYYY.",
                        LL: "D. MMMM YYYY.",
                        LLL: "D. MMMM YYYY. H:mm",
                        LLLL: "dddd, D. MMMM YYYY. H:mm"
                    },
                    calendar: {
                        sameDay: "[danas u] LT",
                        nextDay: "[sutra u] LT",
                        nextWeek: function() {
                            switch (this.day()) {
                              case 0:
                                return "[u] [nedelju] [u] LT";

                              case 3:
                                return "[u] [sredu] [u] LT";

                              case 6:
                                return "[u] [subotu] [u] LT";

                              case 1:
                              case 2:
                              case 4:
                              case 5:
                                return "[u] dddd [u] LT";
                            }
                        },
                        lastDay: "[jue u] LT",
                        lastWeek: function() {
                            var lastWeekDays = [ "[prole] [nedelje] [u] LT", "[prolog] [ponedeljka] [u] LT", "[prolog] [utorka] [u] LT", "[prole] [srede] [u] LT", "[prolog] [etvrtka] [u] LT", "[prolog] [petka] [u] LT", "[prole] [subote] [u] LT" ];
                            return lastWeekDays[this.day()];
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "za %s",
                        past: "pre %s",
                        s: "nekoliko sekundi",
                        ss: translator.translate,
                        m: translator.translate,
                        mm: translator.translate,
                        h: translator.translate,
                        hh: translator.translate,
                        d: translator.translate,
                        dd: translator.translate,
                        M: translator.translate,
                        MM: translator.translate,
                        y: translator.translate,
                        yy: translator.translate
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return sr;
            }));
        },
        5893: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var ss = moment.defineLocale("ss", {
                    months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split("_"),
                    monthsShort: "Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo".split("_"),
                    weekdays: "Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo".split("_"),
                    weekdaysShort: "Lis_Umb_Lsb_Les_Lsi_Lsh_Umg".split("_"),
                    weekdaysMin: "Li_Us_Lb_Lt_Ls_Lh_Ug".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "h:mm A",
                        LTS: "h:mm:ss A",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY h:mm A",
                        LLLL: "dddd, D MMMM YYYY h:mm A"
                    },
                    calendar: {
                        sameDay: "[Namuhla nga] LT",
                        nextDay: "[Kusasa nga] LT",
                        nextWeek: "dddd [nga] LT",
                        lastDay: "[Itolo nga] LT",
                        lastWeek: "dddd [leliphelile] [nga] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "nga %s",
                        past: "wenteka nga %s",
                        s: "emizuzwana lomcane",
                        ss: "%d mzuzwana",
                        m: "umzuzu",
                        mm: "%d emizuzu",
                        h: "lihora",
                        hh: "%d emahora",
                        d: "lilanga",
                        dd: "%d emalanga",
                        M: "inyanga",
                        MM: "%d tinyanga",
                        y: "umnyaka",
                        yy: "%d iminyaka"
                    },
                    meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
                    meridiem: function(hours, minutes, isLower) {
                        if (hours < 11) return "ekuseni"; else if (hours < 15) return "emini"; else if (hours < 19) return "entsambama"; else return "ebusuku";
                    },
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("ekuseni" === meridiem) return hour; else if ("emini" === meridiem) return hour >= 11 ? hour : hour + 12; else if ("entsambama" === meridiem || "ebusuku" === meridiem) {
                            if (0 === hour) return 0;
                            return hour + 12;
                        }
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: "%d",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return ss;
            }));
        },
        8760: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var sv = moment.defineLocale("sv", {
                    months: "januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split("_"),
                    monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
                    weekdays: "sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag".split("_"),
                    weekdaysShort: "sn_mn_tis_ons_tor_fre_lr".split("_"),
                    weekdaysMin: "s_m_ti_on_to_fr_l".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "YYYY-MM-DD",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY [kl.] HH:mm",
                        LLLL: "dddd D MMMM YYYY [kl.] HH:mm",
                        lll: "D MMM YYYY HH:mm",
                        llll: "ddd D MMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[Idag] LT",
                        nextDay: "[Imorgon] LT",
                        lastDay: "[Igr] LT",
                        nextWeek: "[P] dddd LT",
                        lastWeek: "[I] dddd[s] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "om %s",
                        past: "fr %s sedan",
                        s: "ngra sekunder",
                        ss: "%d sekunder",
                        m: "en minut",
                        mm: "%d minuter",
                        h: "en timme",
                        hh: "%d timmar",
                        d: "en dag",
                        dd: "%d dagar",
                        M: "en mnad",
                        MM: "%d mnader",
                        y: "ett r",
                        yy: "%d r"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(\:e|\:a)/,
                    ordinal: function(number) {
                        var b = number % 10, output = 1 === ~~(number % 100 / 10) ? ":e" : 1 === b ? ":a" : 2 === b ? ":a" : 3 === b ? ":e" : ":e";
                        return number + output;
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return sv;
            }));
        },
        1172: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var sw = moment.defineLocale("sw", {
                    months: "Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba".split("_"),
                    monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des".split("_"),
                    weekdays: "Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi".split("_"),
                    weekdaysShort: "Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos".split("_"),
                    weekdaysMin: "J2_J3_J4_J5_Al_Ij_J1".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "hh:mm A",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[leo saa] LT",
                        nextDay: "[kesho saa] LT",
                        nextWeek: "[wiki ijayo] dddd [saat] LT",
                        lastDay: "[jana] LT",
                        lastWeek: "[wiki iliyopita] dddd [saat] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s baadaye",
                        past: "tokea %s",
                        s: "hivi punde",
                        ss: "sekunde %d",
                        m: "dakika moja",
                        mm: "dakika %d",
                        h: "saa limoja",
                        hh: "masaa %d",
                        d: "siku moja",
                        dd: "siku %d",
                        M: "mwezi mmoja",
                        MM: "miezi %d",
                        y: "mwaka mmoja",
                        yy: "miaka %d"
                    },
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return sw;
            }));
        },
        7333: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var symbolMap = {
                    1: "",
                    2: "",
                    3: "",
                    4: "",
                    5: "",
                    6: "",
                    7: "",
                    8: "",
                    9: "",
                    0: ""
                }, numberMap = {
                    "": "1",
                    "": "2",
                    "": "3",
                    "": "4",
                    "": "5",
                    "": "6",
                    "": "7",
                    "": "8",
                    "": "9",
                    "": "0"
                };
                var ta = moment.defineLocale("ta", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY, HH:mm",
                        LLLL: "dddd, D MMMM YYYY, HH:mm"
                    },
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        nextWeek: "dddd, LT",
                        lastDay: "[] LT",
                        lastWeek: "[ ] dddd, LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s ",
                        past: "%s ",
                        s: "  ",
                        ss: "%d ",
                        m: " ",
                        mm: "%d ",
                        h: "  ",
                        hh: "%d  ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: function(number) {
                        return number + "";
                    },
                    preparse: function(string) {
                        return string.replace(/[]/g, (function(match) {
                            return numberMap[match];
                        }));
                    },
                    postformat: function(string) {
                        return string.replace(/\d/g, (function(match) {
                            return symbolMap[match];
                        }));
                    },
                    meridiemParse: /|||||/,
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 2) return " "; else if (hour < 6) return " "; else if (hour < 10) return " "; else if (hour < 14) return " "; else if (hour < 18) return " "; else if (hour < 22) return " "; else return " ";
                    },
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("" === meridiem) return hour < 2 ? hour : hour + 12; else if ("" === meridiem || "" === meridiem) return hour; else if ("" === meridiem) return hour >= 10 ? hour : hour + 12; else return hour + 12;
                    },
                    week: {
                        dow: 0,
                        doy: 6
                    }
                });
                return ta;
            }));
        },
        3110: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var te = moment.defineLocale("te", {
                    months: "___________".split("_"),
                    monthsShort: "._.__.____._._._._.".split("_"),
                    monthsParseExact: true,
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "A h:mm",
                        LTS: "A h:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY, A h:mm",
                        LLLL: "dddd, D MMMM YYYY, A h:mm"
                    },
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        nextWeek: "dddd, LT",
                        lastDay: "[] LT",
                        lastWeek: "[] dddd, LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s ",
                        past: "%s ",
                        s: " ",
                        ss: "%d ",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: "%d",
                    meridiemParse: /|||/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("" === meridiem) return hour < 4 ? hour : hour + 12; else if ("" === meridiem) return hour; else if ("" === meridiem) return hour >= 10 ? hour : hour + 12; else if ("" === meridiem) return hour + 12;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 4) return ""; else if (hour < 10) return ""; else if (hour < 17) return ""; else if (hour < 20) return ""; else return "";
                    },
                    week: {
                        dow: 0,
                        doy: 6
                    }
                });
                return te;
            }));
        },
        2095: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var tet = moment.defineLocale("tet", {
                    months: "Janeiru_Fevereiru_Marsu_Abril_Maiu_Juu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru".split("_"),
                    monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),
                    weekdays: "Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu".split("_"),
                    weekdaysShort: "Dom_Seg_Ters_Kua_Kint_Sest_Sab".split("_"),
                    weekdaysMin: "Do_Seg_Te_Ku_Ki_Ses_Sa".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[Ohin iha] LT",
                        nextDay: "[Aban iha] LT",
                        nextWeek: "dddd [iha] LT",
                        lastDay: "[Horiseik iha] LT",
                        lastWeek: "dddd [semana kotuk] [iha] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "iha %s",
                        past: "%s liuba",
                        s: "segundu balun",
                        ss: "segundu %d",
                        m: "minutu ida",
                        mm: "minutu %d",
                        h: "oras ida",
                        hh: "oras %d",
                        d: "loron ida",
                        dd: "loron %d",
                        M: "fulan ida",
                        MM: "fulan %d",
                        y: "tinan ida",
                        yy: "tinan %d"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
                    ordinal: function(number) {
                        var b = number % 10, output = 1 === ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th";
                        return number + output;
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return tet;
            }));
        },
        7321: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var suffixes = {
                    0: "-",
                    1: "-",
                    2: "-",
                    3: "-",
                    4: "-",
                    5: "-",
                    6: "-",
                    7: "-",
                    8: "-",
                    9: "-",
                    10: "-",
                    12: "-",
                    13: "-",
                    20: "-",
                    30: "-",
                    40: "-",
                    50: "-",
                    60: "-",
                    70: "-",
                    80: "-",
                    90: "-",
                    100: "-"
                };
                var tg = moment.defineLocale("tg", {
                    months: {
                        format: "___________".split("_"),
                        standalone: "___________".split("_")
                    },
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[ ] LT",
                        nextDay: "[ ] LT",
                        lastDay: "[ ] LT",
                        nextWeek: "dddd[] [  ] LT",
                        lastWeek: "dddd[] [  ] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s",
                        past: "%s ",
                        s: " ",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    meridiemParse: /|||/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("" === meridiem) return hour < 4 ? hour : hour + 12; else if ("" === meridiem) return hour; else if ("" === meridiem) return hour >= 11 ? hour : hour + 12; else if ("" === meridiem) return hour + 12;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 4) return ""; else if (hour < 11) return ""; else if (hour < 16) return ""; else if (hour < 19) return ""; else return "";
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
                    ordinal: function(number) {
                        var a = number % 10, b = number >= 100 ? 100 : null;
                        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
                    },
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return tg;
            }));
        },
        9041: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var th = moment.defineLocale("th", {
                    months: "___________".split("_"),
                    monthsShort: ".._.._.._.._.._.._.._.._.._.._.._..".split("_"),
                    monthsParseExact: true,
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "._._._._._._.".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "H:mm",
                        LTS: "H:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY  H:mm",
                        LLLL: "dddd D MMMM YYYY  H:mm"
                    },
                    meridiemParse: /|/,
                    isPM: function(input) {
                        return "" === input;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 12) return ""; else return "";
                    },
                    calendar: {
                        sameDay: "[ ] LT",
                        nextDay: "[ ] LT",
                        nextWeek: "dddd[ ] LT",
                        lastDay: "[ ] LT",
                        lastWeek: "[]dddd[ ] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s",
                        past: "%s",
                        s: "",
                        ss: "%d ",
                        m: "1 ",
                        mm: "%d ",
                        h: "1 ",
                        hh: "%d ",
                        d: "1 ",
                        dd: "%d ",
                        w: "1 ",
                        ww: "%d ",
                        M: "1 ",
                        MM: "%d ",
                        y: "1 ",
                        yy: "%d "
                    }
                });
                return th;
            }));
        },
        9005: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var suffixes = {
                    1: "'inji",
                    5: "'inji",
                    8: "'inji",
                    70: "'inji",
                    80: "'inji",
                    2: "'nji",
                    7: "'nji",
                    20: "'nji",
                    50: "'nji",
                    3: "'nji",
                    4: "'nji",
                    100: "'nji",
                    6: "'njy",
                    9: "'unjy",
                    10: "'unjy",
                    30: "'unjy",
                    60: "'ynjy",
                    90: "'ynjy"
                };
                var tk = moment.defineLocale("tk", {
                    months: "anwar_Fewral_Mart_Aprel_Ma_Iun_Iul_Awgust_Sentabr_Oktabr_Noabr_Dekabr".split("_"),
                    monthsShort: "an_Few_Mar_Apr_Ma_In_Il_Awg_Sen_Okt_No_Dek".split("_"),
                    weekdays: "ekenbe_Duenbe_Sienbe_arenbe_Penenbe_Anna_enbe".split("_"),
                    weekdaysShort: "ek_Du_Si_ar_Pen_Ann_en".split("_"),
                    weekdaysMin: "k_D_S_r_Pn_An_n".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[bugn sagat] LT",
                        nextDay: "[ertir sagat] LT",
                        nextWeek: "[indiki] dddd [sagat] LT",
                        lastDay: "[dn] LT",
                        lastWeek: "[geen] dddd [sagat] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s so",
                        past: "%s ",
                        s: "birne sekunt",
                        m: "bir minut",
                        mm: "%d minut",
                        h: "bir sagat",
                        hh: "%d sagat",
                        d: "bir gn",
                        dd: "%d gn",
                        M: "bir a",
                        MM: "%d a",
                        y: "bir yl",
                        yy: "%d yl"
                    },
                    ordinal: function(number, period) {
                        switch (period) {
                          case "d":
                          case "D":
                          case "Do":
                          case "DD":
                            return number;

                          default:
                            if (0 === number) return number + "'unjy";
                            var a = number % 10, b = number % 100 - a, c = number >= 100 ? 100 : null;
                            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
                        }
                    },
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return tk;
            }));
        },
        5768: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var tlPh = moment.defineLocale("tl-ph", {
                    months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"),
                    monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),
                    weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"),
                    weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),
                    weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "MM/D/YYYY",
                        LL: "MMMM D, YYYY",
                        LLL: "MMMM D, YYYY HH:mm",
                        LLLL: "dddd, MMMM DD, YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "LT [ngayong araw]",
                        nextDay: "[Bukas ng] LT",
                        nextWeek: "LT [sa susunod na] dddd",
                        lastDay: "LT [kahapon]",
                        lastWeek: "LT [noong nakaraang] dddd",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "sa loob ng %s",
                        past: "%s ang nakalipas",
                        s: "ilang segundo",
                        ss: "%d segundo",
                        m: "isang minuto",
                        mm: "%d minuto",
                        h: "isang oras",
                        hh: "%d oras",
                        d: "isang araw",
                        dd: "%d araw",
                        M: "isang buwan",
                        MM: "%d buwan",
                        y: "isang taon",
                        yy: "%d taon"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: function(number) {
                        return number;
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return tlPh;
            }));
        },
        9444: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var numbersNouns = "pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut".split("_");
                function translateFuture(output) {
                    var time = output;
                    time = -1 !== output.indexOf("jaj") ? time.slice(0, -3) + "leS" : -1 !== output.indexOf("jar") ? time.slice(0, -3) + "waQ" : -1 !== output.indexOf("DIS") ? time.slice(0, -3) + "nem" : time + " pIq";
                    return time;
                }
                function translatePast(output) {
                    var time = output;
                    time = -1 !== output.indexOf("jaj") ? time.slice(0, -3) + "Hu" : -1 !== output.indexOf("jar") ? time.slice(0, -3) + "wen" : -1 !== output.indexOf("DIS") ? time.slice(0, -3) + "ben" : time + " ret";
                    return time;
                }
                function translate(number, withoutSuffix, string, isFuture) {
                    var numberNoun = numberAsNoun(number);
                    switch (string) {
                      case "ss":
                        return numberNoun + " lup";

                      case "mm":
                        return numberNoun + " tup";

                      case "hh":
                        return numberNoun + " rep";

                      case "dd":
                        return numberNoun + " jaj";

                      case "MM":
                        return numberNoun + " jar";

                      case "yy":
                        return numberNoun + " DIS";
                    }
                }
                function numberAsNoun(number) {
                    var hundred = Math.floor(number % 1e3 / 100), ten = Math.floor(number % 100 / 10), one = number % 10, word = "";
                    if (hundred > 0) word += numbersNouns[hundred] + "vatlh";
                    if (ten > 0) word += ("" !== word ? " " : "") + numbersNouns[ten] + "maH";
                    if (one > 0) word += ("" !== word ? " " : "") + numbersNouns[one];
                    return "" === word ? "pagh" : word;
                }
                var tlh = moment.defineLocale("tlh", {
                    months: "tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha".split("_"),
                    monthsShort: "jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha".split("_"),
                    monthsParseExact: true,
                    weekdays: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
                    weekdaysShort: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
                    weekdaysMin: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[DaHjaj] LT",
                        nextDay: "[waleS] LT",
                        nextWeek: "LLL",
                        lastDay: "[waHu] LT",
                        lastWeek: "LLL",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: translateFuture,
                        past: translatePast,
                        s: "puS lup",
                        ss: translate,
                        m: "wa tup",
                        mm: translate,
                        h: "wa rep",
                        hh: translate,
                        d: "wa jaj",
                        dd: translate,
                        M: "wa jar",
                        MM: translate,
                        y: "wa DIS",
                        yy: translate
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return tlh;
            }));
        },
        2397: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var suffixes = {
                    1: "'inci",
                    5: "'inci",
                    8: "'inci",
                    70: "'inci",
                    80: "'inci",
                    2: "'nci",
                    7: "'nci",
                    20: "'nci",
                    50: "'nci",
                    3: "'nc",
                    4: "'nc",
                    100: "'nc",
                    6: "'nc",
                    9: "'uncu",
                    10: "'uncu",
                    30: "'uncu",
                    60: "'nc",
                    90: "'nc"
                };
                var tr = moment.defineLocale("tr", {
                    months: "Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk".split("_"),
                    monthsShort: "Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara".split("_"),
                    weekdays: "Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi".split("_"),
                    weekdaysShort: "Paz_Pzt_Sal_ar_Per_Cum_Cmt".split("_"),
                    weekdaysMin: "Pz_Pt_Sa_a_Pe_Cu_Ct".split("_"),
                    meridiem: function(hours, minutes, isLower) {
                        if (hours < 12) return isLower ? "" : ""; else return isLower ? "s" : "S";
                    },
                    meridiemParse: /||s|S/,
                    isPM: function(input) {
                        return "s" === input || "S" === input;
                    },
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[bugn saat] LT",
                        nextDay: "[yarn saat] LT",
                        nextWeek: "[gelecek] dddd [saat] LT",
                        lastDay: "[dn] LT",
                        lastWeek: "[geen] dddd [saat] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s sonra",
                        past: "%s nce",
                        s: "birka saniye",
                        ss: "%d saniye",
                        m: "bir dakika",
                        mm: "%d dakika",
                        h: "bir saat",
                        hh: "%d saat",
                        d: "bir gn",
                        dd: "%d gn",
                        w: "bir hafta",
                        ww: "%d hafta",
                        M: "bir ay",
                        MM: "%d ay",
                        y: "bir yl",
                        yy: "%d yl"
                    },
                    ordinal: function(number, period) {
                        switch (period) {
                          case "d":
                          case "D":
                          case "Do":
                          case "DD":
                            return number;

                          default:
                            if (0 === number) return number + "'nc";
                            var a = number % 10, b = number % 100 - a, c = number >= 100 ? 100 : null;
                            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
                        }
                    },
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return tr;
            }));
        },
        8254: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var tzl = moment.defineLocale("tzl", {
                    months: "Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar".split("_"),
                    monthsShort: "Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec".split("_"),
                    weekdays: "Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi".split("_"),
                    weekdaysShort: "Sl_Ln_Mai_Mr_Xh_Vi_St".split("_"),
                    weekdaysMin: "S_L_Ma_M_Xh_Vi_S".split("_"),
                    longDateFormat: {
                        LT: "HH.mm",
                        LTS: "HH.mm.ss",
                        L: "DD.MM.YYYY",
                        LL: "D. MMMM [dallas] YYYY",
                        LLL: "D. MMMM [dallas] YYYY HH.mm",
                        LLLL: "dddd, [li] D. MMMM [dallas] YYYY HH.mm"
                    },
                    meridiemParse: /d\'o|d\'a/i,
                    isPM: function(input) {
                        return "d'o" === input.toLowerCase();
                    },
                    meridiem: function(hours, minutes, isLower) {
                        if (hours > 11) return isLower ? "d'o" : "D'O"; else return isLower ? "d'a" : "D'A";
                    },
                    calendar: {
                        sameDay: "[oxhi ] LT",
                        nextDay: "[dem ] LT",
                        nextWeek: "dddd [] LT",
                        lastDay: "[ieiri ] LT",
                        lastWeek: "[sr el] dddd [lasteu ] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "osprei %s",
                        past: "ja%s",
                        s: processRelativeTime,
                        ss: processRelativeTime,
                        m: processRelativeTime,
                        mm: processRelativeTime,
                        h: processRelativeTime,
                        hh: processRelativeTime,
                        d: processRelativeTime,
                        dd: processRelativeTime,
                        M: processRelativeTime,
                        MM: processRelativeTime,
                        y: processRelativeTime,
                        yy: processRelativeTime
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}\./,
                    ordinal: "%d.",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                function processRelativeTime(number, withoutSuffix, key, isFuture) {
                    var format = {
                        s: [ "viensas secunds", "'iensas secunds" ],
                        ss: [ number + " secunds", number + " secunds" ],
                        m: [ "'n mut", "'iens mut" ],
                        mm: [ number + " muts", number + " muts" ],
                        h: [ "'n ora", "'iensa ora" ],
                        hh: [ number + " oras", number + " oras" ],
                        d: [ "'n ziua", "'iensa ziua" ],
                        dd: [ number + " ziuas", number + " ziuas" ],
                        M: [ "'n mes", "'iens mes" ],
                        MM: [ number + " mesen", number + " mesen" ],
                        y: [ "'n ar", "'iens ar" ],
                        yy: [ number + " ars", number + " ars" ]
                    };
                    return isFuture ? format[key][0] : withoutSuffix ? format[key][0] : format[key][1];
                }
                return tzl;
            }));
        },
        699: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var tzmLatn = moment.defineLocale("tzm-latn", {
                    months: "innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir".split("_"),
                    monthsShort: "innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir".split("_"),
                    weekdays: "asamas_aynas_asinas_akras_akwas_asimwas_asiyas".split("_"),
                    weekdaysShort: "asamas_aynas_asinas_akras_akwas_asimwas_asiyas".split("_"),
                    weekdaysMin: "asamas_aynas_asinas_akras_akwas_asimwas_asiyas".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[asdkh g] LT",
                        nextDay: "[aska g] LT",
                        nextWeek: "dddd [g] LT",
                        lastDay: "[assant g] LT",
                        lastWeek: "dddd [g] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "dadkh s yan %s",
                        past: "yan %s",
                        s: "imik",
                        ss: "%d imik",
                        m: "minu",
                        mm: "%d minu",
                        h: "saa",
                        hh: "%d tassain",
                        d: "ass",
                        dd: "%d ossan",
                        M: "ayowr",
                        MM: "%d iyyirn",
                        y: "asgas",
                        yy: "%d isgasn"
                    },
                    week: {
                        dow: 6,
                        doy: 12
                    }
                });
                return tzmLatn;
            }));
        },
        1106: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var tzm = moment.defineLocale("tzm", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[ ] LT",
                        nextDay: "[ ] LT",
                        nextWeek: "dddd [] LT",
                        lastDay: "[ ] LT",
                        lastWeek: "dddd [] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "   %s",
                        past: " %s",
                        s: "",
                        ss: "%d ",
                        m: "",
                        mm: "%d ",
                        h: "",
                        hh: "%d ",
                        d: "",
                        dd: "%d o",
                        M: "o",
                        MM: "%d ",
                        y: "",
                        yy: "%d "
                    },
                    week: {
                        dow: 6,
                        doy: 12
                    }
                });
                return tzm;
            }));
        },
        9288: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var ugCn = moment.defineLocale("ug-cn", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "YYYY-MM-DD",
                        LL: "YYYY-M-D-",
                        LLL: "YYYY-M-D- HH:mm",
                        LLLL: "dddd YYYY-M-D- HH:mm"
                    },
                    meridiemParse: / || || |/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if (" " === meridiem || "" === meridiem || " " === meridiem) return hour; else if (" " === meridiem || "" === meridiem) return hour + 12; else return hour >= 11 ? hour : hour + 12;
                    },
                    meridiem: function(hour, minute, isLower) {
                        var hm = 100 * hour + minute;
                        if (hm < 600) return " "; else if (hm < 900) return ""; else if (hm < 1130) return " "; else if (hm < 1230) return ""; else if (hm < 1800) return " "; else return "";
                    },
                    calendar: {
                        sameDay: "[ ] LT",
                        nextDay: "[ ] LT",
                        nextWeek: "[] dddd [] LT",
                        lastDay: "[] LT",
                        lastWeek: "[] dddd [] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s ",
                        past: "%s ",
                        s: " ",
                        ss: "%d ",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(-|-|-)/,
                    ordinal: function(number, period) {
                        switch (period) {
                          case "d":
                          case "D":
                          case "DDD":
                            return number + "-";

                          case "w":
                          case "W":
                            return number + "-";

                          default:
                            return number;
                        }
                    },
                    preparse: function(string) {
                        return string.replace(//g, ",");
                    },
                    postformat: function(string) {
                        return string.replace(/,/g, "");
                    },
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return ugCn;
            }));
        },
        7691: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                function plural(word, num) {
                    var forms = word.split("_");
                    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
                }
                function relativeTimeWithPlural(number, withoutSuffix, key) {
                    var format = {
                        ss: withoutSuffix ? "__" : "__",
                        mm: withoutSuffix ? "__" : "__",
                        hh: withoutSuffix ? "__" : "__",
                        dd: "__",
                        MM: "__",
                        yy: "__"
                    };
                    if ("m" === key) return withoutSuffix ? "" : ""; else if ("h" === key) return withoutSuffix ? "" : ""; else return number + " " + plural(format[key], +number);
                }
                function weekdaysCaseReplace(m, format) {
                    var nounCase, weekdays = {
                        nominative: "______".split("_"),
                        accusative: "______".split("_"),
                        genitive: "______".split("_")
                    };
                    if (true === m) return weekdays["nominative"].slice(1, 7).concat(weekdays["nominative"].slice(0, 1));
                    if (!m) return weekdays["nominative"];
                    nounCase = /(\[[]\]) ?dddd/.test(format) ? "accusative" : /\[?(?:|)? ?\] ?dddd/.test(format) ? "genitive" : "nominative";
                    return weekdays[nounCase][m.day()];
                }
                function processHoursFunction(str) {
                    return function() {
                        return str + "" + (11 === this.hours() ? "" : "") + "] LT";
                    };
                }
                var uk = moment.defineLocale("uk", {
                    months: {
                        format: "___________".split("_"),
                        standalone: "___________".split("_")
                    },
                    monthsShort: "___________".split("_"),
                    weekdays: weekdaysCaseReplace,
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD.MM.YYYY",
                        LL: "D MMMM YYYY .",
                        LLL: "D MMMM YYYY ., HH:mm",
                        LLLL: "dddd, D MMMM YYYY ., HH:mm"
                    },
                    calendar: {
                        sameDay: processHoursFunction("[ "),
                        nextDay: processHoursFunction("[ "),
                        lastDay: processHoursFunction("[ "),
                        nextWeek: processHoursFunction("[] dddd ["),
                        lastWeek: function() {
                            switch (this.day()) {
                              case 0:
                              case 3:
                              case 5:
                              case 6:
                                return processHoursFunction("[] dddd [").call(this);

                              case 1:
                              case 2:
                              case 4:
                                return processHoursFunction("[] dddd [").call(this);
                            }
                        },
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s",
                        past: "%s ",
                        s: " ",
                        ss: relativeTimeWithPlural,
                        m: relativeTimeWithPlural,
                        mm: relativeTimeWithPlural,
                        h: "",
                        hh: relativeTimeWithPlural,
                        d: "",
                        dd: relativeTimeWithPlural,
                        M: "",
                        MM: relativeTimeWithPlural,
                        y: "",
                        yy: relativeTimeWithPlural
                    },
                    meridiemParse: /|||/,
                    isPM: function(input) {
                        return /^(|)$/.test(input);
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 4) return ""; else if (hour < 12) return ""; else if (hour < 17) return ""; else return "";
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
                    ordinal: function(number, period) {
                        switch (period) {
                          case "M":
                          case "d":
                          case "DDD":
                          case "w":
                          case "W":
                            return number + "-";

                          case "D":
                            return number + "-";

                          default:
                            return number;
                        }
                    },
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return uk;
            }));
        },
        3795: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var months = [ "", "", "", "", "", "", "", "", "", "", "", "" ], days = [ "", "", "", "", "", "", "" ];
                var ur = moment.defineLocale("ur", {
                    months,
                    monthsShort: months,
                    weekdays: days,
                    weekdaysShort: days,
                    weekdaysMin: days,
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd D MMMM YYYY HH:mm"
                    },
                    meridiemParse: /|/,
                    isPM: function(input) {
                        return "" === input;
                    },
                    meridiem: function(hour, minute, isLower) {
                        if (hour < 12) return "";
                        return "";
                    },
                    calendar: {
                        sameDay: "[ ] LT",
                        nextDay: "[ ] LT",
                        nextWeek: "dddd [] LT",
                        lastDay: "[  ] LT",
                        lastWeek: "[] dddd [] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s ",
                        past: "%s ",
                        s: " ",
                        ss: "%d ",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    preparse: function(string) {
                        return string.replace(//g, ",");
                    },
                    postformat: function(string) {
                        return string.replace(/,/g, "");
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return ur;
            }));
        },
        588: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var uzLatn = moment.defineLocale("uz-latn", {
                    months: "Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr".split("_"),
                    monthsShort: "Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek".split("_"),
                    weekdays: "Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba".split("_"),
                    weekdaysShort: "Yak_Dush_Sesh_Chor_Pay_Jum_Shan".split("_"),
                    weekdaysMin: "Ya_Du_Se_Cho_Pa_Ju_Sha".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "D MMMM YYYY, dddd HH:mm"
                    },
                    calendar: {
                        sameDay: "[Bugun soat] LT [da]",
                        nextDay: "[Ertaga] LT [da]",
                        nextWeek: "dddd [kuni soat] LT [da]",
                        lastDay: "[Kecha soat] LT [da]",
                        lastWeek: "[O'tgan] dddd [kuni soat] LT [da]",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "Yaqin %s ichida",
                        past: "Bir necha %s oldin",
                        s: "soniya",
                        ss: "%d soniya",
                        m: "bir daqiqa",
                        mm: "%d daqiqa",
                        h: "bir soat",
                        hh: "%d soat",
                        d: "bir kun",
                        dd: "%d kun",
                        M: "bir oy",
                        MM: "%d oy",
                        y: "bir yil",
                        yy: "%d yil"
                    },
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return uzLatn;
            }));
        },
        6791: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var uz = moment.defineLocale("uz", {
                    months: "___________".split("_"),
                    monthsShort: "___________".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "D MMMM YYYY, dddd HH:mm"
                    },
                    calendar: {
                        sameDay: "[ ] LT []",
                        nextDay: "[] LT []",
                        nextWeek: "dddd [ ] LT []",
                        lastDay: "[ ] LT []",
                        lastWeek: "[] dddd [ ] LT []",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: " %s ",
                        past: "  %s ",
                        s: "",
                        ss: "%d ",
                        m: " ",
                        mm: "%d ",
                        h: " ",
                        hh: "%d ",
                        d: " ",
                        dd: "%d ",
                        M: " ",
                        MM: "%d ",
                        y: " ",
                        yy: "%d "
                    },
                    week: {
                        dow: 1,
                        doy: 7
                    }
                });
                return uz;
            }));
        },
        5666: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var vi = moment.defineLocale("vi", {
                    months: "thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12".split("_"),
                    monthsShort: "Thg 01_Thg 02_Thg 03_Thg 04_Thg 05_Thg 06_Thg 07_Thg 08_Thg 09_Thg 10_Thg 11_Thg 12".split("_"),
                    monthsParseExact: true,
                    weekdays: "ch nht_th hai_th ba_th t_th nm_th su_th by".split("_"),
                    weekdaysShort: "CN_T2_T3_T4_T5_T6_T7".split("_"),
                    weekdaysMin: "CN_T2_T3_T4_T5_T6_T7".split("_"),
                    weekdaysParseExact: true,
                    meridiemParse: /sa|ch/i,
                    isPM: function(input) {
                        return /^ch$/i.test(input);
                    },
                    meridiem: function(hours, minutes, isLower) {
                        if (hours < 12) return isLower ? "sa" : "SA"; else return isLower ? "ch" : "CH";
                    },
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM [nm] YYYY",
                        LLL: "D MMMM [nm] YYYY HH:mm",
                        LLLL: "dddd, D MMMM [nm] YYYY HH:mm",
                        l: "DD/M/YYYY",
                        ll: "D MMM YYYY",
                        lll: "D MMM YYYY HH:mm",
                        llll: "ddd, D MMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[Hm nay lc] LT",
                        nextDay: "[Ngy mai lc] LT",
                        nextWeek: "dddd [tun ti lc] LT",
                        lastDay: "[Hm qua lc] LT",
                        lastWeek: "dddd [tun trc lc] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "%s ti",
                        past: "%s trc",
                        s: "vi giy",
                        ss: "%d giy",
                        m: "mt pht",
                        mm: "%d pht",
                        h: "mt gi",
                        hh: "%d gi",
                        d: "mt ngy",
                        dd: "%d ngy",
                        w: "mt tun",
                        ww: "%d tun",
                        M: "mt thng",
                        MM: "%d thng",
                        y: "mt nm",
                        yy: "%d nm"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}/,
                    ordinal: function(number) {
                        return number;
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return vi;
            }));
        },
        4378: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var xPseudo = moment.defineLocale("x-pseudo", {
                    months: "J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr".split("_"),
                    monthsShort: "J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc".split("_"),
                    monthsParseExact: true,
                    weekdays: "S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d".split("_"),
                    weekdaysShort: "S~_~M_~T_~Wd_~Th_~Fr_~St".split("_"),
                    weekdaysMin: "S~_M~_T_~W_T~h_Fr~_S".split("_"),
                    weekdaysParseExact: true,
                    longDateFormat: {
                        LT: "HH:mm",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY HH:mm",
                        LLLL: "dddd, D MMMM YYYY HH:mm"
                    },
                    calendar: {
                        sameDay: "[T~d~ t] LT",
                        nextDay: "[T~m~rr~w t] LT",
                        nextWeek: "dddd [t] LT",
                        lastDay: "[~st~rd~ t] LT",
                        lastWeek: "[L~st] dddd [t] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "~ %s",
                        past: "%s ~g",
                        s: " ~fw ~sc~ds",
                        ss: "%d s~c~ds",
                        m: " ~m~t",
                        mm: "%d m~~ts",
                        h: "~ h~r",
                        hh: "%d h~rs",
                        d: " ~d",
                        dd: "%d d~s",
                        M: " ~m~th",
                        MM: "%d m~t~hs",
                        y: " ~r",
                        yy: "%d ~rs"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
                    ordinal: function(number) {
                        var b = number % 10, output = 1 === ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th";
                        return number + output;
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return xPseudo;
            }));
        },
        5805: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var yo = moment.defineLocale("yo", {
                    months: "Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p".split("_"),
                    monthsShort: "Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p".split("_"),
                    weekdays: "Aiku_Aje_Isgun_jru_jb_ti_Abamta".split("_"),
                    weekdaysShort: "Aik_Aje_Is_jr_jb_ti_Aba".split("_"),
                    weekdaysMin: "Ai_Aj_Is_r_b_t_Ab".split("_"),
                    longDateFormat: {
                        LT: "h:mm A",
                        LTS: "h:mm:ss A",
                        L: "DD/MM/YYYY",
                        LL: "D MMMM YYYY",
                        LLL: "D MMMM YYYY h:mm A",
                        LLLL: "dddd, D MMMM YYYY h:mm A"
                    },
                    calendar: {
                        sameDay: "[Oni ni] LT",
                        nextDay: "[la ni] LT",
                        nextWeek: "dddd [s ton'b] [ni] LT",
                        lastDay: "[Ana ni] LT",
                        lastWeek: "dddd [s tol] [ni] LT",
                        sameElse: "L"
                    },
                    relativeTime: {
                        future: "ni %s",
                        past: "%s kja",
                        s: "isju aaya die",
                        ss: "aaya %d",
                        m: "isju kan",
                        mm: "isju %d",
                        h: "wakati kan",
                        hh: "wakati %d",
                        d: "j kan",
                        dd: "j %d",
                        M: "osu kan",
                        MM: "osu %d",
                        y: "dun kan",
                        yy: "dun %d"
                    },
                    dayOfMonthOrdinalParse: /j\s\d{1,2}/,
                    ordinal: "j %d",
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return yo;
            }));
        },
        3839: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var zhCn = moment.defineLocale("zh-cn", {
                    months: "___________".split("_"),
                    monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "YYYY/MM/DD",
                        LL: "YYYYMD",
                        LLL: "YYYYMDAhmm",
                        LLLL: "YYYYMDddddAhmm",
                        l: "YYYY/M/D",
                        ll: "YYYYMD",
                        lll: "YYYYMD HH:mm",
                        llll: "YYYYMDdddd HH:mm"
                    },
                    meridiemParse: /|||||/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("" === meridiem || "" === meridiem || "" === meridiem) return hour; else if ("" === meridiem || "" === meridiem) return hour + 12; else return hour >= 11 ? hour : hour + 12;
                    },
                    meridiem: function(hour, minute, isLower) {
                        var hm = 100 * hour + minute;
                        if (hm < 600) return ""; else if (hm < 900) return ""; else if (hm < 1130) return ""; else if (hm < 1230) return ""; else if (hm < 1800) return ""; else return "";
                    },
                    calendar: {
                        sameDay: "[]LT",
                        nextDay: "[]LT",
                        nextWeek: function(now) {
                            if (now.week() !== this.week()) return "[]dddLT"; else return "[]dddLT";
                        },
                        lastDay: "[]LT",
                        lastWeek: function(now) {
                            if (this.week() !== now.week()) return "[]dddLT"; else return "[]dddLT";
                        },
                        sameElse: "L"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
                    ordinal: function(number, period) {
                        switch (period) {
                          case "d":
                          case "D":
                          case "DDD":
                            return number + "";

                          case "M":
                            return number + "";

                          case "w":
                          case "W":
                            return number + "";

                          default:
                            return number;
                        }
                    },
                    relativeTime: {
                        future: "%s",
                        past: "%s",
                        s: "",
                        ss: "%d ",
                        m: "1 ",
                        mm: "%d ",
                        h: "1 ",
                        hh: "%d ",
                        d: "1 ",
                        dd: "%d ",
                        w: "1 ",
                        ww: "%d ",
                        M: "1 ",
                        MM: "%d ",
                        y: "1 ",
                        yy: "%d "
                    },
                    week: {
                        dow: 1,
                        doy: 4
                    }
                });
                return zhCn;
            }));
        },
        5726: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var zhHk = moment.defineLocale("zh-hk", {
                    months: "___________".split("_"),
                    monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "YYYY/MM/DD",
                        LL: "YYYYMD",
                        LLL: "YYYYMD HH:mm",
                        LLLL: "YYYYMDdddd HH:mm",
                        l: "YYYY/M/D",
                        ll: "YYYYMD",
                        lll: "YYYYMD HH:mm",
                        llll: "YYYYMDdddd HH:mm"
                    },
                    meridiemParse: /|||||/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("" === meridiem || "" === meridiem || "" === meridiem) return hour; else if ("" === meridiem) return hour >= 11 ? hour : hour + 12; else if ("" === meridiem || "" === meridiem) return hour + 12;
                    },
                    meridiem: function(hour, minute, isLower) {
                        var hm = 100 * hour + minute;
                        if (hm < 600) return ""; else if (hm < 900) return ""; else if (hm < 1200) return ""; else if (1200 === hm) return ""; else if (hm < 1800) return ""; else return "";
                    },
                    calendar: {
                        sameDay: "[]LT",
                        nextDay: "[]LT",
                        nextWeek: "[]ddddLT",
                        lastDay: "[]LT",
                        lastWeek: "[]ddddLT",
                        sameElse: "L"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
                    ordinal: function(number, period) {
                        switch (period) {
                          case "d":
                          case "D":
                          case "DDD":
                            return number + "";

                          case "M":
                            return number + "";

                          case "w":
                          case "W":
                            return number + "";

                          default:
                            return number;
                        }
                    },
                    relativeTime: {
                        future: "%s",
                        past: "%s",
                        s: "",
                        ss: "%d ",
                        m: "1 ",
                        mm: "%d ",
                        h: "1 ",
                        hh: "%d ",
                        d: "1 ",
                        dd: "%d ",
                        M: "1 ",
                        MM: "%d ",
                        y: "1 ",
                        yy: "%d "
                    }
                });
                return zhHk;
            }));
        },
        9807: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var zhMo = moment.defineLocale("zh-mo", {
                    months: "___________".split("_"),
                    monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "DD/MM/YYYY",
                        LL: "YYYYMD",
                        LLL: "YYYYMD HH:mm",
                        LLLL: "YYYYMDdddd HH:mm",
                        l: "D/M/YYYY",
                        ll: "YYYYMD",
                        lll: "YYYYMD HH:mm",
                        llll: "YYYYMDdddd HH:mm"
                    },
                    meridiemParse: /|||||/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("" === meridiem || "" === meridiem || "" === meridiem) return hour; else if ("" === meridiem) return hour >= 11 ? hour : hour + 12; else if ("" === meridiem || "" === meridiem) return hour + 12;
                    },
                    meridiem: function(hour, minute, isLower) {
                        var hm = 100 * hour + minute;
                        if (hm < 600) return ""; else if (hm < 900) return ""; else if (hm < 1130) return ""; else if (hm < 1230) return ""; else if (hm < 1800) return ""; else return "";
                    },
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        nextWeek: "[]dddd LT",
                        lastDay: "[] LT",
                        lastWeek: "[]dddd LT",
                        sameElse: "L"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
                    ordinal: function(number, period) {
                        switch (period) {
                          case "d":
                          case "D":
                          case "DDD":
                            return number + "";

                          case "M":
                            return number + "";

                          case "w":
                          case "W":
                            return number + "";

                          default:
                            return number;
                        }
                    },
                    relativeTime: {
                        future: "%s",
                        past: "%s",
                        s: "",
                        ss: "%d ",
                        m: "1 ",
                        mm: "%d ",
                        h: "1 ",
                        hh: "%d ",
                        d: "1 ",
                        dd: "%d ",
                        M: "1 ",
                        MM: "%d ",
                        y: "1 ",
                        yy: "%d "
                    }
                });
                return zhMo;
            }));
        },
        4152: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {
            (function(global, factory) {
                true ? factory(__webpack_require__(381)) : 0;
            })(0, (function(moment) {
                "use strict";
                //! moment.js locale configuration
                                var zhTw = moment.defineLocale("zh-tw", {
                    months: "___________".split("_"),
                    monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
                    weekdays: "______".split("_"),
                    weekdaysShort: "______".split("_"),
                    weekdaysMin: "______".split("_"),
                    longDateFormat: {
                        LT: "HH:mm",
                        LTS: "HH:mm:ss",
                        L: "YYYY/MM/DD",
                        LL: "YYYYMD",
                        LLL: "YYYYMD HH:mm",
                        LLLL: "YYYYMDdddd HH:mm",
                        l: "YYYY/M/D",
                        ll: "YYYYMD",
                        lll: "YYYYMD HH:mm",
                        llll: "YYYYMDdddd HH:mm"
                    },
                    meridiemParse: /|||||/,
                    meridiemHour: function(hour, meridiem) {
                        if (12 === hour) hour = 0;
                        if ("" === meridiem || "" === meridiem || "" === meridiem) return hour; else if ("" === meridiem) return hour >= 11 ? hour : hour + 12; else if ("" === meridiem || "" === meridiem) return hour + 12;
                    },
                    meridiem: function(hour, minute, isLower) {
                        var hm = 100 * hour + minute;
                        if (hm < 600) return ""; else if (hm < 900) return ""; else if (hm < 1130) return ""; else if (hm < 1230) return ""; else if (hm < 1800) return ""; else return "";
                    },
                    calendar: {
                        sameDay: "[] LT",
                        nextDay: "[] LT",
                        nextWeek: "[]dddd LT",
                        lastDay: "[] LT",
                        lastWeek: "[]dddd LT",
                        sameElse: "L"
                    },
                    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
                    ordinal: function(number, period) {
                        switch (period) {
                          case "d":
                          case "D":
                          case "DDD":
                            return number + "";

                          case "M":
                            return number + "";

                          case "w":
                          case "W":
                            return number + "";

                          default:
                            return number;
                        }
                    },
                    relativeTime: {
                        future: "%s",
                        past: "%s",
                        s: "",
                        ss: "%d ",
                        m: "1 ",
                        mm: "%d ",
                        h: "1 ",
                        hh: "%d ",
                        d: "1 ",
                        dd: "%d ",
                        M: "1 ",
                        MM: "%d ",
                        y: "1 ",
                        yy: "%d "
                    }
                });
                return zhTw;
            }));
        },
        6700: (module, __unused_webpack_exports, __webpack_require__) => {
            var map = {
                "./af": 2786,
                "./af.js": 2786,
                "./ar": 867,
                "./ar-dz": 4130,
                "./ar-dz.js": 4130,
                "./ar-kw": 6135,
                "./ar-kw.js": 6135,
                "./ar-ly": 6440,
                "./ar-ly.js": 6440,
                "./ar-ma": 7702,
                "./ar-ma.js": 7702,
                "./ar-sa": 6040,
                "./ar-sa.js": 6040,
                "./ar-tn": 7100,
                "./ar-tn.js": 7100,
                "./ar.js": 867,
                "./az": 1083,
                "./az.js": 1083,
                "./be": 9808,
                "./be.js": 9808,
                "./bg": 8338,
                "./bg.js": 8338,
                "./bm": 7438,
                "./bm.js": 7438,
                "./bn": 8905,
                "./bn-bd": 6225,
                "./bn-bd.js": 6225,
                "./bn.js": 8905,
                "./bo": 1560,
                "./bo.js": 1560,
                "./br": 1278,
                "./br.js": 1278,
                "./bs": 622,
                "./bs.js": 622,
                "./ca": 2468,
                "./ca.js": 2468,
                "./cs": 5822,
                "./cs.js": 5822,
                "./cv": 877,
                "./cv.js": 877,
                "./cy": 7373,
                "./cy.js": 7373,
                "./da": 4780,
                "./da.js": 4780,
                "./de": 9740,
                "./de-at": 217,
                "./de-at.js": 217,
                "./de-ch": 894,
                "./de-ch.js": 894,
                "./de.js": 9740,
                "./dv": 5300,
                "./dv.js": 5300,
                "./el": 837,
                "./el.js": 837,
                "./en-au": 8348,
                "./en-au.js": 8348,
                "./en-ca": 7925,
                "./en-ca.js": 7925,
                "./en-gb": 2243,
                "./en-gb.js": 2243,
                "./en-ie": 6436,
                "./en-ie.js": 6436,
                "./en-il": 7207,
                "./en-il.js": 7207,
                "./en-in": 4175,
                "./en-in.js": 4175,
                "./en-nz": 6319,
                "./en-nz.js": 6319,
                "./en-sg": 1662,
                "./en-sg.js": 1662,
                "./eo": 2915,
                "./eo.js": 2915,
                "./es": 5655,
                "./es-do": 5251,
                "./es-do.js": 5251,
                "./es-mx": 6112,
                "./es-mx.js": 6112,
                "./es-us": 1146,
                "./es-us.js": 1146,
                "./es.js": 5655,
                "./et": 5603,
                "./et.js": 5603,
                "./eu": 7763,
                "./eu.js": 7763,
                "./fa": 6959,
                "./fa.js": 6959,
                "./fi": 1897,
                "./fi.js": 1897,
                "./fil": 2549,
                "./fil.js": 2549,
                "./fo": 4694,
                "./fo.js": 4694,
                "./fr": 4470,
                "./fr-ca": 3049,
                "./fr-ca.js": 3049,
                "./fr-ch": 2330,
                "./fr-ch.js": 2330,
                "./fr.js": 4470,
                "./fy": 5044,
                "./fy.js": 5044,
                "./ga": 9295,
                "./ga.js": 9295,
                "./gd": 2101,
                "./gd.js": 2101,
                "./gl": 8794,
                "./gl.js": 8794,
                "./gom-deva": 7884,
                "./gom-deva.js": 7884,
                "./gom-latn": 3168,
                "./gom-latn.js": 3168,
                "./gu": 5349,
                "./gu.js": 5349,
                "./he": 4206,
                "./he.js": 4206,
                "./hi": 94,
                "./hi.js": 94,
                "./hr": 316,
                "./hr.js": 316,
                "./hu": 2138,
                "./hu.js": 2138,
                "./hy-am": 1423,
                "./hy-am.js": 1423,
                "./id": 9218,
                "./id.js": 9218,
                "./is": 135,
                "./is.js": 135,
                "./it": 626,
                "./it-ch": 150,
                "./it-ch.js": 150,
                "./it.js": 626,
                "./ja": 9183,
                "./ja.js": 9183,
                "./jv": 4286,
                "./jv.js": 4286,
                "./ka": 2105,
                "./ka.js": 2105,
                "./kk": 7772,
                "./kk.js": 7772,
                "./km": 8758,
                "./km.js": 8758,
                "./kn": 9282,
                "./kn.js": 9282,
                "./ko": 3730,
                "./ko.js": 3730,
                "./ku": 1408,
                "./ku.js": 1408,
                "./ky": 3291,
                "./ky.js": 3291,
                "./lb": 6841,
                "./lb.js": 6841,
                "./lo": 5466,
                "./lo.js": 5466,
                "./lt": 7010,
                "./lt.js": 7010,
                "./lv": 7595,
                "./lv.js": 7595,
                "./me": 9861,
                "./me.js": 9861,
                "./mi": 5493,
                "./mi.js": 5493,
                "./mk": 5966,
                "./mk.js": 5966,
                "./ml": 7341,
                "./ml.js": 7341,
                "./mn": 5115,
                "./mn.js": 5115,
                "./mr": 370,
                "./mr.js": 370,
                "./ms": 9847,
                "./ms-my": 1237,
                "./ms-my.js": 1237,
                "./ms.js": 9847,
                "./mt": 2126,
                "./mt.js": 2126,
                "./my": 6165,
                "./my.js": 6165,
                "./nb": 4924,
                "./nb.js": 4924,
                "./ne": 6744,
                "./ne.js": 6744,
                "./nl": 3901,
                "./nl-be": 9814,
                "./nl-be.js": 9814,
                "./nl.js": 3901,
                "./nn": 3877,
                "./nn.js": 3877,
                "./oc-lnc": 2135,
                "./oc-lnc.js": 2135,
                "./pa-in": 5858,
                "./pa-in.js": 5858,
                "./pl": 4495,
                "./pl.js": 4495,
                "./pt": 9520,
                "./pt-br": 7971,
                "./pt-br.js": 7971,
                "./pt.js": 9520,
                "./ro": 6459,
                "./ro.js": 6459,
                "./ru": 1793,
                "./ru.js": 1793,
                "./sd": 950,
                "./sd.js": 950,
                "./se": 490,
                "./se.js": 490,
                "./si": 124,
                "./si.js": 124,
                "./sk": 4249,
                "./sk.js": 4249,
                "./sl": 4985,
                "./sl.js": 4985,
                "./sq": 1104,
                "./sq.js": 1104,
                "./sr": 9131,
                "./sr-cyrl": 9915,
                "./sr-cyrl.js": 9915,
                "./sr.js": 9131,
                "./ss": 5893,
                "./ss.js": 5893,
                "./sv": 8760,
                "./sv.js": 8760,
                "./sw": 1172,
                "./sw.js": 1172,
                "./ta": 7333,
                "./ta.js": 7333,
                "./te": 3110,
                "./te.js": 3110,
                "./tet": 2095,
                "./tet.js": 2095,
                "./tg": 7321,
                "./tg.js": 7321,
                "./th": 9041,
                "./th.js": 9041,
                "./tk": 9005,
                "./tk.js": 9005,
                "./tl-ph": 5768,
                "./tl-ph.js": 5768,
                "./tlh": 9444,
                "./tlh.js": 9444,
                "./tr": 2397,
                "./tr.js": 2397,
                "./tzl": 8254,
                "./tzl.js": 8254,
                "./tzm": 1106,
                "./tzm-latn": 699,
                "./tzm-latn.js": 699,
                "./tzm.js": 1106,
                "./ug-cn": 9288,
                "./ug-cn.js": 9288,
                "./uk": 7691,
                "./uk.js": 7691,
                "./ur": 3795,
                "./ur.js": 3795,
                "./uz": 6791,
                "./uz-latn": 588,
                "./uz-latn.js": 588,
                "./uz.js": 6791,
                "./vi": 5666,
                "./vi.js": 5666,
                "./x-pseudo": 4378,
                "./x-pseudo.js": 4378,
                "./yo": 5805,
                "./yo.js": 5805,
                "./zh-cn": 3839,
                "./zh-cn.js": 3839,
                "./zh-hk": 5726,
                "./zh-hk.js": 5726,
                "./zh-mo": 9807,
                "./zh-mo.js": 9807,
                "./zh-tw": 4152,
                "./zh-tw.js": 4152
            };
            function webpackContext(req) {
                var id = webpackContextResolve(req);
                return __webpack_require__(id);
            }
            function webpackContextResolve(req) {
                if (!__webpack_require__.o(map, req)) {
                    var e = new Error("Cannot find module '" + req + "'");
                    e.code = "MODULE_NOT_FOUND";
                    throw e;
                }
                return map[req];
            }
            webpackContext.keys = function webpackContextKeys() {
                return Object.keys(map);
            };
            webpackContext.resolve = webpackContextResolve;
            module.exports = webpackContext;
            webpackContext.id = 6700;
        },
        381: function(module, __unused_webpack_exports, __webpack_require__) {
            module = __webpack_require__.nmd(module);
            //! moment.js
            //! version : 2.29.4
            //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
            //! license : MIT
            //! momentjs.com
                        (function(global, factory) {
                true ? module.exports = factory() : 0;
            })(0, (function() {
                "use strict";
                var hookCallback;
                function hooks() {
                    return hookCallback.apply(null, arguments);
                }
                function setHookCallback(callback) {
                    hookCallback = callback;
                }
                function isArray(input) {
                    return input instanceof Array || "[object Array]" === Object.prototype.toString.call(input);
                }
                function isObject(input) {
                    return null != input && "[object Object]" === Object.prototype.toString.call(input);
                }
                function hasOwnProp(a, b) {
                    return Object.prototype.hasOwnProperty.call(a, b);
                }
                function isObjectEmpty(obj) {
                    if (Object.getOwnPropertyNames) return 0 === Object.getOwnPropertyNames(obj).length; else {
                        var k;
                        for (k in obj) if (hasOwnProp(obj, k)) return false;
                        return true;
                    }
                }
                function isUndefined(input) {
                    return void 0 === input;
                }
                function isNumber(input) {
                    return "number" === typeof input || "[object Number]" === Object.prototype.toString.call(input);
                }
                function isDate(input) {
                    return input instanceof Date || "[object Date]" === Object.prototype.toString.call(input);
                }
                function map(arr, fn) {
                    var i, res = [], arrLen = arr.length;
                    for (i = 0; i < arrLen; ++i) res.push(fn(arr[i], i));
                    return res;
                }
                function extend(a, b) {
                    for (var i in b) if (hasOwnProp(b, i)) a[i] = b[i];
                    if (hasOwnProp(b, "toString")) a.toString = b.toString;
                    if (hasOwnProp(b, "valueOf")) a.valueOf = b.valueOf;
                    return a;
                }
                function createUTC(input, format, locale, strict) {
                    return createLocalOrUTC(input, format, locale, strict, true).utc();
                }
                function defaultParsingFlags() {
                    return {
                        empty: false,
                        unusedTokens: [],
                        unusedInput: [],
                        overflow: -2,
                        charsLeftOver: 0,
                        nullInput: false,
                        invalidEra: null,
                        invalidMonth: null,
                        invalidFormat: false,
                        userInvalidated: false,
                        iso: false,
                        parsedDateParts: [],
                        era: null,
                        meridiem: null,
                        rfc2822: false,
                        weekdayMismatch: false
                    };
                }
                function getParsingFlags(m) {
                    if (null == m._pf) m._pf = defaultParsingFlags();
                    return m._pf;
                }
                var some;
                if (Array.prototype.some) some = Array.prototype.some; else some = function(fun) {
                    var i, t = Object(this), len = t.length >>> 0;
                    for (i = 0; i < len; i++) if (i in t && fun.call(this, t[i], i, t)) return true;
                    return false;
                };
                function isValid(m) {
                    if (null == m._isValid) {
                        var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, (function(i) {
                            return null != i;
                        })), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
                        if (m._strict) isNowValid = isNowValid && 0 === flags.charsLeftOver && 0 === flags.unusedTokens.length && void 0 === flags.bigHour;
                        if (null == Object.isFrozen || !Object.isFrozen(m)) m._isValid = isNowValid; else return isNowValid;
                    }
                    return m._isValid;
                }
                function createInvalid(flags) {
                    var m = createUTC(NaN);
                    if (null != flags) extend(getParsingFlags(m), flags); else getParsingFlags(m).userInvalidated = true;
                    return m;
                }
                var momentProperties = hooks.momentProperties = [], updateInProgress = false;
                function copyConfig(to, from) {
                    var i, prop, val, momentPropertiesLen = momentProperties.length;
                    if (!isUndefined(from._isAMomentObject)) to._isAMomentObject = from._isAMomentObject;
                    if (!isUndefined(from._i)) to._i = from._i;
                    if (!isUndefined(from._f)) to._f = from._f;
                    if (!isUndefined(from._l)) to._l = from._l;
                    if (!isUndefined(from._strict)) to._strict = from._strict;
                    if (!isUndefined(from._tzm)) to._tzm = from._tzm;
                    if (!isUndefined(from._isUTC)) to._isUTC = from._isUTC;
                    if (!isUndefined(from._offset)) to._offset = from._offset;
                    if (!isUndefined(from._pf)) to._pf = getParsingFlags(from);
                    if (!isUndefined(from._locale)) to._locale = from._locale;
                    if (momentPropertiesLen > 0) for (i = 0; i < momentPropertiesLen; i++) {
                        prop = momentProperties[i];
                        val = from[prop];
                        if (!isUndefined(val)) to[prop] = val;
                    }
                    return to;
                }
                function Moment(config) {
                    copyConfig(this, config);
                    this._d = new Date(null != config._d ? config._d.getTime() : NaN);
                    if (!this.isValid()) this._d = new Date(NaN);
                    if (false === updateInProgress) {
                        updateInProgress = true;
                        hooks.updateOffset(this);
                        updateInProgress = false;
                    }
                }
                function isMoment(obj) {
                    return obj instanceof Moment || null != obj && null != obj._isAMomentObject;
                }
                function warn(msg) {
                    if (false === hooks.suppressDeprecationWarnings && "undefined" !== typeof console && console.warn) console.warn("Deprecation warning: " + msg);
                }
                function deprecate(msg, fn) {
                    var firstTime = true;
                    return extend((function() {
                        if (null != hooks.deprecationHandler) hooks.deprecationHandler(null, msg);
                        if (firstTime) {
                            var arg, i, key, args = [], argLen = arguments.length;
                            for (i = 0; i < argLen; i++) {
                                arg = "";
                                if ("object" === typeof arguments[i]) {
                                    arg += "\n[" + i + "] ";
                                    for (key in arguments[0]) if (hasOwnProp(arguments[0], key)) arg += key + ": " + arguments[0][key] + ", ";
                                    arg = arg.slice(0, -2);
                                } else arg = arguments[i];
                                args.push(arg);
                            }
                            warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + (new Error).stack);
                            firstTime = false;
                        }
                        return fn.apply(this, arguments);
                    }), fn);
                }
                var deprecations = {};
                function deprecateSimple(name, msg) {
                    if (null != hooks.deprecationHandler) hooks.deprecationHandler(name, msg);
                    if (!deprecations[name]) {
                        warn(msg);
                        deprecations[name] = true;
                    }
                }
                hooks.suppressDeprecationWarnings = false;
                hooks.deprecationHandler = null;
                function isFunction(input) {
                    return "undefined" !== typeof Function && input instanceof Function || "[object Function]" === Object.prototype.toString.call(input);
                }
                function set(config) {
                    var prop, i;
                    for (i in config) if (hasOwnProp(config, i)) {
                        prop = config[i];
                        if (isFunction(prop)) this[i] = prop; else this["_" + i] = prop;
                    }
                    this._config = config;
                    this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
                }
                function mergeConfigs(parentConfig, childConfig) {
                    var prop, res = extend({}, parentConfig);
                    for (prop in childConfig) if (hasOwnProp(childConfig, prop)) if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                        res[prop] = {};
                        extend(res[prop], parentConfig[prop]);
                        extend(res[prop], childConfig[prop]);
                    } else if (null != childConfig[prop]) res[prop] = childConfig[prop]; else delete res[prop];
                    for (prop in parentConfig) if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) res[prop] = extend({}, res[prop]);
                    return res;
                }
                function Locale(config) {
                    if (null != config) this.set(config);
                }
                var keys;
                if (Object.keys) keys = Object.keys; else keys = function(obj) {
                    var i, res = [];
                    for (i in obj) if (hasOwnProp(obj, i)) res.push(i);
                    return res;
                };
                var defaultCalendar = {
                    sameDay: "[Today at] LT",
                    nextDay: "[Tomorrow at] LT",
                    nextWeek: "dddd [at] LT",
                    lastDay: "[Yesterday at] LT",
                    lastWeek: "[Last] dddd [at] LT",
                    sameElse: "L"
                };
                function calendar(key, mom, now) {
                    var output = this._calendar[key] || this._calendar["sameElse"];
                    return isFunction(output) ? output.call(mom, now) : output;
                }
                function zeroFill(number, targetLength, forceSign) {
                    var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign = number >= 0;
                    return (sign ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
                }
                var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
                function addFormatToken(token, padded, ordinal, callback) {
                    var func = callback;
                    if ("string" === typeof callback) func = function() {
                        return this[callback]();
                    };
                    if (token) formatTokenFunctions[token] = func;
                    if (padded) formatTokenFunctions[padded[0]] = function() {
                        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
                    };
                    if (ordinal) formatTokenFunctions[ordinal] = function() {
                        return this.localeData().ordinal(func.apply(this, arguments), token);
                    };
                }
                function removeFormattingTokens(input) {
                    if (input.match(/\[[\s\S]/)) return input.replace(/^\[|\]$/g, "");
                    return input.replace(/\\/g, "");
                }
                function makeFormatFunction(format) {
                    var i, length, array = format.match(formattingTokens);
                    for (i = 0, length = array.length; i < length; i++) if (formatTokenFunctions[array[i]]) array[i] = formatTokenFunctions[array[i]]; else array[i] = removeFormattingTokens(array[i]);
                    return function(mom) {
                        var i, output = "";
                        for (i = 0; i < length; i++) output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
                        return output;
                    };
                }
                function formatMoment(m, format) {
                    if (!m.isValid()) return m.localeData().invalidDate();
                    format = expandFormat(format, m.localeData());
                    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
                    return formatFunctions[format](m);
                }
                function expandFormat(format, locale) {
                    var i = 5;
                    function replaceLongDateFormatTokens(input) {
                        return locale.longDateFormat(input) || input;
                    }
                    localFormattingTokens.lastIndex = 0;
                    while (i >= 0 && localFormattingTokens.test(format)) {
                        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
                        localFormattingTokens.lastIndex = 0;
                        i -= 1;
                    }
                    return format;
                }
                var defaultLongDateFormat = {
                    LTS: "h:mm:ss A",
                    LT: "h:mm A",
                    L: "MM/DD/YYYY",
                    LL: "MMMM D, YYYY",
                    LLL: "MMMM D, YYYY h:mm A",
                    LLLL: "dddd, MMMM D, YYYY h:mm A"
                };
                function longDateFormat(key) {
                    var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
                    if (format || !formatUpper) return format;
                    this._longDateFormat[key] = formatUpper.match(formattingTokens).map((function(tok) {
                        if ("MMMM" === tok || "MM" === tok || "DD" === tok || "dddd" === tok) return tok.slice(1);
                        return tok;
                    })).join("");
                    return this._longDateFormat[key];
                }
                var defaultInvalidDate = "Invalid date";
                function invalidDate() {
                    return this._invalidDate;
                }
                var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
                function ordinal(number) {
                    return this._ordinal.replace("%d", number);
                }
                var defaultRelativeTime = {
                    future: "in %s",
                    past: "%s ago",
                    s: "a few seconds",
                    ss: "%d seconds",
                    m: "a minute",
                    mm: "%d minutes",
                    h: "an hour",
                    hh: "%d hours",
                    d: "a day",
                    dd: "%d days",
                    w: "a week",
                    ww: "%d weeks",
                    M: "a month",
                    MM: "%d months",
                    y: "a year",
                    yy: "%d years"
                };
                function relativeTime(number, withoutSuffix, string, isFuture) {
                    var output = this._relativeTime[string];
                    return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
                }
                function pastFuture(diff, output) {
                    var format = this._relativeTime[diff > 0 ? "future" : "past"];
                    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
                }
                var aliases = {};
                function addUnitAlias(unit, shorthand) {
                    var lowerCase = unit.toLowerCase();
                    aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
                }
                function normalizeUnits(units) {
                    return "string" === typeof units ? aliases[units] || aliases[units.toLowerCase()] : void 0;
                }
                function normalizeObjectUnits(inputObject) {
                    var normalizedProp, prop, normalizedInput = {};
                    for (prop in inputObject) if (hasOwnProp(inputObject, prop)) {
                        normalizedProp = normalizeUnits(prop);
                        if (normalizedProp) normalizedInput[normalizedProp] = inputObject[prop];
                    }
                    return normalizedInput;
                }
                var priorities = {};
                function addUnitPriority(unit, priority) {
                    priorities[unit] = priority;
                }
                function getPrioritizedUnits(unitsObj) {
                    var u, units = [];
                    for (u in unitsObj) if (hasOwnProp(unitsObj, u)) units.push({
                        unit: u,
                        priority: priorities[u]
                    });
                    units.sort((function(a, b) {
                        return a.priority - b.priority;
                    }));
                    return units;
                }
                function isLeapYear(year) {
                    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
                }
                function absFloor(number) {
                    if (number < 0) return Math.ceil(number) || 0; else return Math.floor(number);
                }
                function toInt(argumentForCoercion) {
                    var coercedNumber = +argumentForCoercion, value = 0;
                    if (0 !== coercedNumber && isFinite(coercedNumber)) value = absFloor(coercedNumber);
                    return value;
                }
                function makeGetSet(unit, keepTime) {
                    return function(value) {
                        if (null != value) {
                            set$1(this, unit, value);
                            hooks.updateOffset(this, keepTime);
                            return this;
                        } else return get(this, unit);
                    };
                }
                function get(mom, unit) {
                    return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
                }
                function set$1(mom, unit, value) {
                    if (mom.isValid() && !isNaN(value)) if ("FullYear" === unit && isLeapYear(mom.year()) && 1 === mom.month() && 29 === mom.date()) {
                        value = toInt(value);
                        mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
                    } else mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
                }
                function stringGet(units) {
                    units = normalizeUnits(units);
                    if (isFunction(this[units])) return this[units]();
                    return this;
                }
                function stringSet(units, value) {
                    if ("object" === typeof units) {
                        units = normalizeObjectUnits(units);
                        var i, prioritized = getPrioritizedUnits(units), prioritizedLen = prioritized.length;
                        for (i = 0; i < prioritizedLen; i++) this[prioritized[i].unit](units[prioritized[i].unit]);
                    } else {
                        units = normalizeUnits(units);
                        if (isFunction(this[units])) return this[units](value);
                    }
                    return this;
                }
                var regexes, match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
                regexes = {};
                function addRegexToken(token, regex, strictRegex) {
                    regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
                        return isStrict && strictRegex ? strictRegex : regex;
                    };
                }
                function getParseRegexForToken(token, config) {
                    if (!hasOwnProp(regexes, token)) return new RegExp(unescapeFormat(token));
                    return regexes[token](config._strict, config._locale);
                }
                function unescapeFormat(s) {
                    return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, (function(matched, p1, p2, p3, p4) {
                        return p1 || p2 || p3 || p4;
                    })));
                }
                function regexEscape(s) {
                    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
                }
                var tokens = {};
                function addParseToken(token, callback) {
                    var i, tokenLen, func = callback;
                    if ("string" === typeof token) token = [ token ];
                    if (isNumber(callback)) func = function(input, array) {
                        array[callback] = toInt(input);
                    };
                    tokenLen = token.length;
                    for (i = 0; i < tokenLen; i++) tokens[token[i]] = func;
                }
                function addWeekParseToken(token, callback) {
                    addParseToken(token, (function(input, array, config, token) {
                        config._w = config._w || {};
                        callback(input, config._w, config, token);
                    }));
                }
                function addTimeToArrayFromToken(token, input, config) {
                    if (null != input && hasOwnProp(tokens, token)) tokens[token](input, config._a, config, token);
                }
                var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
                function mod(n, x) {
                    return (n % x + x) % x;
                }
                var indexOf;
                if (Array.prototype.indexOf) indexOf = Array.prototype.indexOf; else indexOf = function(o) {
                    var i;
                    for (i = 0; i < this.length; ++i) if (this[i] === o) return i;
                    return -1;
                };
                function daysInMonth(year, month) {
                    if (isNaN(year) || isNaN(month)) return NaN;
                    var modMonth = mod(month, 12);
                    year += (month - modMonth) / 12;
                    return 1 === modMonth ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
                }
                addFormatToken("M", [ "MM", 2 ], "Mo", (function() {
                    return this.month() + 1;
                }));
                addFormatToken("MMM", 0, 0, (function(format) {
                    return this.localeData().monthsShort(this, format);
                }));
                addFormatToken("MMMM", 0, 0, (function(format) {
                    return this.localeData().months(this, format);
                }));
                addUnitAlias("month", "M");
                addUnitPriority("month", 8);
                addRegexToken("M", match1to2);
                addRegexToken("MM", match1to2, match2);
                addRegexToken("MMM", (function(isStrict, locale) {
                    return locale.monthsShortRegex(isStrict);
                }));
                addRegexToken("MMMM", (function(isStrict, locale) {
                    return locale.monthsRegex(isStrict);
                }));
                addParseToken([ "M", "MM" ], (function(input, array) {
                    array[MONTH] = toInt(input) - 1;
                }));
                addParseToken([ "MMM", "MMMM" ], (function(input, array, config, token) {
                    var month = config._locale.monthsParse(input, token, config._strict);
                    if (null != month) array[MONTH] = month; else getParsingFlags(config).invalidMonth = input;
                }));
                var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
                function localeMonths(m, format) {
                    if (!m) return isArray(this._months) ? this._months : this._months["standalone"];
                    return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? "format" : "standalone"][m.month()];
                }
                function localeMonthsShort(m, format) {
                    if (!m) return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
                    return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? "format" : "standalone"][m.month()];
                }
                function handleStrictParse(monthName, format, strict) {
                    var i, ii, mom, llc = monthName.toLocaleLowerCase();
                    if (!this._monthsParse) {
                        this._monthsParse = [];
                        this._longMonthsParse = [];
                        this._shortMonthsParse = [];
                        for (i = 0; i < 12; ++i) {
                            mom = createUTC([ 2e3, i ]);
                            this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
                            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
                        }
                    }
                    if (strict) if ("MMM" === format) {
                        ii = indexOf.call(this._shortMonthsParse, llc);
                        return -1 !== ii ? ii : null;
                    } else {
                        ii = indexOf.call(this._longMonthsParse, llc);
                        return -1 !== ii ? ii : null;
                    } else if ("MMM" === format) {
                        ii = indexOf.call(this._shortMonthsParse, llc);
                        if (-1 !== ii) return ii;
                        ii = indexOf.call(this._longMonthsParse, llc);
                        return -1 !== ii ? ii : null;
                    } else {
                        ii = indexOf.call(this._longMonthsParse, llc);
                        if (-1 !== ii) return ii;
                        ii = indexOf.call(this._shortMonthsParse, llc);
                        return -1 !== ii ? ii : null;
                    }
                }
                function localeMonthsParse(monthName, format, strict) {
                    var i, mom, regex;
                    if (this._monthsParseExact) return handleStrictParse.call(this, monthName, format, strict);
                    if (!this._monthsParse) {
                        this._monthsParse = [];
                        this._longMonthsParse = [];
                        this._shortMonthsParse = [];
                    }
                    for (i = 0; i < 12; i++) {
                        mom = createUTC([ 2e3, i ]);
                        if (strict && !this._longMonthsParse[i]) {
                            this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
                            this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
                        }
                        if (!strict && !this._monthsParse[i]) {
                            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
                            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
                        }
                        if (strict && "MMMM" === format && this._longMonthsParse[i].test(monthName)) return i; else if (strict && "MMM" === format && this._shortMonthsParse[i].test(monthName)) return i; else if (!strict && this._monthsParse[i].test(monthName)) return i;
                    }
                }
                function setMonth(mom, value) {
                    var dayOfMonth;
                    if (!mom.isValid()) return mom;
                    if ("string" === typeof value) if (/^\d+$/.test(value)) value = toInt(value); else {
                        value = mom.localeData().monthsParse(value);
                        if (!isNumber(value)) return mom;
                    }
                    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
                    mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
                    return mom;
                }
                function getSetMonth(value) {
                    if (null != value) {
                        setMonth(this, value);
                        hooks.updateOffset(this, true);
                        return this;
                    } else return get(this, "Month");
                }
                function getDaysInMonth() {
                    return daysInMonth(this.year(), this.month());
                }
                function monthsShortRegex(isStrict) {
                    if (this._monthsParseExact) {
                        if (!hasOwnProp(this, "_monthsRegex")) computeMonthsParse.call(this);
                        if (isStrict) return this._monthsShortStrictRegex; else return this._monthsShortRegex;
                    } else {
                        if (!hasOwnProp(this, "_monthsShortRegex")) this._monthsShortRegex = defaultMonthsShortRegex;
                        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
                    }
                }
                function monthsRegex(isStrict) {
                    if (this._monthsParseExact) {
                        if (!hasOwnProp(this, "_monthsRegex")) computeMonthsParse.call(this);
                        if (isStrict) return this._monthsStrictRegex; else return this._monthsRegex;
                    } else {
                        if (!hasOwnProp(this, "_monthsRegex")) this._monthsRegex = defaultMonthsRegex;
                        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
                    }
                }
                function computeMonthsParse() {
                    function cmpLenRev(a, b) {
                        return b.length - a.length;
                    }
                    var i, mom, shortPieces = [], longPieces = [], mixedPieces = [];
                    for (i = 0; i < 12; i++) {
                        mom = createUTC([ 2e3, i ]);
                        shortPieces.push(this.monthsShort(mom, ""));
                        longPieces.push(this.months(mom, ""));
                        mixedPieces.push(this.months(mom, ""));
                        mixedPieces.push(this.monthsShort(mom, ""));
                    }
                    shortPieces.sort(cmpLenRev);
                    longPieces.sort(cmpLenRev);
                    mixedPieces.sort(cmpLenRev);
                    for (i = 0; i < 12; i++) {
                        shortPieces[i] = regexEscape(shortPieces[i]);
                        longPieces[i] = regexEscape(longPieces[i]);
                    }
                    for (i = 0; i < 24; i++) mixedPieces[i] = regexEscape(mixedPieces[i]);
                    this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
                    this._monthsShortRegex = this._monthsRegex;
                    this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
                    this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
                }
                addFormatToken("Y", 0, 0, (function() {
                    var y = this.year();
                    return y <= 9999 ? zeroFill(y, 4) : "+" + y;
                }));
                addFormatToken(0, [ "YY", 2 ], 0, (function() {
                    return this.year() % 100;
                }));
                addFormatToken(0, [ "YYYY", 4 ], 0, "year");
                addFormatToken(0, [ "YYYYY", 5 ], 0, "year");
                addFormatToken(0, [ "YYYYYY", 6, true ], 0, "year");
                addUnitAlias("year", "y");
                addUnitPriority("year", 1);
                addRegexToken("Y", matchSigned);
                addRegexToken("YY", match1to2, match2);
                addRegexToken("YYYY", match1to4, match4);
                addRegexToken("YYYYY", match1to6, match6);
                addRegexToken("YYYYYY", match1to6, match6);
                addParseToken([ "YYYYY", "YYYYYY" ], YEAR);
                addParseToken("YYYY", (function(input, array) {
                    array[YEAR] = 2 === input.length ? hooks.parseTwoDigitYear(input) : toInt(input);
                }));
                addParseToken("YY", (function(input, array) {
                    array[YEAR] = hooks.parseTwoDigitYear(input);
                }));
                addParseToken("Y", (function(input, array) {
                    array[YEAR] = parseInt(input, 10);
                }));
                function daysInYear(year) {
                    return isLeapYear(year) ? 366 : 365;
                }
                hooks.parseTwoDigitYear = function(input) {
                    return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
                };
                var getSetYear = makeGetSet("FullYear", true);
                function getIsLeapYear() {
                    return isLeapYear(this.year());
                }
                function createDate(y, m, d, h, M, s, ms) {
                    var date;
                    if (y < 100 && y >= 0) {
                        date = new Date(y + 400, m, d, h, M, s, ms);
                        if (isFinite(date.getFullYear())) date.setFullYear(y);
                    } else date = new Date(y, m, d, h, M, s, ms);
                    return date;
                }
                function createUTCDate(y) {
                    var date, args;
                    if (y < 100 && y >= 0) {
                        args = Array.prototype.slice.call(arguments);
                        args[0] = y + 400;
                        date = new Date(Date.UTC.apply(null, args));
                        if (isFinite(date.getUTCFullYear())) date.setUTCFullYear(y);
                    } else date = new Date(Date.UTC.apply(null, arguments));
                    return date;
                }
                function firstWeekOffset(year, dow, doy) {
                    var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
                    return -fwdlw + fwd - 1;
                }
                function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
                    var resYear, resDayOfYear, localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset;
                    if (dayOfYear <= 0) {
                        resYear = year - 1;
                        resDayOfYear = daysInYear(resYear) + dayOfYear;
                    } else if (dayOfYear > daysInYear(year)) {
                        resYear = year + 1;
                        resDayOfYear = dayOfYear - daysInYear(year);
                    } else {
                        resYear = year;
                        resDayOfYear = dayOfYear;
                    }
                    return {
                        year: resYear,
                        dayOfYear: resDayOfYear
                    };
                }
                function weekOfYear(mom, dow, doy) {
                    var resWeek, resYear, weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1;
                    if (week < 1) {
                        resYear = mom.year() - 1;
                        resWeek = week + weeksInYear(resYear, dow, doy);
                    } else if (week > weeksInYear(mom.year(), dow, doy)) {
                        resWeek = week - weeksInYear(mom.year(), dow, doy);
                        resYear = mom.year() + 1;
                    } else {
                        resYear = mom.year();
                        resWeek = week;
                    }
                    return {
                        week: resWeek,
                        year: resYear
                    };
                }
                function weeksInYear(year, dow, doy) {
                    var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
                    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
                }
                addFormatToken("w", [ "ww", 2 ], "wo", "week");
                addFormatToken("W", [ "WW", 2 ], "Wo", "isoWeek");
                addUnitAlias("week", "w");
                addUnitAlias("isoWeek", "W");
                addUnitPriority("week", 5);
                addUnitPriority("isoWeek", 5);
                addRegexToken("w", match1to2);
                addRegexToken("ww", match1to2, match2);
                addRegexToken("W", match1to2);
                addRegexToken("WW", match1to2, match2);
                addWeekParseToken([ "w", "ww", "W", "WW" ], (function(input, week, config, token) {
                    week[token.substr(0, 1)] = toInt(input);
                }));
                function localeWeek(mom) {
                    return weekOfYear(mom, this._week.dow, this._week.doy).week;
                }
                var defaultLocaleWeek = {
                    dow: 0,
                    doy: 6
                };
                function localeFirstDayOfWeek() {
                    return this._week.dow;
                }
                function localeFirstDayOfYear() {
                    return this._week.doy;
                }
                function getSetWeek(input) {
                    var week = this.localeData().week(this);
                    return null == input ? week : this.add(7 * (input - week), "d");
                }
                function getSetISOWeek(input) {
                    var week = weekOfYear(this, 1, 4).week;
                    return null == input ? week : this.add(7 * (input - week), "d");
                }
                addFormatToken("d", 0, "do", "day");
                addFormatToken("dd", 0, 0, (function(format) {
                    return this.localeData().weekdaysMin(this, format);
                }));
                addFormatToken("ddd", 0, 0, (function(format) {
                    return this.localeData().weekdaysShort(this, format);
                }));
                addFormatToken("dddd", 0, 0, (function(format) {
                    return this.localeData().weekdays(this, format);
                }));
                addFormatToken("e", 0, 0, "weekday");
                addFormatToken("E", 0, 0, "isoWeekday");
                addUnitAlias("day", "d");
                addUnitAlias("weekday", "e");
                addUnitAlias("isoWeekday", "E");
                addUnitPriority("day", 11);
                addUnitPriority("weekday", 11);
                addUnitPriority("isoWeekday", 11);
                addRegexToken("d", match1to2);
                addRegexToken("e", match1to2);
                addRegexToken("E", match1to2);
                addRegexToken("dd", (function(isStrict, locale) {
                    return locale.weekdaysMinRegex(isStrict);
                }));
                addRegexToken("ddd", (function(isStrict, locale) {
                    return locale.weekdaysShortRegex(isStrict);
                }));
                addRegexToken("dddd", (function(isStrict, locale) {
                    return locale.weekdaysRegex(isStrict);
                }));
                addWeekParseToken([ "dd", "ddd", "dddd" ], (function(input, week, config, token) {
                    var weekday = config._locale.weekdaysParse(input, token, config._strict);
                    if (null != weekday) week.d = weekday; else getParsingFlags(config).invalidWeekday = input;
                }));
                addWeekParseToken([ "d", "e", "E" ], (function(input, week, config, token) {
                    week[token] = toInt(input);
                }));
                function parseWeekday(input, locale) {
                    if ("string" !== typeof input) return input;
                    if (!isNaN(input)) return parseInt(input, 10);
                    input = locale.weekdaysParse(input);
                    if ("number" === typeof input) return input;
                    return null;
                }
                function parseIsoWeekday(input, locale) {
                    if ("string" === typeof input) return locale.weekdaysParse(input) % 7 || 7;
                    return isNaN(input) ? null : input;
                }
                function shiftWeekdays(ws, n) {
                    return ws.slice(n, 7).concat(ws.slice(0, n));
                }
                var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
                function localeWeekdays(m, format) {
                    var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && true !== m && this._weekdays.isFormat.test(format) ? "format" : "standalone"];
                    return true === m ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
                }
                function localeWeekdaysShort(m) {
                    return true === m ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
                }
                function localeWeekdaysMin(m) {
                    return true === m ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
                }
                function handleStrictParse$1(weekdayName, format, strict) {
                    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
                    if (!this._weekdaysParse) {
                        this._weekdaysParse = [];
                        this._shortWeekdaysParse = [];
                        this._minWeekdaysParse = [];
                        for (i = 0; i < 7; ++i) {
                            mom = createUTC([ 2e3, 1 ]).day(i);
                            this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
                            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
                            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
                        }
                    }
                    if (strict) if ("dddd" === format) {
                        ii = indexOf.call(this._weekdaysParse, llc);
                        return -1 !== ii ? ii : null;
                    } else if ("ddd" === format) {
                        ii = indexOf.call(this._shortWeekdaysParse, llc);
                        return -1 !== ii ? ii : null;
                    } else {
                        ii = indexOf.call(this._minWeekdaysParse, llc);
                        return -1 !== ii ? ii : null;
                    } else if ("dddd" === format) {
                        ii = indexOf.call(this._weekdaysParse, llc);
                        if (-1 !== ii) return ii;
                        ii = indexOf.call(this._shortWeekdaysParse, llc);
                        if (-1 !== ii) return ii;
                        ii = indexOf.call(this._minWeekdaysParse, llc);
                        return -1 !== ii ? ii : null;
                    } else if ("ddd" === format) {
                        ii = indexOf.call(this._shortWeekdaysParse, llc);
                        if (-1 !== ii) return ii;
                        ii = indexOf.call(this._weekdaysParse, llc);
                        if (-1 !== ii) return ii;
                        ii = indexOf.call(this._minWeekdaysParse, llc);
                        return -1 !== ii ? ii : null;
                    } else {
                        ii = indexOf.call(this._minWeekdaysParse, llc);
                        if (-1 !== ii) return ii;
                        ii = indexOf.call(this._weekdaysParse, llc);
                        if (-1 !== ii) return ii;
                        ii = indexOf.call(this._shortWeekdaysParse, llc);
                        return -1 !== ii ? ii : null;
                    }
                }
                function localeWeekdaysParse(weekdayName, format, strict) {
                    var i, mom, regex;
                    if (this._weekdaysParseExact) return handleStrictParse$1.call(this, weekdayName, format, strict);
                    if (!this._weekdaysParse) {
                        this._weekdaysParse = [];
                        this._minWeekdaysParse = [];
                        this._shortWeekdaysParse = [];
                        this._fullWeekdaysParse = [];
                    }
                    for (i = 0; i < 7; i++) {
                        mom = createUTC([ 2e3, 1 ]).day(i);
                        if (strict && !this._fullWeekdaysParse[i]) {
                            this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
                            this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
                            this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
                        }
                        if (!this._weekdaysParse[i]) {
                            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
                            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
                        }
                        if (strict && "dddd" === format && this._fullWeekdaysParse[i].test(weekdayName)) return i; else if (strict && "ddd" === format && this._shortWeekdaysParse[i].test(weekdayName)) return i; else if (strict && "dd" === format && this._minWeekdaysParse[i].test(weekdayName)) return i; else if (!strict && this._weekdaysParse[i].test(weekdayName)) return i;
                    }
                }
                function getSetDayOfWeek(input) {
                    if (!this.isValid()) return null != input ? this : NaN;
                    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                    if (null != input) {
                        input = parseWeekday(input, this.localeData());
                        return this.add(input - day, "d");
                    } else return day;
                }
                function getSetLocaleDayOfWeek(input) {
                    if (!this.isValid()) return null != input ? this : NaN;
                    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
                    return null == input ? weekday : this.add(input - weekday, "d");
                }
                function getSetISODayOfWeek(input) {
                    if (!this.isValid()) return null != input ? this : NaN;
                    if (null != input) {
                        var weekday = parseIsoWeekday(input, this.localeData());
                        return this.day(this.day() % 7 ? weekday : weekday - 7);
                    } else return this.day() || 7;
                }
                function weekdaysRegex(isStrict) {
                    if (this._weekdaysParseExact) {
                        if (!hasOwnProp(this, "_weekdaysRegex")) computeWeekdaysParse.call(this);
                        if (isStrict) return this._weekdaysStrictRegex; else return this._weekdaysRegex;
                    } else {
                        if (!hasOwnProp(this, "_weekdaysRegex")) this._weekdaysRegex = defaultWeekdaysRegex;
                        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
                    }
                }
                function weekdaysShortRegex(isStrict) {
                    if (this._weekdaysParseExact) {
                        if (!hasOwnProp(this, "_weekdaysRegex")) computeWeekdaysParse.call(this);
                        if (isStrict) return this._weekdaysShortStrictRegex; else return this._weekdaysShortRegex;
                    } else {
                        if (!hasOwnProp(this, "_weekdaysShortRegex")) this._weekdaysShortRegex = defaultWeekdaysShortRegex;
                        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
                    }
                }
                function weekdaysMinRegex(isStrict) {
                    if (this._weekdaysParseExact) {
                        if (!hasOwnProp(this, "_weekdaysRegex")) computeWeekdaysParse.call(this);
                        if (isStrict) return this._weekdaysMinStrictRegex; else return this._weekdaysMinRegex;
                    } else {
                        if (!hasOwnProp(this, "_weekdaysMinRegex")) this._weekdaysMinRegex = defaultWeekdaysMinRegex;
                        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
                    }
                }
                function computeWeekdaysParse() {
                    function cmpLenRev(a, b) {
                        return b.length - a.length;
                    }
                    var i, mom, minp, shortp, longp, minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [];
                    for (i = 0; i < 7; i++) {
                        mom = createUTC([ 2e3, 1 ]).day(i);
                        minp = regexEscape(this.weekdaysMin(mom, ""));
                        shortp = regexEscape(this.weekdaysShort(mom, ""));
                        longp = regexEscape(this.weekdays(mom, ""));
                        minPieces.push(minp);
                        shortPieces.push(shortp);
                        longPieces.push(longp);
                        mixedPieces.push(minp);
                        mixedPieces.push(shortp);
                        mixedPieces.push(longp);
                    }
                    minPieces.sort(cmpLenRev);
                    shortPieces.sort(cmpLenRev);
                    longPieces.sort(cmpLenRev);
                    mixedPieces.sort(cmpLenRev);
                    this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
                    this._weekdaysShortRegex = this._weekdaysRegex;
                    this._weekdaysMinRegex = this._weekdaysRegex;
                    this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
                    this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
                    this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
                }
                function hFormat() {
                    return this.hours() % 12 || 12;
                }
                function kFormat() {
                    return this.hours() || 24;
                }
                addFormatToken("H", [ "HH", 2 ], 0, "hour");
                addFormatToken("h", [ "hh", 2 ], 0, hFormat);
                addFormatToken("k", [ "kk", 2 ], 0, kFormat);
                addFormatToken("hmm", 0, 0, (function() {
                    return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
                }));
                addFormatToken("hmmss", 0, 0, (function() {
                    return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
                }));
                addFormatToken("Hmm", 0, 0, (function() {
                    return "" + this.hours() + zeroFill(this.minutes(), 2);
                }));
                addFormatToken("Hmmss", 0, 0, (function() {
                    return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
                }));
                function meridiem(token, lowercase) {
                    addFormatToken(token, 0, 0, (function() {
                        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
                    }));
                }
                meridiem("a", true);
                meridiem("A", false);
                addUnitAlias("hour", "h");
                addUnitPriority("hour", 13);
                function matchMeridiem(isStrict, locale) {
                    return locale._meridiemParse;
                }
                addRegexToken("a", matchMeridiem);
                addRegexToken("A", matchMeridiem);
                addRegexToken("H", match1to2);
                addRegexToken("h", match1to2);
                addRegexToken("k", match1to2);
                addRegexToken("HH", match1to2, match2);
                addRegexToken("hh", match1to2, match2);
                addRegexToken("kk", match1to2, match2);
                addRegexToken("hmm", match3to4);
                addRegexToken("hmmss", match5to6);
                addRegexToken("Hmm", match3to4);
                addRegexToken("Hmmss", match5to6);
                addParseToken([ "H", "HH" ], HOUR);
                addParseToken([ "k", "kk" ], (function(input, array, config) {
                    var kInput = toInt(input);
                    array[HOUR] = 24 === kInput ? 0 : kInput;
                }));
                addParseToken([ "a", "A" ], (function(input, array, config) {
                    config._isPm = config._locale.isPM(input);
                    config._meridiem = input;
                }));
                addParseToken([ "h", "hh" ], (function(input, array, config) {
                    array[HOUR] = toInt(input);
                    getParsingFlags(config).bigHour = true;
                }));
                addParseToken("hmm", (function(input, array, config) {
                    var pos = input.length - 2;
                    array[HOUR] = toInt(input.substr(0, pos));
                    array[MINUTE] = toInt(input.substr(pos));
                    getParsingFlags(config).bigHour = true;
                }));
                addParseToken("hmmss", (function(input, array, config) {
                    var pos1 = input.length - 4, pos2 = input.length - 2;
                    array[HOUR] = toInt(input.substr(0, pos1));
                    array[MINUTE] = toInt(input.substr(pos1, 2));
                    array[SECOND] = toInt(input.substr(pos2));
                    getParsingFlags(config).bigHour = true;
                }));
                addParseToken("Hmm", (function(input, array, config) {
                    var pos = input.length - 2;
                    array[HOUR] = toInt(input.substr(0, pos));
                    array[MINUTE] = toInt(input.substr(pos));
                }));
                addParseToken("Hmmss", (function(input, array, config) {
                    var pos1 = input.length - 4, pos2 = input.length - 2;
                    array[HOUR] = toInt(input.substr(0, pos1));
                    array[MINUTE] = toInt(input.substr(pos1, 2));
                    array[SECOND] = toInt(input.substr(pos2));
                }));
                function localeIsPM(input) {
                    return "p" === (input + "").toLowerCase().charAt(0);
                }
                var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
                function localeMeridiem(hours, minutes, isLower) {
                    if (hours > 11) return isLower ? "pm" : "PM"; else return isLower ? "am" : "AM";
                }
                var baseConfig = {
                    calendar: defaultCalendar,
                    longDateFormat: defaultLongDateFormat,
                    invalidDate: defaultInvalidDate,
                    ordinal: defaultOrdinal,
                    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
                    relativeTime: defaultRelativeTime,
                    months: defaultLocaleMonths,
                    monthsShort: defaultLocaleMonthsShort,
                    week: defaultLocaleWeek,
                    weekdays: defaultLocaleWeekdays,
                    weekdaysMin: defaultLocaleWeekdaysMin,
                    weekdaysShort: defaultLocaleWeekdaysShort,
                    meridiemParse: defaultLocaleMeridiemParse
                };
                var globalLocale, locales = {}, localeFamilies = {};
                function commonPrefix(arr1, arr2) {
                    var i, minl = Math.min(arr1.length, arr2.length);
                    for (i = 0; i < minl; i += 1) if (arr1[i] !== arr2[i]) return i;
                    return minl;
                }
                function normalizeLocale(key) {
                    return key ? key.toLowerCase().replace("_", "-") : key;
                }
                function chooseLocale(names) {
                    var j, next, locale, split, i = 0;
                    while (i < names.length) {
                        split = normalizeLocale(names[i]).split("-");
                        j = split.length;
                        next = normalizeLocale(names[i + 1]);
                        next = next ? next.split("-") : null;
                        while (j > 0) {
                            locale = loadLocale(split.slice(0, j).join("-"));
                            if (locale) return locale;
                            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) break;
                            j--;
                        }
                        i++;
                    }
                    return globalLocale;
                }
                function isLocaleNameSane(name) {
                    return null != name.match("^[^/\\\\]*$");
                }
                function loadLocale(name) {
                    var oldLocale = null;
                    if (void 0 === locales[name] && "object" !== "undefined" && module && module.exports && isLocaleNameSane(name)) try {
                        oldLocale = globalLocale._abbr;
                        void 0;
                        __webpack_require__(6700)("./" + name);
                        getSetGlobalLocale(oldLocale);
                    } catch (e) {
                        locales[name] = null;
                    }
                    return locales[name];
                }
                function getSetGlobalLocale(key, values) {
                    var data;
                    if (key) {
                        if (isUndefined(values)) data = getLocale(key); else data = defineLocale(key, values);
                        if (data) globalLocale = data; else if ("undefined" !== typeof console && console.warn) console.warn("Locale " + key + " not found. Did you forget to load it?");
                    }
                    return globalLocale._abbr;
                }
                function defineLocale(name, config) {
                    if (null !== config) {
                        var locale, parentConfig = baseConfig;
                        config.abbr = name;
                        if (null != locales[name]) {
                            deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change " + "an existing locale. moment.defineLocale(localeName, " + "config) should only be used for creating a new locale " + "See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
                            parentConfig = locales[name]._config;
                        } else if (null != config.parentLocale) if (null != locales[config.parentLocale]) parentConfig = locales[config.parentLocale]._config; else {
                            locale = loadLocale(config.parentLocale);
                            if (null != locale) parentConfig = locale._config; else {
                                if (!localeFamilies[config.parentLocale]) localeFamilies[config.parentLocale] = [];
                                localeFamilies[config.parentLocale].push({
                                    name,
                                    config
                                });
                                return null;
                            }
                        }
                        locales[name] = new Locale(mergeConfigs(parentConfig, config));
                        if (localeFamilies[name]) localeFamilies[name].forEach((function(x) {
                            defineLocale(x.name, x.config);
                        }));
                        getSetGlobalLocale(name);
                        return locales[name];
                    } else {
                        delete locales[name];
                        return null;
                    }
                }
                function updateLocale(name, config) {
                    if (null != config) {
                        var locale, tmpLocale, parentConfig = baseConfig;
                        if (null != locales[name] && null != locales[name].parentLocale) locales[name].set(mergeConfigs(locales[name]._config, config)); else {
                            tmpLocale = loadLocale(name);
                            if (null != tmpLocale) parentConfig = tmpLocale._config;
                            config = mergeConfigs(parentConfig, config);
                            if (null == tmpLocale) config.abbr = name;
                            locale = new Locale(config);
                            locale.parentLocale = locales[name];
                            locales[name] = locale;
                        }
                        getSetGlobalLocale(name);
                    } else if (null != locales[name]) if (null != locales[name].parentLocale) {
                        locales[name] = locales[name].parentLocale;
                        if (name === getSetGlobalLocale()) getSetGlobalLocale(name);
                    } else if (null != locales[name]) delete locales[name];
                    return locales[name];
                }
                function getLocale(key) {
                    var locale;
                    if (key && key._locale && key._locale._abbr) key = key._locale._abbr;
                    if (!key) return globalLocale;
                    if (!isArray(key)) {
                        locale = loadLocale(key);
                        if (locale) return locale;
                        key = [ key ];
                    }
                    return chooseLocale(key);
                }
                function listLocales() {
                    return keys(locales);
                }
                function checkOverflow(m) {
                    var overflow, a = m._a;
                    if (a && -2 === getParsingFlags(m).overflow) {
                        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || 24 === a[HOUR] && (0 !== a[MINUTE] || 0 !== a[SECOND] || 0 !== a[MILLISECOND]) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
                        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) overflow = DATE;
                        if (getParsingFlags(m)._overflowWeeks && -1 === overflow) overflow = WEEK;
                        if (getParsingFlags(m)._overflowWeekday && -1 === overflow) overflow = WEEKDAY;
                        getParsingFlags(m).overflow = overflow;
                    }
                    return m;
                }
                var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [ [ "YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/ ], [ "YYYY-MM-DD", /\d{4}-\d\d-\d\d/ ], [ "GGGG-[W]WW-E", /\d{4}-W\d\d-\d/ ], [ "GGGG-[W]WW", /\d{4}-W\d\d/, false ], [ "YYYY-DDD", /\d{4}-\d{3}/ ], [ "YYYY-MM", /\d{4}-\d\d/, false ], [ "YYYYYYMMDD", /[+-]\d{10}/ ], [ "YYYYMMDD", /\d{8}/ ], [ "GGGG[W]WWE", /\d{4}W\d{3}/ ], [ "GGGG[W]WW", /\d{4}W\d{2}/, false ], [ "YYYYDDD", /\d{7}/ ], [ "YYYYMM", /\d{6}/, false ], [ "YYYY", /\d{4}/, false ] ], isoTimes = [ [ "HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/ ], [ "HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/ ], [ "HH:mm:ss", /\d\d:\d\d:\d\d/ ], [ "HH:mm", /\d\d:\d\d/ ], [ "HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/ ], [ "HHmmss,SSSS", /\d\d\d\d\d\d,\d+/ ], [ "HHmmss", /\d\d\d\d\d\d/ ], [ "HHmm", /\d\d\d\d/ ], [ "HH", /\d\d/ ] ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
                    UT: 0,
                    GMT: 0,
                    EDT: -4 * 60,
                    EST: -5 * 60,
                    CDT: -5 * 60,
                    CST: -6 * 60,
                    MDT: -6 * 60,
                    MST: -7 * 60,
                    PDT: -7 * 60,
                    PST: -8 * 60
                };
                function configFromISO(config) {
                    var i, l, allowTime, dateFormat, timeFormat, tzFormat, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
                    if (match) {
                        getParsingFlags(config).iso = true;
                        for (i = 0, l = isoDatesLen; i < l; i++) if (isoDates[i][1].exec(match[1])) {
                            dateFormat = isoDates[i][0];
                            allowTime = false !== isoDates[i][2];
                            break;
                        }
                        if (null == dateFormat) {
                            config._isValid = false;
                            return;
                        }
                        if (match[3]) {
                            for (i = 0, l = isoTimesLen; i < l; i++) if (isoTimes[i][1].exec(match[3])) {
                                timeFormat = (match[2] || " ") + isoTimes[i][0];
                                break;
                            }
                            if (null == timeFormat) {
                                config._isValid = false;
                                return;
                            }
                        }
                        if (!allowTime && null != timeFormat) {
                            config._isValid = false;
                            return;
                        }
                        if (match[4]) if (tzRegex.exec(match[4])) tzFormat = "Z"; else {
                            config._isValid = false;
                            return;
                        }
                        config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
                        configFromStringAndFormat(config);
                    } else config._isValid = false;
                }
                function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
                    var result = [ untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10) ];
                    if (secondStr) result.push(parseInt(secondStr, 10));
                    return result;
                }
                function untruncateYear(yearStr) {
                    var year = parseInt(yearStr, 10);
                    if (year <= 49) return 2e3 + year; else if (year <= 999) return 1900 + year;
                    return year;
                }
                function preprocessRFC2822(s) {
                    return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
                }
                function checkWeekday(weekdayStr, parsedInput, config) {
                    if (weekdayStr) {
                        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
                        if (weekdayProvided !== weekdayActual) {
                            getParsingFlags(config).weekdayMismatch = true;
                            config._isValid = false;
                            return false;
                        }
                    }
                    return true;
                }
                function calculateOffset(obsOffset, militaryOffset, numOffset) {
                    if (obsOffset) return obsOffsets[obsOffset]; else if (militaryOffset) return 0; else {
                        var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
                        return 60 * h + m;
                    }
                }
                function configFromRFC2822(config) {
                    var parsedArray, match = rfc2822.exec(preprocessRFC2822(config._i));
                    if (match) {
                        parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
                        if (!checkWeekday(match[1], parsedArray, config)) return;
                        config._a = parsedArray;
                        config._tzm = calculateOffset(match[8], match[9], match[10]);
                        config._d = createUTCDate.apply(null, config._a);
                        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
                        getParsingFlags(config).rfc2822 = true;
                    } else config._isValid = false;
                }
                function configFromString(config) {
                    var matched = aspNetJsonRegex.exec(config._i);
                    if (null !== matched) {
                        config._d = new Date(+matched[1]);
                        return;
                    }
                    configFromISO(config);
                    if (false === config._isValid) delete config._isValid; else return;
                    configFromRFC2822(config);
                    if (false === config._isValid) delete config._isValid; else return;
                    if (config._strict) config._isValid = false; else hooks.createFromInputFallback(config);
                }
                hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), " + "which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are " + "discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", (function(config) {
                    config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
                }));
                function defaults(a, b, c) {
                    if (null != a) return a;
                    if (null != b) return b;
                    return c;
                }
                function currentDateArray(config) {
                    var nowValue = new Date(hooks.now());
                    if (config._useUTC) return [ nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate() ];
                    return [ nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate() ];
                }
                function configFromArray(config) {
                    var i, date, currentDate, expectedWeekday, yearToUse, input = [];
                    if (config._d) return;
                    currentDate = currentDateArray(config);
                    if (config._w && null == config._a[DATE] && null == config._a[MONTH]) dayOfYearFromWeekInfo(config);
                    if (null != config._dayOfYear) {
                        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
                        if (config._dayOfYear > daysInYear(yearToUse) || 0 === config._dayOfYear) getParsingFlags(config)._overflowDayOfYear = true;
                        date = createUTCDate(yearToUse, 0, config._dayOfYear);
                        config._a[MONTH] = date.getUTCMonth();
                        config._a[DATE] = date.getUTCDate();
                    }
                    for (i = 0; i < 3 && null == config._a[i]; ++i) config._a[i] = input[i] = currentDate[i];
                    for (;i < 7; i++) config._a[i] = input[i] = null == config._a[i] ? 2 === i ? 1 : 0 : config._a[i];
                    if (24 === config._a[HOUR] && 0 === config._a[MINUTE] && 0 === config._a[SECOND] && 0 === config._a[MILLISECOND]) {
                        config._nextDay = true;
                        config._a[HOUR] = 0;
                    }
                    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
                    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
                    if (null != config._tzm) config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
                    if (config._nextDay) config._a[HOUR] = 24;
                    if (config._w && "undefined" !== typeof config._w.d && config._w.d !== expectedWeekday) getParsingFlags(config).weekdayMismatch = true;
                }
                function dayOfYearFromWeekInfo(config) {
                    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
                    w = config._w;
                    if (null != w.GG || null != w.W || null != w.E) {
                        dow = 1;
                        doy = 4;
                        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
                        week = defaults(w.W, 1);
                        weekday = defaults(w.E, 1);
                        if (weekday < 1 || weekday > 7) weekdayOverflow = true;
                    } else {
                        dow = config._locale._week.dow;
                        doy = config._locale._week.doy;
                        curWeek = weekOfYear(createLocal(), dow, doy);
                        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
                        week = defaults(w.w, curWeek.week);
                        if (null != w.d) {
                            weekday = w.d;
                            if (weekday < 0 || weekday > 6) weekdayOverflow = true;
                        } else if (null != w.e) {
                            weekday = w.e + dow;
                            if (w.e < 0 || w.e > 6) weekdayOverflow = true;
                        } else weekday = dow;
                    }
                    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) getParsingFlags(config)._overflowWeeks = true; else if (null != weekdayOverflow) getParsingFlags(config)._overflowWeekday = true; else {
                        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
                        config._a[YEAR] = temp.year;
                        config._dayOfYear = temp.dayOfYear;
                    }
                }
                hooks.ISO_8601 = function() {};
                hooks.RFC_2822 = function() {};
                function configFromStringAndFormat(config) {
                    if (config._f === hooks.ISO_8601) {
                        configFromISO(config);
                        return;
                    }
                    if (config._f === hooks.RFC_2822) {
                        configFromRFC2822(config);
                        return;
                    }
                    config._a = [];
                    getParsingFlags(config).empty = true;
                    var i, parsedInput, tokens, token, skipped, era, tokenLen, string = "" + config._i, stringLength = string.length, totalParsedInputLength = 0;
                    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
                    tokenLen = tokens.length;
                    for (i = 0; i < tokenLen; i++) {
                        token = tokens[i];
                        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
                        if (parsedInput) {
                            skipped = string.substr(0, string.indexOf(parsedInput));
                            if (skipped.length > 0) getParsingFlags(config).unusedInput.push(skipped);
                            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                            totalParsedInputLength += parsedInput.length;
                        }
                        if (formatTokenFunctions[token]) {
                            if (parsedInput) getParsingFlags(config).empty = false; else getParsingFlags(config).unusedTokens.push(token);
                            addTimeToArrayFromToken(token, parsedInput, config);
                        } else if (config._strict && !parsedInput) getParsingFlags(config).unusedTokens.push(token);
                    }
                    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
                    if (string.length > 0) getParsingFlags(config).unusedInput.push(string);
                    if (config._a[HOUR] <= 12 && true === getParsingFlags(config).bigHour && config._a[HOUR] > 0) getParsingFlags(config).bigHour = void 0;
                    getParsingFlags(config).parsedDateParts = config._a.slice(0);
                    getParsingFlags(config).meridiem = config._meridiem;
                    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
                    era = getParsingFlags(config).era;
                    if (null !== era) config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
                    configFromArray(config);
                    checkOverflow(config);
                }
                function meridiemFixWrap(locale, hour, meridiem) {
                    var isPm;
                    if (null == meridiem) return hour;
                    if (null != locale.meridiemHour) return locale.meridiemHour(hour, meridiem); else if (null != locale.isPM) {
                        isPm = locale.isPM(meridiem);
                        if (isPm && hour < 12) hour += 12;
                        if (!isPm && 12 === hour) hour = 0;
                        return hour;
                    } else return hour;
                }
                function configFromStringAndArray(config) {
                    var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
                    if (0 === configfLen) {
                        getParsingFlags(config).invalidFormat = true;
                        config._d = new Date(NaN);
                        return;
                    }
                    for (i = 0; i < configfLen; i++) {
                        currentScore = 0;
                        validFormatFound = false;
                        tempConfig = copyConfig({}, config);
                        if (null != config._useUTC) tempConfig._useUTC = config._useUTC;
                        tempConfig._f = config._f[i];
                        configFromStringAndFormat(tempConfig);
                        if (isValid(tempConfig)) validFormatFound = true;
                        currentScore += getParsingFlags(tempConfig).charsLeftOver;
                        currentScore += 10 * getParsingFlags(tempConfig).unusedTokens.length;
                        getParsingFlags(tempConfig).score = currentScore;
                        if (!bestFormatIsValid) {
                            if (null == scoreToBeat || currentScore < scoreToBeat || validFormatFound) {
                                scoreToBeat = currentScore;
                                bestMoment = tempConfig;
                                if (validFormatFound) bestFormatIsValid = true;
                            }
                        } else if (currentScore < scoreToBeat) {
                            scoreToBeat = currentScore;
                            bestMoment = tempConfig;
                        }
                    }
                    extend(config, bestMoment || tempConfig);
                }
                function configFromObject(config) {
                    if (config._d) return;
                    var i = normalizeObjectUnits(config._i), dayOrDate = void 0 === i.day ? i.date : i.day;
                    config._a = map([ i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond ], (function(obj) {
                        return obj && parseInt(obj, 10);
                    }));
                    configFromArray(config);
                }
                function createFromConfig(config) {
                    var res = new Moment(checkOverflow(prepareConfig(config)));
                    if (res._nextDay) {
                        res.add(1, "d");
                        res._nextDay = void 0;
                    }
                    return res;
                }
                function prepareConfig(config) {
                    var input = config._i, format = config._f;
                    config._locale = config._locale || getLocale(config._l);
                    if (null === input || void 0 === format && "" === input) return createInvalid({
                        nullInput: true
                    });
                    if ("string" === typeof input) config._i = input = config._locale.preparse(input);
                    if (isMoment(input)) return new Moment(checkOverflow(input)); else if (isDate(input)) config._d = input; else if (isArray(format)) configFromStringAndArray(config); else if (format) configFromStringAndFormat(config); else configFromInput(config);
                    if (!isValid(config)) config._d = null;
                    return config;
                }
                function configFromInput(config) {
                    var input = config._i;
                    if (isUndefined(input)) config._d = new Date(hooks.now()); else if (isDate(input)) config._d = new Date(input.valueOf()); else if ("string" === typeof input) configFromString(config); else if (isArray(input)) {
                        config._a = map(input.slice(0), (function(obj) {
                            return parseInt(obj, 10);
                        }));
                        configFromArray(config);
                    } else if (isObject(input)) configFromObject(config); else if (isNumber(input)) config._d = new Date(input); else hooks.createFromInputFallback(config);
                }
                function createLocalOrUTC(input, format, locale, strict, isUTC) {
                    var c = {};
                    if (true === format || false === format) {
                        strict = format;
                        format = void 0;
                    }
                    if (true === locale || false === locale) {
                        strict = locale;
                        locale = void 0;
                    }
                    if (isObject(input) && isObjectEmpty(input) || isArray(input) && 0 === input.length) input = void 0;
                    c._isAMomentObject = true;
                    c._useUTC = c._isUTC = isUTC;
                    c._l = locale;
                    c._i = input;
                    c._f = format;
                    c._strict = strict;
                    return createFromConfig(c);
                }
                function createLocal(input, format, locale, strict) {
                    return createLocalOrUTC(input, format, locale, strict, false);
                }
                var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", (function() {
                    var other = createLocal.apply(null, arguments);
                    if (this.isValid() && other.isValid()) return other < this ? this : other; else return createInvalid();
                })), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", (function() {
                    var other = createLocal.apply(null, arguments);
                    if (this.isValid() && other.isValid()) return other > this ? this : other; else return createInvalid();
                }));
                function pickBy(fn, moments) {
                    var res, i;
                    if (1 === moments.length && isArray(moments[0])) moments = moments[0];
                    if (!moments.length) return createLocal();
                    res = moments[0];
                    for (i = 1; i < moments.length; ++i) if (!moments[i].isValid() || moments[i][fn](res)) res = moments[i];
                    return res;
                }
                function min() {
                    var args = [].slice.call(arguments, 0);
                    return pickBy("isBefore", args);
                }
                function max() {
                    var args = [].slice.call(arguments, 0);
                    return pickBy("isAfter", args);
                }
                var now = function() {
                    return Date.now ? Date.now() : +new Date;
                };
                var ordering = [ "year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond" ];
                function isDurationValid(m) {
                    var key, i, unitHasDecimal = false, orderLen = ordering.length;
                    for (key in m) if (hasOwnProp(m, key) && !(-1 !== indexOf.call(ordering, key) && (null == m[key] || !isNaN(m[key])))) return false;
                    for (i = 0; i < orderLen; ++i) if (m[ordering[i]]) {
                        if (unitHasDecimal) return false;
                        if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) unitHasDecimal = true;
                    }
                    return true;
                }
                function isValid$1() {
                    return this._isValid;
                }
                function createInvalid$1() {
                    return createDuration(NaN);
                }
                function Duration(duration) {
                    var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || normalizedInput.isoWeek || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
                    this._isValid = isDurationValid(normalizedInput);
                    this._milliseconds = +milliseconds + 1e3 * seconds + 6e4 * minutes + 1e3 * hours * 60 * 60;
                    this._days = +days + 7 * weeks;
                    this._months = +months + 3 * quarters + 12 * years;
                    this._data = {};
                    this._locale = getLocale();
                    this._bubble();
                }
                function isDuration(obj) {
                    return obj instanceof Duration;
                }
                function absRound(number) {
                    if (number < 0) return -1 * Math.round(-1 * number); else return Math.round(number);
                }
                function compareArrays(array1, array2, dontConvert) {
                    var i, len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0;
                    for (i = 0; i < len; i++) if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) diffs++;
                    return diffs + lengthDiff;
                }
                function offset(token, separator) {
                    addFormatToken(token, 0, 0, (function() {
                        var offset = this.utcOffset(), sign = "+";
                        if (offset < 0) {
                            offset = -offset;
                            sign = "-";
                        }
                        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
                    }));
                }
                offset("Z", ":");
                offset("ZZ", "");
                addRegexToken("Z", matchShortOffset);
                addRegexToken("ZZ", matchShortOffset);
                addParseToken([ "Z", "ZZ" ], (function(input, array, config) {
                    config._useUTC = true;
                    config._tzm = offsetFromString(matchShortOffset, input);
                }));
                var chunkOffset = /([\+\-]|\d\d)/gi;
                function offsetFromString(matcher, string) {
                    var chunk, parts, minutes, matches = (string || "").match(matcher);
                    if (null === matches) return null;
                    chunk = matches[matches.length - 1] || [];
                    parts = (chunk + "").match(chunkOffset) || [ "-", 0, 0 ];
                    minutes = +60 * parts[1] + toInt(parts[2]);
                    return 0 === minutes ? 0 : "+" === parts[0] ? minutes : -minutes;
                }
                function cloneWithOffset(input, model) {
                    var res, diff;
                    if (model._isUTC) {
                        res = model.clone();
                        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
                        res._d.setTime(res._d.valueOf() + diff);
                        hooks.updateOffset(res, false);
                        return res;
                    } else return createLocal(input).local();
                }
                function getDateOffset(m) {
                    return -Math.round(m._d.getTimezoneOffset());
                }
                hooks.updateOffset = function() {};
                function getSetOffset(input, keepLocalTime, keepMinutes) {
                    var localAdjust, offset = this._offset || 0;
                    if (!this.isValid()) return null != input ? this : NaN;
                    if (null != input) {
                        if ("string" === typeof input) {
                            input = offsetFromString(matchShortOffset, input);
                            if (null === input) return this;
                        } else if (Math.abs(input) < 16 && !keepMinutes) input *= 60;
                        if (!this._isUTC && keepLocalTime) localAdjust = getDateOffset(this);
                        this._offset = input;
                        this._isUTC = true;
                        if (null != localAdjust) this.add(localAdjust, "m");
                        if (offset !== input) if (!keepLocalTime || this._changeInProgress) addSubtract(this, createDuration(input - offset, "m"), 1, false); else if (!this._changeInProgress) {
                            this._changeInProgress = true;
                            hooks.updateOffset(this, true);
                            this._changeInProgress = null;
                        }
                        return this;
                    } else return this._isUTC ? offset : getDateOffset(this);
                }
                function getSetZone(input, keepLocalTime) {
                    if (null != input) {
                        if ("string" !== typeof input) input = -input;
                        this.utcOffset(input, keepLocalTime);
                        return this;
                    } else return -this.utcOffset();
                }
                function setOffsetToUTC(keepLocalTime) {
                    return this.utcOffset(0, keepLocalTime);
                }
                function setOffsetToLocal(keepLocalTime) {
                    if (this._isUTC) {
                        this.utcOffset(0, keepLocalTime);
                        this._isUTC = false;
                        if (keepLocalTime) this.subtract(getDateOffset(this), "m");
                    }
                    return this;
                }
                function setOffsetToParsedOffset() {
                    if (null != this._tzm) this.utcOffset(this._tzm, false, true); else if ("string" === typeof this._i) {
                        var tZone = offsetFromString(matchOffset, this._i);
                        if (null != tZone) this.utcOffset(tZone); else this.utcOffset(0, true);
                    }
                    return this;
                }
                function hasAlignedHourOffset(input) {
                    if (!this.isValid()) return false;
                    input = input ? createLocal(input).utcOffset() : 0;
                    return (this.utcOffset() - input) % 60 === 0;
                }
                function isDaylightSavingTime() {
                    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
                }
                function isDaylightSavingTimeShifted() {
                    if (!isUndefined(this._isDSTShifted)) return this._isDSTShifted;
                    var other, c = {};
                    copyConfig(c, this);
                    c = prepareConfig(c);
                    if (c._a) {
                        other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
                        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
                    } else this._isDSTShifted = false;
                    return this._isDSTShifted;
                }
                function isLocal() {
                    return this.isValid() ? !this._isUTC : false;
                }
                function isUtcOffset() {
                    return this.isValid() ? this._isUTC : false;
                }
                function isUtc() {
                    return this.isValid() ? this._isUTC && 0 === this._offset : false;
                }
                var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
                function createDuration(input, key) {
                    var sign, ret, diffRes, duration = input, match = null;
                    if (isDuration(input)) duration = {
                        ms: input._milliseconds,
                        d: input._days,
                        M: input._months
                    }; else if (isNumber(input) || !isNaN(+input)) {
                        duration = {};
                        if (key) duration[key] = +input; else duration.milliseconds = +input;
                    } else if (match = aspNetRegex.exec(input)) {
                        sign = "-" === match[1] ? -1 : 1;
                        duration = {
                            y: 0,
                            d: toInt(match[DATE]) * sign,
                            h: toInt(match[HOUR]) * sign,
                            m: toInt(match[MINUTE]) * sign,
                            s: toInt(match[SECOND]) * sign,
                            ms: toInt(absRound(1e3 * match[MILLISECOND])) * sign
                        };
                    } else if (match = isoRegex.exec(input)) {
                        sign = "-" === match[1] ? -1 : 1;
                        duration = {
                            y: parseIso(match[2], sign),
                            M: parseIso(match[3], sign),
                            w: parseIso(match[4], sign),
                            d: parseIso(match[5], sign),
                            h: parseIso(match[6], sign),
                            m: parseIso(match[7], sign),
                            s: parseIso(match[8], sign)
                        };
                    } else if (null == duration) duration = {}; else if ("object" === typeof duration && ("from" in duration || "to" in duration)) {
                        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
                        duration = {};
                        duration.ms = diffRes.milliseconds;
                        duration.M = diffRes.months;
                    }
                    ret = new Duration(duration);
                    if (isDuration(input) && hasOwnProp(input, "_locale")) ret._locale = input._locale;
                    if (isDuration(input) && hasOwnProp(input, "_isValid")) ret._isValid = input._isValid;
                    return ret;
                }
                createDuration.fn = Duration.prototype;
                createDuration.invalid = createInvalid$1;
                function parseIso(inp, sign) {
                    var res = inp && parseFloat(inp.replace(",", "."));
                    return (isNaN(res) ? 0 : res) * sign;
                }
                function positiveMomentsDifference(base, other) {
                    var res = {};
                    res.months = other.month() - base.month() + 12 * (other.year() - base.year());
                    if (base.clone().add(res.months, "M").isAfter(other)) --res.months;
                    res.milliseconds = +other - +base.clone().add(res.months, "M");
                    return res;
                }
                function momentsDifference(base, other) {
                    var res;
                    if (!(base.isValid() && other.isValid())) return {
                        milliseconds: 0,
                        months: 0
                    };
                    other = cloneWithOffset(other, base);
                    if (base.isBefore(other)) res = positiveMomentsDifference(base, other); else {
                        res = positiveMomentsDifference(other, base);
                        res.milliseconds = -res.milliseconds;
                        res.months = -res.months;
                    }
                    return res;
                }
                function createAdder(direction, name) {
                    return function(val, period) {
                        var dur, tmp;
                        if (null !== period && !isNaN(+period)) {
                            deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). " + "See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
                            tmp = val;
                            val = period;
                            period = tmp;
                        }
                        dur = createDuration(val, period);
                        addSubtract(this, dur, direction);
                        return this;
                    };
                }
                function addSubtract(mom, duration, isAdding, updateOffset) {
                    var milliseconds = duration._milliseconds, days = absRound(duration._days), months = absRound(duration._months);
                    if (!mom.isValid()) return;
                    updateOffset = null == updateOffset ? true : updateOffset;
                    if (months) setMonth(mom, get(mom, "Month") + months * isAdding);
                    if (days) set$1(mom, "Date", get(mom, "Date") + days * isAdding);
                    if (milliseconds) mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
                    if (updateOffset) hooks.updateOffset(mom, days || months);
                }
                var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
                function isString(input) {
                    return "string" === typeof input || input instanceof String;
                }
                function isMomentInput(input) {
                    return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || null === input || void 0 === input;
                }
                function isMomentInputObject(input) {
                    var i, property, objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [ "years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour", "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms" ], propertyLen = properties.length;
                    for (i = 0; i < propertyLen; i += 1) {
                        property = properties[i];
                        propertyTest = propertyTest || hasOwnProp(input, property);
                    }
                    return objectTest && propertyTest;
                }
                function isNumberOrStringArray(input) {
                    var arrayTest = isArray(input), dataTypeTest = false;
                    if (arrayTest) dataTypeTest = 0 === input.filter((function(item) {
                        return !isNumber(item) && isString(input);
                    })).length;
                    return arrayTest && dataTypeTest;
                }
                function isCalendarSpec(input) {
                    var i, property, objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [ "sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse" ];
                    for (i = 0; i < properties.length; i += 1) {
                        property = properties[i];
                        propertyTest = propertyTest || hasOwnProp(input, property);
                    }
                    return objectTest && propertyTest;
                }
                function getCalendarFormat(myMoment, now) {
                    var diff = myMoment.diff(now, "days", true);
                    return diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
                }
                function calendar$1(time, formats) {
                    if (1 === arguments.length) if (!arguments[0]) {
                        time = void 0;
                        formats = void 0;
                    } else if (isMomentInput(arguments[0])) {
                        time = arguments[0];
                        formats = void 0;
                    } else if (isCalendarSpec(arguments[0])) {
                        formats = arguments[0];
                        time = void 0;
                    }
                    var now = time || createLocal(), sod = cloneWithOffset(now, this).startOf("day"), format = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
                    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
                }
                function clone() {
                    return new Moment(this);
                }
                function isAfter(input, units) {
                    var localInput = isMoment(input) ? input : createLocal(input);
                    if (!(this.isValid() && localInput.isValid())) return false;
                    units = normalizeUnits(units) || "millisecond";
                    if ("millisecond" === units) return this.valueOf() > localInput.valueOf(); else return localInput.valueOf() < this.clone().startOf(units).valueOf();
                }
                function isBefore(input, units) {
                    var localInput = isMoment(input) ? input : createLocal(input);
                    if (!(this.isValid() && localInput.isValid())) return false;
                    units = normalizeUnits(units) || "millisecond";
                    if ("millisecond" === units) return this.valueOf() < localInput.valueOf(); else return this.clone().endOf(units).valueOf() < localInput.valueOf();
                }
                function isBetween(from, to, units, inclusivity) {
                    var localFrom = isMoment(from) ? from : createLocal(from), localTo = isMoment(to) ? to : createLocal(to);
                    if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) return false;
                    inclusivity = inclusivity || "()";
                    return ("(" === inclusivity[0] ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (")" === inclusivity[1] ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
                }
                function isSame(input, units) {
                    var inputMs, localInput = isMoment(input) ? input : createLocal(input);
                    if (!(this.isValid() && localInput.isValid())) return false;
                    units = normalizeUnits(units) || "millisecond";
                    if ("millisecond" === units) return this.valueOf() === localInput.valueOf(); else {
                        inputMs = localInput.valueOf();
                        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
                    }
                }
                function isSameOrAfter(input, units) {
                    return this.isSame(input, units) || this.isAfter(input, units);
                }
                function isSameOrBefore(input, units) {
                    return this.isSame(input, units) || this.isBefore(input, units);
                }
                function diff(input, units, asFloat) {
                    var that, zoneDelta, output;
                    if (!this.isValid()) return NaN;
                    that = cloneWithOffset(input, this);
                    if (!that.isValid()) return NaN;
                    zoneDelta = 6e4 * (that.utcOffset() - this.utcOffset());
                    units = normalizeUnits(units);
                    switch (units) {
                      case "year":
                        output = monthDiff(this, that) / 12;
                        break;

                      case "month":
                        output = monthDiff(this, that);
                        break;

                      case "quarter":
                        output = monthDiff(this, that) / 3;
                        break;

                      case "second":
                        output = (this - that) / 1e3;
                        break;

                      case "minute":
                        output = (this - that) / 6e4;
                        break;

                      case "hour":
                        output = (this - that) / 36e5;
                        break;

                      case "day":
                        output = (this - that - zoneDelta) / 864e5;
                        break;

                      case "week":
                        output = (this - that - zoneDelta) / 6048e5;
                        break;

                      default:
                        output = this - that;
                    }
                    return asFloat ? output : absFloor(output);
                }
                function monthDiff(a, b) {
                    if (a.date() < b.date()) return -monthDiff(b, a);
                    var anchor2, adjust, wholeMonthDiff = 12 * (b.year() - a.year()) + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months");
                    if (b - anchor < 0) {
                        anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
                        adjust = (b - anchor) / (anchor - anchor2);
                    } else {
                        anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
                        adjust = (b - anchor) / (anchor2 - anchor);
                    }
                    return -(wholeMonthDiff + adjust) || 0;
                }
                hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
                hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
                function toString() {
                    return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
                }
                function toISOString(keepOffset) {
                    if (!this.isValid()) return null;
                    var utc = true !== keepOffset, m = utc ? this.clone().utc() : this;
                    if (m.year() < 0 || m.year() > 9999) return formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
                    if (isFunction(Date.prototype.toISOString)) if (utc) return this.toDate().toISOString(); else return new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
                    return formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
                }
                function inspect() {
                    if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
                    var prefix, year, datetime, suffix, func = "moment", zone = "";
                    if (!this.isLocal()) {
                        func = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone";
                        zone = "Z";
                    }
                    prefix = "[" + func + '("]';
                    year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
                    datetime = "-MM-DD[T]HH:mm:ss.SSS";
                    suffix = zone + '[")]';
                    return this.format(prefix + year + datetime + suffix);
                }
                function format(inputString) {
                    if (!inputString) inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
                    var output = formatMoment(this, inputString);
                    return this.localeData().postformat(output);
                }
                function from(time, withoutSuffix) {
                    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) return createDuration({
                        to: this,
                        from: time
                    }).locale(this.locale()).humanize(!withoutSuffix); else return this.localeData().invalidDate();
                }
                function fromNow(withoutSuffix) {
                    return this.from(createLocal(), withoutSuffix);
                }
                function to(time, withoutSuffix) {
                    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) return createDuration({
                        from: this,
                        to: time
                    }).locale(this.locale()).humanize(!withoutSuffix); else return this.localeData().invalidDate();
                }
                function toNow(withoutSuffix) {
                    return this.to(createLocal(), withoutSuffix);
                }
                function locale(key) {
                    var newLocaleData;
                    if (void 0 === key) return this._locale._abbr; else {
                        newLocaleData = getLocale(key);
                        if (null != newLocaleData) this._locale = newLocaleData;
                        return this;
                    }
                }
                var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", (function(key) {
                    if (void 0 === key) return this.localeData(); else return this.locale(key);
                }));
                function localeData() {
                    return this._locale;
                }
                var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = 24 * (365 * 400 + 97) * MS_PER_HOUR;
                function mod$1(dividend, divisor) {
                    return (dividend % divisor + divisor) % divisor;
                }
                function localStartOfDate(y, m, d) {
                    if (y < 100 && y >= 0) return new Date(y + 400, m, d) - MS_PER_400_YEARS; else return new Date(y, m, d).valueOf();
                }
                function utcStartOfDate(y, m, d) {
                    if (y < 100 && y >= 0) return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS; else return Date.UTC(y, m, d);
                }
                function startOf(units) {
                    var time, startOfDate;
                    units = normalizeUnits(units);
                    if (void 0 === units || "millisecond" === units || !this.isValid()) return this;
                    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
                    switch (units) {
                      case "year":
                        time = startOfDate(this.year(), 0, 1);
                        break;

                      case "quarter":
                        time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
                        break;

                      case "month":
                        time = startOfDate(this.year(), this.month(), 1);
                        break;

                      case "week":
                        time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                        break;

                      case "isoWeek":
                        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                        break;

                      case "day":
                      case "date":
                        time = startOfDate(this.year(), this.month(), this.date());
                        break;

                      case "hour":
                        time = this._d.valueOf();
                        time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
                        break;

                      case "minute":
                        time = this._d.valueOf();
                        time -= mod$1(time, MS_PER_MINUTE);
                        break;

                      case "second":
                        time = this._d.valueOf();
                        time -= mod$1(time, MS_PER_SECOND);
                        break;
                    }
                    this._d.setTime(time);
                    hooks.updateOffset(this, true);
                    return this;
                }
                function endOf(units) {
                    var time, startOfDate;
                    units = normalizeUnits(units);
                    if (void 0 === units || "millisecond" === units || !this.isValid()) return this;
                    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
                    switch (units) {
                      case "year":
                        time = startOfDate(this.year() + 1, 0, 1) - 1;
                        break;

                      case "quarter":
                        time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                        break;

                      case "month":
                        time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                        break;

                      case "week":
                        time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                        break;

                      case "isoWeek":
                        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                        break;

                      case "day":
                      case "date":
                        time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                        break;

                      case "hour":
                        time = this._d.valueOf();
                        time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
                        break;

                      case "minute":
                        time = this._d.valueOf();
                        time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                        break;

                      case "second":
                        time = this._d.valueOf();
                        time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                        break;
                    }
                    this._d.setTime(time);
                    hooks.updateOffset(this, true);
                    return this;
                }
                function valueOf() {
                    return this._d.valueOf() - 6e4 * (this._offset || 0);
                }
                function unix() {
                    return Math.floor(this.valueOf() / 1e3);
                }
                function toDate() {
                    return new Date(this.valueOf());
                }
                function toArray() {
                    var m = this;
                    return [ m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond() ];
                }
                function toObject() {
                    var m = this;
                    return {
                        years: m.year(),
                        months: m.month(),
                        date: m.date(),
                        hours: m.hours(),
                        minutes: m.minutes(),
                        seconds: m.seconds(),
                        milliseconds: m.milliseconds()
                    };
                }
                function toJSON() {
                    return this.isValid() ? this.toISOString() : null;
                }
                function isValid$2() {
                    return isValid(this);
                }
                function parsingFlags() {
                    return extend({}, getParsingFlags(this));
                }
                function invalidAt() {
                    return getParsingFlags(this).overflow;
                }
                function creationData() {
                    return {
                        input: this._i,
                        format: this._f,
                        locale: this._locale,
                        isUTC: this._isUTC,
                        strict: this._strict
                    };
                }
                addFormatToken("N", 0, 0, "eraAbbr");
                addFormatToken("NN", 0, 0, "eraAbbr");
                addFormatToken("NNN", 0, 0, "eraAbbr");
                addFormatToken("NNNN", 0, 0, "eraName");
                addFormatToken("NNNNN", 0, 0, "eraNarrow");
                addFormatToken("y", [ "y", 1 ], "yo", "eraYear");
                addFormatToken("y", [ "yy", 2 ], 0, "eraYear");
                addFormatToken("y", [ "yyy", 3 ], 0, "eraYear");
                addFormatToken("y", [ "yyyy", 4 ], 0, "eraYear");
                addRegexToken("N", matchEraAbbr);
                addRegexToken("NN", matchEraAbbr);
                addRegexToken("NNN", matchEraAbbr);
                addRegexToken("NNNN", matchEraName);
                addRegexToken("NNNNN", matchEraNarrow);
                addParseToken([ "N", "NN", "NNN", "NNNN", "NNNNN" ], (function(input, array, config, token) {
                    var era = config._locale.erasParse(input, token, config._strict);
                    if (era) getParsingFlags(config).era = era; else getParsingFlags(config).invalidEra = input;
                }));
                addRegexToken("y", matchUnsigned);
                addRegexToken("yy", matchUnsigned);
                addRegexToken("yyy", matchUnsigned);
                addRegexToken("yyyy", matchUnsigned);
                addRegexToken("yo", matchEraYearOrdinal);
                addParseToken([ "y", "yy", "yyy", "yyyy" ], YEAR);
                addParseToken([ "yo" ], (function(input, array, config, token) {
                    var match;
                    if (config._locale._eraYearOrdinalRegex) match = input.match(config._locale._eraYearOrdinalRegex);
                    if (config._locale.eraYearOrdinalParse) array[YEAR] = config._locale.eraYearOrdinalParse(input, match); else array[YEAR] = parseInt(input, 10);
                }));
                function localeEras(m, format) {
                    var i, l, date, eras = this._eras || getLocale("en")._eras;
                    for (i = 0, l = eras.length; i < l; ++i) {
                        switch (typeof eras[i].since) {
                          case "string":
                            date = hooks(eras[i].since).startOf("day");
                            eras[i].since = date.valueOf();
                            break;
                        }
                        switch (typeof eras[i].until) {
                          case "undefined":
                            eras[i].until = +1 / 0;
                            break;

                          case "string":
                            date = hooks(eras[i].until).startOf("day").valueOf();
                            eras[i].until = date.valueOf();
                            break;
                        }
                    }
                    return eras;
                }
                function localeErasParse(eraName, format, strict) {
                    var i, l, name, abbr, narrow, eras = this.eras();
                    eraName = eraName.toUpperCase();
                    for (i = 0, l = eras.length; i < l; ++i) {
                        name = eras[i].name.toUpperCase();
                        abbr = eras[i].abbr.toUpperCase();
                        narrow = eras[i].narrow.toUpperCase();
                        if (strict) switch (format) {
                          case "N":
                          case "NN":
                          case "NNN":
                            if (abbr === eraName) return eras[i];
                            break;

                          case "NNNN":
                            if (name === eraName) return eras[i];
                            break;

                          case "NNNNN":
                            if (narrow === eraName) return eras[i];
                            break;
                        } else if ([ name, abbr, narrow ].indexOf(eraName) >= 0) return eras[i];
                    }
                }
                function localeErasConvertYear(era, year) {
                    var dir = era.since <= era.until ? +1 : -1;
                    if (void 0 === year) return hooks(era.since).year(); else return hooks(era.since).year() + (year - era.offset) * dir;
                }
                function getEraName() {
                    var i, l, val, eras = this.localeData().eras();
                    for (i = 0, l = eras.length; i < l; ++i) {
                        val = this.clone().startOf("day").valueOf();
                        if (eras[i].since <= val && val <= eras[i].until) return eras[i].name;
                        if (eras[i].until <= val && val <= eras[i].since) return eras[i].name;
                    }
                    return "";
                }
                function getEraNarrow() {
                    var i, l, val, eras = this.localeData().eras();
                    for (i = 0, l = eras.length; i < l; ++i) {
                        val = this.clone().startOf("day").valueOf();
                        if (eras[i].since <= val && val <= eras[i].until) return eras[i].narrow;
                        if (eras[i].until <= val && val <= eras[i].since) return eras[i].narrow;
                    }
                    return "";
                }
                function getEraAbbr() {
                    var i, l, val, eras = this.localeData().eras();
                    for (i = 0, l = eras.length; i < l; ++i) {
                        val = this.clone().startOf("day").valueOf();
                        if (eras[i].since <= val && val <= eras[i].until) return eras[i].abbr;
                        if (eras[i].until <= val && val <= eras[i].since) return eras[i].abbr;
                    }
                    return "";
                }
                function getEraYear() {
                    var i, l, dir, val, eras = this.localeData().eras();
                    for (i = 0, l = eras.length; i < l; ++i) {
                        dir = eras[i].since <= eras[i].until ? +1 : -1;
                        val = this.clone().startOf("day").valueOf();
                        if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
                    }
                    return this.year();
                }
                function erasNameRegex(isStrict) {
                    if (!hasOwnProp(this, "_erasNameRegex")) computeErasParse.call(this);
                    return isStrict ? this._erasNameRegex : this._erasRegex;
                }
                function erasAbbrRegex(isStrict) {
                    if (!hasOwnProp(this, "_erasAbbrRegex")) computeErasParse.call(this);
                    return isStrict ? this._erasAbbrRegex : this._erasRegex;
                }
                function erasNarrowRegex(isStrict) {
                    if (!hasOwnProp(this, "_erasNarrowRegex")) computeErasParse.call(this);
                    return isStrict ? this._erasNarrowRegex : this._erasRegex;
                }
                function matchEraAbbr(isStrict, locale) {
                    return locale.erasAbbrRegex(isStrict);
                }
                function matchEraName(isStrict, locale) {
                    return locale.erasNameRegex(isStrict);
                }
                function matchEraNarrow(isStrict, locale) {
                    return locale.erasNarrowRegex(isStrict);
                }
                function matchEraYearOrdinal(isStrict, locale) {
                    return locale._eraYearOrdinalRegex || matchUnsigned;
                }
                function computeErasParse() {
                    var i, l, abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], eras = this.eras();
                    for (i = 0, l = eras.length; i < l; ++i) {
                        namePieces.push(regexEscape(eras[i].name));
                        abbrPieces.push(regexEscape(eras[i].abbr));
                        narrowPieces.push(regexEscape(eras[i].narrow));
                        mixedPieces.push(regexEscape(eras[i].name));
                        mixedPieces.push(regexEscape(eras[i].abbr));
                        mixedPieces.push(regexEscape(eras[i].narrow));
                    }
                    this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
                    this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
                    this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
                    this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
                }
                addFormatToken(0, [ "gg", 2 ], 0, (function() {
                    return this.weekYear() % 100;
                }));
                addFormatToken(0, [ "GG", 2 ], 0, (function() {
                    return this.isoWeekYear() % 100;
                }));
                function addWeekYearFormatToken(token, getter) {
                    addFormatToken(0, [ token, token.length ], 0, getter);
                }
                addWeekYearFormatToken("gggg", "weekYear");
                addWeekYearFormatToken("ggggg", "weekYear");
                addWeekYearFormatToken("GGGG", "isoWeekYear");
                addWeekYearFormatToken("GGGGG", "isoWeekYear");
                addUnitAlias("weekYear", "gg");
                addUnitAlias("isoWeekYear", "GG");
                addUnitPriority("weekYear", 1);
                addUnitPriority("isoWeekYear", 1);
                addRegexToken("G", matchSigned);
                addRegexToken("g", matchSigned);
                addRegexToken("GG", match1to2, match2);
                addRegexToken("gg", match1to2, match2);
                addRegexToken("GGGG", match1to4, match4);
                addRegexToken("gggg", match1to4, match4);
                addRegexToken("GGGGG", match1to6, match6);
                addRegexToken("ggggg", match1to6, match6);
                addWeekParseToken([ "gggg", "ggggg", "GGGG", "GGGGG" ], (function(input, week, config, token) {
                    week[token.substr(0, 2)] = toInt(input);
                }));
                addWeekParseToken([ "gg", "GG" ], (function(input, week, config, token) {
                    week[token] = hooks.parseTwoDigitYear(input);
                }));
                function getSetWeekYear(input) {
                    return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
                }
                function getSetISOWeekYear(input) {
                    return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
                }
                function getISOWeeksInYear() {
                    return weeksInYear(this.year(), 1, 4);
                }
                function getISOWeeksInISOWeekYear() {
                    return weeksInYear(this.isoWeekYear(), 1, 4);
                }
                function getWeeksInYear() {
                    var weekInfo = this.localeData()._week;
                    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
                }
                function getWeeksInWeekYear() {
                    var weekInfo = this.localeData()._week;
                    return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
                }
                function getSetWeekYearHelper(input, week, weekday, dow, doy) {
                    var weeksTarget;
                    if (null == input) return weekOfYear(this, dow, doy).year; else {
                        weeksTarget = weeksInYear(input, dow, doy);
                        if (week > weeksTarget) week = weeksTarget;
                        return setWeekAll.call(this, input, week, weekday, dow, doy);
                    }
                }
                function setWeekAll(weekYear, week, weekday, dow, doy) {
                    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
                    this.year(date.getUTCFullYear());
                    this.month(date.getUTCMonth());
                    this.date(date.getUTCDate());
                    return this;
                }
                addFormatToken("Q", 0, "Qo", "quarter");
                addUnitAlias("quarter", "Q");
                addUnitPriority("quarter", 7);
                addRegexToken("Q", match1);
                addParseToken("Q", (function(input, array) {
                    array[MONTH] = 3 * (toInt(input) - 1);
                }));
                function getSetQuarter(input) {
                    return null == input ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (input - 1) + this.month() % 3);
                }
                addFormatToken("D", [ "DD", 2 ], "Do", "date");
                addUnitAlias("date", "D");
                addUnitPriority("date", 9);
                addRegexToken("D", match1to2);
                addRegexToken("DD", match1to2, match2);
                addRegexToken("Do", (function(isStrict, locale) {
                    return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
                }));
                addParseToken([ "D", "DD" ], DATE);
                addParseToken("Do", (function(input, array) {
                    array[DATE] = toInt(input.match(match1to2)[0]);
                }));
                var getSetDayOfMonth = makeGetSet("Date", true);
                addFormatToken("DDD", [ "DDDD", 3 ], "DDDo", "dayOfYear");
                addUnitAlias("dayOfYear", "DDD");
                addUnitPriority("dayOfYear", 4);
                addRegexToken("DDD", match1to3);
                addRegexToken("DDDD", match3);
                addParseToken([ "DDD", "DDDD" ], (function(input, array, config) {
                    config._dayOfYear = toInt(input);
                }));
                function getSetDayOfYear(input) {
                    var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
                    return null == input ? dayOfYear : this.add(input - dayOfYear, "d");
                }
                addFormatToken("m", [ "mm", 2 ], 0, "minute");
                addUnitAlias("minute", "m");
                addUnitPriority("minute", 14);
                addRegexToken("m", match1to2);
                addRegexToken("mm", match1to2, match2);
                addParseToken([ "m", "mm" ], MINUTE);
                var getSetMinute = makeGetSet("Minutes", false);
                addFormatToken("s", [ "ss", 2 ], 0, "second");
                addUnitAlias("second", "s");
                addUnitPriority("second", 15);
                addRegexToken("s", match1to2);
                addRegexToken("ss", match1to2, match2);
                addParseToken([ "s", "ss" ], SECOND);
                var getSetSecond = makeGetSet("Seconds", false);
                addFormatToken("S", 0, 0, (function() {
                    return ~~(this.millisecond() / 100);
                }));
                addFormatToken(0, [ "SS", 2 ], 0, (function() {
                    return ~~(this.millisecond() / 10);
                }));
                addFormatToken(0, [ "SSS", 3 ], 0, "millisecond");
                addFormatToken(0, [ "SSSS", 4 ], 0, (function() {
                    return 10 * this.millisecond();
                }));
                addFormatToken(0, [ "SSSSS", 5 ], 0, (function() {
                    return 100 * this.millisecond();
                }));
                addFormatToken(0, [ "SSSSSS", 6 ], 0, (function() {
                    return 1e3 * this.millisecond();
                }));
                addFormatToken(0, [ "SSSSSSS", 7 ], 0, (function() {
                    return 1e4 * this.millisecond();
                }));
                addFormatToken(0, [ "SSSSSSSS", 8 ], 0, (function() {
                    return 1e5 * this.millisecond();
                }));
                addFormatToken(0, [ "SSSSSSSSS", 9 ], 0, (function() {
                    return 1e6 * this.millisecond();
                }));
                addUnitAlias("millisecond", "ms");
                addUnitPriority("millisecond", 16);
                addRegexToken("S", match1to3, match1);
                addRegexToken("SS", match1to3, match2);
                addRegexToken("SSS", match1to3, match3);
                var token, getSetMillisecond;
                for (token = "SSSS"; token.length <= 9; token += "S") addRegexToken(token, matchUnsigned);
                function parseMs(input, array) {
                    array[MILLISECOND] = toInt(1e3 * ("0." + input));
                }
                for (token = "S"; token.length <= 9; token += "S") addParseToken(token, parseMs);
                getSetMillisecond = makeGetSet("Milliseconds", false);
                addFormatToken("z", 0, 0, "zoneAbbr");
                addFormatToken("zz", 0, 0, "zoneName");
                function getZoneAbbr() {
                    return this._isUTC ? "UTC" : "";
                }
                function getZoneName() {
                    return this._isUTC ? "Coordinated Universal Time" : "";
                }
                var proto = Moment.prototype;
                proto.add = add;
                proto.calendar = calendar$1;
                proto.clone = clone;
                proto.diff = diff;
                proto.endOf = endOf;
                proto.format = format;
                proto.from = from;
                proto.fromNow = fromNow;
                proto.to = to;
                proto.toNow = toNow;
                proto.get = stringGet;
                proto.invalidAt = invalidAt;
                proto.isAfter = isAfter;
                proto.isBefore = isBefore;
                proto.isBetween = isBetween;
                proto.isSame = isSame;
                proto.isSameOrAfter = isSameOrAfter;
                proto.isSameOrBefore = isSameOrBefore;
                proto.isValid = isValid$2;
                proto.lang = lang;
                proto.locale = locale;
                proto.localeData = localeData;
                proto.max = prototypeMax;
                proto.min = prototypeMin;
                proto.parsingFlags = parsingFlags;
                proto.set = stringSet;
                proto.startOf = startOf;
                proto.subtract = subtract;
                proto.toArray = toArray;
                proto.toObject = toObject;
                proto.toDate = toDate;
                proto.toISOString = toISOString;
                proto.inspect = inspect;
                if ("undefined" !== typeof Symbol && null != Symbol.for) proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
                    return "Moment<" + this.format() + ">";
                };
                proto.toJSON = toJSON;
                proto.toString = toString;
                proto.unix = unix;
                proto.valueOf = valueOf;
                proto.creationData = creationData;
                proto.eraName = getEraName;
                proto.eraNarrow = getEraNarrow;
                proto.eraAbbr = getEraAbbr;
                proto.eraYear = getEraYear;
                proto.year = getSetYear;
                proto.isLeapYear = getIsLeapYear;
                proto.weekYear = getSetWeekYear;
                proto.isoWeekYear = getSetISOWeekYear;
                proto.quarter = proto.quarters = getSetQuarter;
                proto.month = getSetMonth;
                proto.daysInMonth = getDaysInMonth;
                proto.week = proto.weeks = getSetWeek;
                proto.isoWeek = proto.isoWeeks = getSetISOWeek;
                proto.weeksInYear = getWeeksInYear;
                proto.weeksInWeekYear = getWeeksInWeekYear;
                proto.isoWeeksInYear = getISOWeeksInYear;
                proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
                proto.date = getSetDayOfMonth;
                proto.day = proto.days = getSetDayOfWeek;
                proto.weekday = getSetLocaleDayOfWeek;
                proto.isoWeekday = getSetISODayOfWeek;
                proto.dayOfYear = getSetDayOfYear;
                proto.hour = proto.hours = getSetHour;
                proto.minute = proto.minutes = getSetMinute;
                proto.second = proto.seconds = getSetSecond;
                proto.millisecond = proto.milliseconds = getSetMillisecond;
                proto.utcOffset = getSetOffset;
                proto.utc = setOffsetToUTC;
                proto.local = setOffsetToLocal;
                proto.parseZone = setOffsetToParsedOffset;
                proto.hasAlignedHourOffset = hasAlignedHourOffset;
                proto.isDST = isDaylightSavingTime;
                proto.isLocal = isLocal;
                proto.isUtcOffset = isUtcOffset;
                proto.isUtc = isUtc;
                proto.isUTC = isUtc;
                proto.zoneAbbr = getZoneAbbr;
                proto.zoneName = getZoneName;
                proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
                proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
                proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
                proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
                proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
                function createUnix(input) {
                    return createLocal(1e3 * input);
                }
                function createInZone() {
                    return createLocal.apply(null, arguments).parseZone();
                }
                function preParsePostFormat(string) {
                    return string;
                }
                var proto$1 = Locale.prototype;
                proto$1.calendar = calendar;
                proto$1.longDateFormat = longDateFormat;
                proto$1.invalidDate = invalidDate;
                proto$1.ordinal = ordinal;
                proto$1.preparse = preParsePostFormat;
                proto$1.postformat = preParsePostFormat;
                proto$1.relativeTime = relativeTime;
                proto$1.pastFuture = pastFuture;
                proto$1.set = set;
                proto$1.eras = localeEras;
                proto$1.erasParse = localeErasParse;
                proto$1.erasConvertYear = localeErasConvertYear;
                proto$1.erasAbbrRegex = erasAbbrRegex;
                proto$1.erasNameRegex = erasNameRegex;
                proto$1.erasNarrowRegex = erasNarrowRegex;
                proto$1.months = localeMonths;
                proto$1.monthsShort = localeMonthsShort;
                proto$1.monthsParse = localeMonthsParse;
                proto$1.monthsRegex = monthsRegex;
                proto$1.monthsShortRegex = monthsShortRegex;
                proto$1.week = localeWeek;
                proto$1.firstDayOfYear = localeFirstDayOfYear;
                proto$1.firstDayOfWeek = localeFirstDayOfWeek;
                proto$1.weekdays = localeWeekdays;
                proto$1.weekdaysMin = localeWeekdaysMin;
                proto$1.weekdaysShort = localeWeekdaysShort;
                proto$1.weekdaysParse = localeWeekdaysParse;
                proto$1.weekdaysRegex = weekdaysRegex;
                proto$1.weekdaysShortRegex = weekdaysShortRegex;
                proto$1.weekdaysMinRegex = weekdaysMinRegex;
                proto$1.isPM = localeIsPM;
                proto$1.meridiem = localeMeridiem;
                function get$1(format, index, field, setter) {
                    var locale = getLocale(), utc = createUTC().set(setter, index);
                    return locale[field](utc, format);
                }
                function listMonthsImpl(format, index, field) {
                    if (isNumber(format)) {
                        index = format;
                        format = void 0;
                    }
                    format = format || "";
                    if (null != index) return get$1(format, index, field, "month");
                    var i, out = [];
                    for (i = 0; i < 12; i++) out[i] = get$1(format, i, field, "month");
                    return out;
                }
                function listWeekdaysImpl(localeSorted, format, index, field) {
                    if ("boolean" === typeof localeSorted) {
                        if (isNumber(format)) {
                            index = format;
                            format = void 0;
                        }
                        format = format || "";
                    } else {
                        format = localeSorted;
                        index = format;
                        localeSorted = false;
                        if (isNumber(format)) {
                            index = format;
                            format = void 0;
                        }
                        format = format || "";
                    }
                    var i, locale = getLocale(), shift = localeSorted ? locale._week.dow : 0, out = [];
                    if (null != index) return get$1(format, (index + shift) % 7, field, "day");
                    for (i = 0; i < 7; i++) out[i] = get$1(format, (i + shift) % 7, field, "day");
                    return out;
                }
                function listMonths(format, index) {
                    return listMonthsImpl(format, index, "months");
                }
                function listMonthsShort(format, index) {
                    return listMonthsImpl(format, index, "monthsShort");
                }
                function listWeekdays(localeSorted, format, index) {
                    return listWeekdaysImpl(localeSorted, format, index, "weekdays");
                }
                function listWeekdaysShort(localeSorted, format, index) {
                    return listWeekdaysImpl(localeSorted, format, index, "weekdaysShort");
                }
                function listWeekdaysMin(localeSorted, format, index) {
                    return listWeekdaysImpl(localeSorted, format, index, "weekdaysMin");
                }
                getSetGlobalLocale("en", {
                    eras: [ {
                        since: "0001-01-01",
                        until: +1 / 0,
                        offset: 1,
                        name: "Anno Domini",
                        narrow: "AD",
                        abbr: "AD"
                    }, {
                        since: "0000-12-31",
                        until: -1 / 0,
                        offset: 1,
                        name: "Before Christ",
                        narrow: "BC",
                        abbr: "BC"
                    } ],
                    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
                    ordinal: function(number) {
                        var b = number % 10, output = 1 === toInt(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th";
                        return number + output;
                    }
                });
                hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
                hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
                var mathAbs = Math.abs;
                function abs() {
                    var data = this._data;
                    this._milliseconds = mathAbs(this._milliseconds);
                    this._days = mathAbs(this._days);
                    this._months = mathAbs(this._months);
                    data.milliseconds = mathAbs(data.milliseconds);
                    data.seconds = mathAbs(data.seconds);
                    data.minutes = mathAbs(data.minutes);
                    data.hours = mathAbs(data.hours);
                    data.months = mathAbs(data.months);
                    data.years = mathAbs(data.years);
                    return this;
                }
                function addSubtract$1(duration, input, value, direction) {
                    var other = createDuration(input, value);
                    duration._milliseconds += direction * other._milliseconds;
                    duration._days += direction * other._days;
                    duration._months += direction * other._months;
                    return duration._bubble();
                }
                function add$1(input, value) {
                    return addSubtract$1(this, input, value, 1);
                }
                function subtract$1(input, value) {
                    return addSubtract$1(this, input, value, -1);
                }
                function absCeil(number) {
                    if (number < 0) return Math.floor(number); else return Math.ceil(number);
                }
                function bubble() {
                    var seconds, minutes, hours, years, monthsFromDays, milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data;
                    if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
                        milliseconds += 864e5 * absCeil(monthsToDays(months) + days);
                        days = 0;
                        months = 0;
                    }
                    data.milliseconds = milliseconds % 1e3;
                    seconds = absFloor(milliseconds / 1e3);
                    data.seconds = seconds % 60;
                    minutes = absFloor(seconds / 60);
                    data.minutes = minutes % 60;
                    hours = absFloor(minutes / 60);
                    data.hours = hours % 24;
                    days += absFloor(hours / 24);
                    monthsFromDays = absFloor(daysToMonths(days));
                    months += monthsFromDays;
                    days -= absCeil(monthsToDays(monthsFromDays));
                    years = absFloor(months / 12);
                    months %= 12;
                    data.days = days;
                    data.months = months;
                    data.years = years;
                    return this;
                }
                function daysToMonths(days) {
                    return 4800 * days / 146097;
                }
                function monthsToDays(months) {
                    return 146097 * months / 4800;
                }
                function as(units) {
                    if (!this.isValid()) return NaN;
                    var days, months, milliseconds = this._milliseconds;
                    units = normalizeUnits(units);
                    if ("month" === units || "quarter" === units || "year" === units) {
                        days = this._days + milliseconds / 864e5;
                        months = this._months + daysToMonths(days);
                        switch (units) {
                          case "month":
                            return months;

                          case "quarter":
                            return months / 3;

                          case "year":
                            return months / 12;
                        }
                    } else {
                        days = this._days + Math.round(monthsToDays(this._months));
                        switch (units) {
                          case "week":
                            return days / 7 + milliseconds / 6048e5;

                          case "day":
                            return days + milliseconds / 864e5;

                          case "hour":
                            return 24 * days + milliseconds / 36e5;

                          case "minute":
                            return 1440 * days + milliseconds / 6e4;

                          case "second":
                            return 86400 * days + milliseconds / 1e3;

                          case "millisecond":
                            return Math.floor(864e5 * days) + milliseconds;

                          default:
                            throw new Error("Unknown unit " + units);
                        }
                    }
                }
                function valueOf$1() {
                    if (!this.isValid()) return NaN;
                    return this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * toInt(this._months / 12);
                }
                function makeAs(alias) {
                    return function() {
                        return this.as(alias);
                    };
                }
                var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
                function clone$1() {
                    return createDuration(this);
                }
                function get$2(units) {
                    units = normalizeUnits(units);
                    return this.isValid() ? this[units + "s"]() : NaN;
                }
                function makeGetter(name) {
                    return function() {
                        return this.isValid() ? this._data[name] : NaN;
                    };
                }
                var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
                function weeks() {
                    return absFloor(this.days() / 7);
                }
                var round = Math.round, thresholds = {
                    ss: 44,
                    s: 45,
                    m: 45,
                    h: 22,
                    d: 26,
                    w: null,
                    M: 11
                };
                function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
                    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
                }
                function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
                    var duration = createDuration(posNegDuration).abs(), seconds = round(duration.as("s")), minutes = round(duration.as("m")), hours = round(duration.as("h")), days = round(duration.as("d")), months = round(duration.as("M")), weeks = round(duration.as("w")), years = round(duration.as("y")), a = seconds <= thresholds.ss && [ "s", seconds ] || seconds < thresholds.s && [ "ss", seconds ] || minutes <= 1 && [ "m" ] || minutes < thresholds.m && [ "mm", minutes ] || hours <= 1 && [ "h" ] || hours < thresholds.h && [ "hh", hours ] || days <= 1 && [ "d" ] || days < thresholds.d && [ "dd", days ];
                    if (null != thresholds.w) a = a || weeks <= 1 && [ "w" ] || weeks < thresholds.w && [ "ww", weeks ];
                    a = a || months <= 1 && [ "M" ] || months < thresholds.M && [ "MM", months ] || years <= 1 && [ "y" ] || [ "yy", years ];
                    a[2] = withoutSuffix;
                    a[3] = +posNegDuration > 0;
                    a[4] = locale;
                    return substituteTimeAgo.apply(null, a);
                }
                function getSetRelativeTimeRounding(roundingFunction) {
                    if (void 0 === roundingFunction) return round;
                    if ("function" === typeof roundingFunction) {
                        round = roundingFunction;
                        return true;
                    }
                    return false;
                }
                function getSetRelativeTimeThreshold(threshold, limit) {
                    if (void 0 === thresholds[threshold]) return false;
                    if (void 0 === limit) return thresholds[threshold];
                    thresholds[threshold] = limit;
                    if ("s" === threshold) thresholds.ss = limit - 1;
                    return true;
                }
                function humanize(argWithSuffix, argThresholds) {
                    if (!this.isValid()) return this.localeData().invalidDate();
                    var locale, output, withSuffix = false, th = thresholds;
                    if ("object" === typeof argWithSuffix) {
                        argThresholds = argWithSuffix;
                        argWithSuffix = false;
                    }
                    if ("boolean" === typeof argWithSuffix) withSuffix = argWithSuffix;
                    if ("object" === typeof argThresholds) {
                        th = Object.assign({}, thresholds, argThresholds);
                        if (null != argThresholds.s && null == argThresholds.ss) th.ss = argThresholds.s - 1;
                    }
                    locale = this.localeData();
                    output = relativeTime$1(this, !withSuffix, th, locale);
                    if (withSuffix) output = locale.pastFuture(+this, output);
                    return locale.postformat(output);
                }
                var abs$1 = Math.abs;
                function sign(x) {
                    return (x > 0) - (x < 0) || +x;
                }
                function toISOString$1() {
                    if (!this.isValid()) return this.localeData().invalidDate();
                    var minutes, hours, years, s, totalSign, ymSign, daysSign, hmsSign, seconds = abs$1(this._milliseconds) / 1e3, days = abs$1(this._days), months = abs$1(this._months), total = this.asSeconds();
                    if (!total) return "P0D";
                    minutes = absFloor(seconds / 60);
                    hours = absFloor(minutes / 60);
                    seconds %= 60;
                    minutes %= 60;
                    years = absFloor(months / 12);
                    months %= 12;
                    s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, "") : "";
                    totalSign = total < 0 ? "-" : "";
                    ymSign = sign(this._months) !== sign(total) ? "-" : "";
                    daysSign = sign(this._days) !== sign(total) ? "-" : "";
                    hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
                    return totalSign + "P" + (years ? ymSign + years + "Y" : "") + (months ? ymSign + months + "M" : "") + (days ? daysSign + days + "D" : "") + (hours || minutes || seconds ? "T" : "") + (hours ? hmsSign + hours + "H" : "") + (minutes ? hmsSign + minutes + "M" : "") + (seconds ? hmsSign + s + "S" : "");
                }
                var proto$2 = Duration.prototype;
                proto$2.isValid = isValid$1;
                proto$2.abs = abs;
                proto$2.add = add$1;
                proto$2.subtract = subtract$1;
                proto$2.as = as;
                proto$2.asMilliseconds = asMilliseconds;
                proto$2.asSeconds = asSeconds;
                proto$2.asMinutes = asMinutes;
                proto$2.asHours = asHours;
                proto$2.asDays = asDays;
                proto$2.asWeeks = asWeeks;
                proto$2.asMonths = asMonths;
                proto$2.asQuarters = asQuarters;
                proto$2.asYears = asYears;
                proto$2.valueOf = valueOf$1;
                proto$2._bubble = bubble;
                proto$2.clone = clone$1;
                proto$2.get = get$2;
                proto$2.milliseconds = milliseconds;
                proto$2.seconds = seconds;
                proto$2.minutes = minutes;
                proto$2.hours = hours;
                proto$2.days = days;
                proto$2.weeks = weeks;
                proto$2.months = months;
                proto$2.years = years;
                proto$2.humanize = humanize;
                proto$2.toISOString = toISOString$1;
                proto$2.toString = toISOString$1;
                proto$2.toJSON = toISOString$1;
                proto$2.locale = locale;
                proto$2.localeData = localeData;
                proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
                proto$2.lang = lang;
                addFormatToken("X", 0, 0, "unix");
                addFormatToken("x", 0, 0, "valueOf");
                addRegexToken("x", matchSigned);
                addRegexToken("X", matchTimestamp);
                addParseToken("X", (function(input, array, config) {
                    config._d = new Date(1e3 * parseFloat(input));
                }));
                addParseToken("x", (function(input, array, config) {
                    config._d = new Date(toInt(input));
                }));
                //! moment.js
                                hooks.version = "2.29.4";
                setHookCallback(createLocal);
                hooks.fn = proto;
                hooks.min = min;
                hooks.max = max;
                hooks.now = now;
                hooks.utc = createUTC;
                hooks.unix = createUnix;
                hooks.months = listMonths;
                hooks.isDate = isDate;
                hooks.locale = getSetGlobalLocale;
                hooks.invalid = createInvalid;
                hooks.duration = createDuration;
                hooks.isMoment = isMoment;
                hooks.weekdays = listWeekdays;
                hooks.parseZone = createInZone;
                hooks.localeData = getLocale;
                hooks.isDuration = isDuration;
                hooks.monthsShort = listMonthsShort;
                hooks.weekdaysMin = listWeekdaysMin;
                hooks.defineLocale = defineLocale;
                hooks.updateLocale = updateLocale;
                hooks.locales = listLocales;
                hooks.weekdaysShort = listWeekdaysShort;
                hooks.normalizeUnits = normalizeUnits;
                hooks.relativeTimeRounding = getSetRelativeTimeRounding;
                hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
                hooks.calendarFormat = getCalendarFormat;
                hooks.prototype = proto;
                hooks.HTML5_FMT = {
                    DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
                    DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
                    DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
                    DATE: "YYYY-MM-DD",
                    TIME: "HH:mm",
                    TIME_SECONDS: "HH:mm:ss",
                    TIME_MS: "HH:mm:ss.SSS",
                    WEEK: "GGGG-[W]WW",
                    MONTH: "YYYY-MM"
                };
                return hooks;
            }));
        },
        3002: function(module, exports, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
 /*! smooth-scroll v16.1.3 | (c) 2020 Chris Ferdinandi | MIT License | http://github.com/cferdinandi/smooth-scroll */            window.Element && !Element.prototype.closest && (Element.prototype.closest = function(e) {
                var t, n = (this.document || this.ownerDocument).querySelectorAll(e), o = this;
                do {
                    for (t = n.length; 0 <= --t && n.item(t) !== o; ) ;
                } while (t < 0 && (o = o.parentElement));
                return o;
            }), function() {
                if ("function" == typeof window.CustomEvent) return;
                function e(e, t) {
                    t = t || {
                        bubbles: !1,
                        cancelable: !1,
                        detail: void 0
                    };
                    var n = document.createEvent("CustomEvent");
                    return n.initCustomEvent(e, t.bubbles, t.cancelable, t.detail), n;
                }
                e.prototype = window.Event.prototype, window.CustomEvent = e;
            }(), function() {
                for (var r = 0, e = [ "ms", "moz", "webkit", "o" ], t = 0; t < e.length && !window.requestAnimationFrame; ++t) window.requestAnimationFrame = window[e[t] + "RequestAnimationFrame"], 
                window.cancelAnimationFrame = window[e[t] + "CancelAnimationFrame"] || window[e[t] + "CancelRequestAnimationFrame"];
                window.requestAnimationFrame || (window.requestAnimationFrame = function(e, t) {
                    var n = (new Date).getTime(), o = Math.max(0, 16 - (n - r)), a = window.setTimeout((function() {
                        e(n + o);
                    }), o);
                    return r = n + o, a;
                }), window.cancelAnimationFrame || (window.cancelAnimationFrame = function(e) {
                    clearTimeout(e);
                });
            }(), function(e, t) {
                true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                    return t(e);
                }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;
            }("undefined" != typeof __webpack_require__.g ? __webpack_require__.g : "undefined" != typeof window ? window : this, (function(M) {
                "use strict";
                var q = {
                    ignore: "[data-scroll-ignore]",
                    header: null,
                    topOnEmptyHash: !0,
                    speed: 500,
                    speedAsDuration: !1,
                    durationMax: null,
                    durationMin: null,
                    clip: !0,
                    offset: 0,
                    easing: "easeInOutCubic",
                    customEasing: null,
                    updateURL: !0,
                    popstate: !0,
                    emitEvents: !0
                }, I = function() {
                    var n = {};
                    return Array.prototype.forEach.call(arguments, (function(e) {
                        for (var t in e) {
                            if (!e.hasOwnProperty(t)) return;
                            n[t] = e[t];
                        }
                    })), n;
                }, r = function(e) {
                    "#" === e.charAt(0) && (e = e.substr(1));
                    for (var t, n = String(e), o = n.length, a = -1, r = "", i = n.charCodeAt(0); ++a < o; ) {
                        if (0 === (t = n.charCodeAt(a))) throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
                        1 <= t && t <= 31 || 127 == t || 0 === a && 48 <= t && t <= 57 || 1 === a && 48 <= t && t <= 57 && 45 === i ? r += "\\" + t.toString(16) + " " : r += 128 <= t || 45 === t || 95 === t || 48 <= t && t <= 57 || 65 <= t && t <= 90 || 97 <= t && t <= 122 ? n.charAt(a) : "\\" + n.charAt(a);
                    }
                    return "#" + r;
                }, F = function() {
                    return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight);
                }, L = function(e) {
                    return e ? (t = e, parseInt(M.getComputedStyle(t).height, 10) + e.offsetTop) : 0;
                    var t;
                }, x = function(e, t, n) {
                    0 === e && document.body.focus(), n || (e.focus(), document.activeElement !== e && (e.setAttribute("tabindex", "-1"), 
                    e.focus(), e.style.outline = "none"), M.scrollTo(0, t));
                }, H = function(e, t, n, o) {
                    if (t.emitEvents && "function" == typeof M.CustomEvent) {
                        var a = new CustomEvent(e, {
                            bubbles: !0,
                            detail: {
                                anchor: n,
                                toggle: o
                            }
                        });
                        document.dispatchEvent(a);
                    }
                };
                return function(o, e) {
                    var b, a, A, O, C = {};
                    C.cancelScroll = function(e) {
                        cancelAnimationFrame(O), O = null, e || H("scrollCancel", b);
                    }, C.animateScroll = function(a, r, e) {
                        C.cancelScroll();
                        var i = I(b || q, e || {}), c = "[object Number]" === Object.prototype.toString.call(a), t = c || !a.tagName ? null : a;
                        if (c || t) {
                            var s = M.pageYOffset;
                            i.header && !A && (A = document.querySelector(i.header));
                            var n, o, u, l, m, d, f, h, p = L(A), g = c ? a : function(e, t, n, o) {
                                var a = 0;
                                if (e.offsetParent) for (;a += e.offsetTop, e = e.offsetParent; ) ;
                                return a = Math.max(a - t - n, 0), o && (a = Math.min(a, F() - M.innerHeight)), 
                                a;
                            }(t, p, parseInt("function" == typeof i.offset ? i.offset(a, r) : i.offset, 10), i.clip), y = g - s, v = F(), w = 0, S = (n = y, 
                            u = (o = i).speedAsDuration ? o.speed : Math.abs(n / 1e3 * o.speed), o.durationMax && u > o.durationMax ? o.durationMax : o.durationMin && u < o.durationMin ? o.durationMin : parseInt(u, 10)), E = function(e) {
                                var t, n, o;
                                l || (l = e), w += e - l, d = s + y * (n = m = 1 < (m = 0 === S ? 0 : w / S) ? 1 : m, 
                                "easeInQuad" === (t = i).easing && (o = n * n), "easeOutQuad" === t.easing && (o = n * (2 - n)), 
                                "easeInOutQuad" === t.easing && (o = n < .5 ? 2 * n * n : (4 - 2 * n) * n - 1), 
                                "easeInCubic" === t.easing && (o = n * n * n), "easeOutCubic" === t.easing && (o = --n * n * n + 1), 
                                "easeInOutCubic" === t.easing && (o = n < .5 ? 4 * n * n * n : (n - 1) * (2 * n - 2) * (2 * n - 2) + 1), 
                                "easeInQuart" === t.easing && (o = n * n * n * n), "easeOutQuart" === t.easing && (o = 1 - --n * n * n * n), 
                                "easeInOutQuart" === t.easing && (o = n < .5 ? 8 * n * n * n * n : 1 - 8 * --n * n * n * n), 
                                "easeInQuint" === t.easing && (o = n * n * n * n * n), "easeOutQuint" === t.easing && (o = 1 + --n * n * n * n * n), 
                                "easeInOutQuint" === t.easing && (o = n < .5 ? 16 * n * n * n * n * n : 1 + 16 * --n * n * n * n * n), 
                                t.customEasing && (o = t.customEasing(n)), o || n), M.scrollTo(0, Math.floor(d)), 
                                function(e, t) {
                                    var n = M.pageYOffset;
                                    if (e == t || n == t || (s < t && M.innerHeight + n) >= v) return C.cancelScroll(!0), 
                                    x(a, t, c), H("scrollStop", i, a, r), !(O = l = null);
                                }(d, g) || (O = M.requestAnimationFrame(E), l = e);
                            };
                            0 === M.pageYOffset && M.scrollTo(0, 0), f = a, h = i, c || history.pushState && h.updateURL && history.pushState({
                                smoothScroll: JSON.stringify(h),
                                anchor: f.id
                            }, document.title, f === document.documentElement ? "#top" : "#" + f.id), "matchMedia" in M && M.matchMedia("(prefers-reduced-motion)").matches ? x(a, Math.floor(g), !1) : (H("scrollStart", i, a, r), 
                            C.cancelScroll(!0), M.requestAnimationFrame(E));
                        }
                    };
                    var t = function(e) {
                        if (!e.defaultPrevented && !(0 !== e.button || e.metaKey || e.ctrlKey || e.shiftKey) && "closest" in e.target && (a = e.target.closest(o)) && "a" === a.tagName.toLowerCase() && !e.target.closest(b.ignore) && a.hostname === M.location.hostname && a.pathname === M.location.pathname && /#/.test(a.href)) {
                            var t, n;
                            try {
                                t = r(decodeURIComponent(a.hash));
                            } catch (e) {
                                t = r(a.hash);
                            }
                            if ("#" === t) {
                                if (!b.topOnEmptyHash) return;
                                n = document.documentElement;
                            } else n = document.querySelector(t);
                            (n = n || "#top" !== t ? n : document.documentElement) && (e.preventDefault(), function(e) {
                                if (history.replaceState && e.updateURL && !history.state) {
                                    var t = M.location.hash;
                                    t = t || "", history.replaceState({
                                        smoothScroll: JSON.stringify(e),
                                        anchor: t || M.pageYOffset
                                    }, document.title, t || M.location.href);
                                }
                            }(b), C.animateScroll(n, a));
                        }
                    }, n = function(e) {
                        if (null !== history.state && history.state.smoothScroll && history.state.smoothScroll === JSON.stringify(b)) {
                            var t = history.state.anchor;
                            "string" == typeof t && t && !(t = document.querySelector(r(history.state.anchor))) || C.animateScroll(t, null, {
                                updateURL: !1
                            });
                        }
                    };
                    C.destroy = function() {
                        b && (document.removeEventListener("click", t, !1), M.removeEventListener("popstate", n, !1), 
                        C.cancelScroll(), O = A = a = b = null);
                    };
                    return function() {
                        if (!("querySelector" in document && "addEventListener" in M && "requestAnimationFrame" in M && "closest" in M.Element.prototype)) throw "Smooth Scroll: This browser does not support the required JavaScript methods and browser APIs.";
                        C.destroy(), b = I(q, e || {}), A = b.header ? document.querySelector(b.header) : null, 
                        document.addEventListener("click", t, !1), b.updateURL && b.popstate && M.addEventListener("popstate", n, !1);
                    }(), C;
                };
            }));
        },
        2732: function(module) {
            !function(n, t) {
                true ? module.exports = t() : 0;
            }(0, (function() {
                "use strict";
                function n() {
                    return n = Object.assign || function(n) {
                        for (var t = 1; t < arguments.length; t++) {
                            var e = arguments[t];
                            for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]);
                        }
                        return n;
                    }, n.apply(this, arguments);
                }
                var t = "undefined" != typeof window, e = t && !("onscroll" in window) || "undefined" != typeof navigator && /(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent), i = t && "IntersectionObserver" in window, o = t && "classList" in document.createElement("p"), a = t && window.devicePixelRatio > 1, r = {
                    elements_selector: ".lazy",
                    container: e || t ? document : null,
                    threshold: 300,
                    thresholds: null,
                    data_src: "src",
                    data_srcset: "srcset",
                    data_sizes: "sizes",
                    data_bg: "bg",
                    data_bg_hidpi: "bg-hidpi",
                    data_bg_multi: "bg-multi",
                    data_bg_multi_hidpi: "bg-multi-hidpi",
                    data_bg_set: "bg-set",
                    data_poster: "poster",
                    class_applied: "applied",
                    class_loading: "loading",
                    class_loaded: "loaded",
                    class_error: "error",
                    class_entered: "entered",
                    class_exited: "exited",
                    unobserve_completed: !0,
                    unobserve_entered: !1,
                    cancel_on_exit: !0,
                    callback_enter: null,
                    callback_exit: null,
                    callback_applied: null,
                    callback_loading: null,
                    callback_loaded: null,
                    callback_error: null,
                    callback_finish: null,
                    callback_cancel: null,
                    use_native: !1,
                    restore_on_error: !1
                }, c = function(t) {
                    return n({}, r, t);
                }, l = function(n, t) {
                    var e, i = "LazyLoad::Initialized", o = new n(t);
                    try {
                        e = new CustomEvent(i, {
                            detail: {
                                instance: o
                            }
                        });
                    } catch (n) {
                        (e = document.createEvent("CustomEvent")).initCustomEvent(i, !1, !1, {
                            instance: o
                        });
                    }
                    window.dispatchEvent(e);
                }, u = "src", s = "srcset", d = "sizes", f = "poster", _ = "llOriginalAttrs", g = "data", v = "loading", b = "loaded", m = "applied", p = "error", h = "native", E = "data-", I = "ll-status", y = function(n, t) {
                    return n.getAttribute(E + t);
                }, k = function(n) {
                    return y(n, I);
                }, w = function(n, t) {
                    return function(n, t, e) {
                        var i = "data-ll-status";
                        null !== e ? n.setAttribute(i, e) : n.removeAttribute(i);
                    }(n, 0, t);
                }, A = function(n) {
                    return w(n, null);
                }, L = function(n) {
                    return null === k(n);
                }, O = function(n) {
                    return k(n) === h;
                }, x = [ v, b, m, p ], C = function(n, t, e, i) {
                    n && (void 0 === i ? void 0 === e ? n(t) : n(t, e) : n(t, e, i));
                }, N = function(n, t) {
                    o ? n.classList.add(t) : n.className += (n.className ? " " : "") + t;
                }, M = function(n, t) {
                    o ? n.classList.remove(t) : n.className = n.className.replace(new RegExp("(^|\\s+)" + t + "(\\s+|$)"), " ").replace(/^\s+/, "").replace(/\s+$/, "");
                }, z = function(n) {
                    return n.llTempImage;
                }, T = function(n, t) {
                    if (t) {
                        var e = t._observer;
                        e && e.unobserve(n);
                    }
                }, R = function(n, t) {
                    n && (n.loadingCount += t);
                }, G = function(n, t) {
                    n && (n.toLoadCount = t);
                }, j = function(n) {
                    for (var t, e = [], i = 0; t = n.children[i]; i += 1) "SOURCE" === t.tagName && e.push(t);
                    return e;
                }, D = function(n, t) {
                    var e = n.parentNode;
                    e && "PICTURE" === e.tagName && j(e).forEach(t);
                }, H = function(n, t) {
                    j(n).forEach(t);
                }, V = [ u ], F = [ u, f ], B = [ u, s, d ], J = [ g ], P = function(n) {
                    return !!n[_];
                }, S = function(n) {
                    return n[_];
                }, U = function(n) {
                    return delete n[_];
                }, $ = function(n, t) {
                    if (!P(n)) {
                        var e = {};
                        t.forEach((function(t) {
                            e[t] = n.getAttribute(t);
                        })), n[_] = e;
                    }
                }, q = function(n, t) {
                    if (P(n)) {
                        var e = S(n);
                        t.forEach((function(t) {
                            !function(n, t, e) {
                                e ? n.setAttribute(t, e) : n.removeAttribute(t);
                            }(n, t, e[t]);
                        }));
                    }
                }, K = function(n, t, e) {
                    N(n, t.class_applied), w(n, m), e && (t.unobserve_completed && T(n, t), C(t.callback_applied, n, e));
                }, Q = function(n, t, e) {
                    N(n, t.class_loading), w(n, v), e && (R(e, 1), C(t.callback_loading, n, e));
                }, W = function(n, t, e) {
                    e && n.setAttribute(t, e);
                }, X = function(n, t) {
                    W(n, d, y(n, t.data_sizes)), W(n, s, y(n, t.data_srcset)), W(n, u, y(n, t.data_src));
                }, Y = {
                    IMG: function(n, t) {
                        D(n, (function(n) {
                            $(n, B), X(n, t);
                        })), $(n, B), X(n, t);
                    },
                    IFRAME: function(n, t) {
                        $(n, V), W(n, u, y(n, t.data_src));
                    },
                    VIDEO: function(n, t) {
                        H(n, (function(n) {
                            $(n, V), W(n, u, y(n, t.data_src));
                        })), $(n, F), W(n, f, y(n, t.data_poster)), W(n, u, y(n, t.data_src)), n.load();
                    },
                    OBJECT: function(n, t) {
                        $(n, J), W(n, g, y(n, t.data_src));
                    }
                }, Z = [ "IMG", "IFRAME", "VIDEO", "OBJECT" ], nn = function(n, t) {
                    !t || function(n) {
                        return n.loadingCount > 0;
                    }(t) || function(n) {
                        return n.toLoadCount > 0;
                    }(t) || C(n.callback_finish, t);
                }, tn = function(n, t, e) {
                    n.addEventListener(t, e), n.llEvLisnrs[t] = e;
                }, en = function(n, t, e) {
                    n.removeEventListener(t, e);
                }, on = function(n) {
                    return !!n.llEvLisnrs;
                }, an = function(n) {
                    if (on(n)) {
                        var t = n.llEvLisnrs;
                        for (var e in t) {
                            var i = t[e];
                            en(n, e, i);
                        }
                        delete n.llEvLisnrs;
                    }
                }, rn = function(n, t, e) {
                    !function(n) {
                        delete n.llTempImage;
                    }(n), R(e, -1), function(n) {
                        n && (n.toLoadCount -= 1);
                    }(e), M(n, t.class_loading), t.unobserve_completed && T(n, e);
                }, cn = function(n, t, e) {
                    var i = z(n) || n;
                    on(i) || function(n, t, e) {
                        on(n) || (n.llEvLisnrs = {});
                        var i = "VIDEO" === n.tagName ? "loadeddata" : "load";
                        tn(n, i, t), tn(n, "error", e);
                    }(i, (function(o) {
                        !function(n, t, e, i) {
                            var o = O(t);
                            rn(t, e, i), N(t, e.class_loaded), w(t, b), C(e.callback_loaded, t, i), o || nn(e, i);
                        }(0, n, t, e), an(i);
                    }), (function(o) {
                        !function(n, t, e, i) {
                            var o = O(t);
                            rn(t, e, i), N(t, e.class_error), w(t, p), C(e.callback_error, t, i), e.restore_on_error && q(t, B), 
                            o || nn(e, i);
                        }(0, n, t, e), an(i);
                    }));
                }, ln = function(n, t, e) {
                    !function(n) {
                        return Z.indexOf(n.tagName) > -1;
                    }(n) ? function(n, t, e) {
                        !function(n) {
                            n.llTempImage = document.createElement("IMG");
                        }(n), cn(n, t, e), function(n) {
                            P(n) || (n[_] = {
                                backgroundImage: n.style.backgroundImage
                            });
                        }(n), function(n, t, e) {
                            var i = y(n, t.data_bg), o = y(n, t.data_bg_hidpi), r = a && o ? o : i;
                            r && (n.style.backgroundImage = 'url("'.concat(r, '")'), z(n).setAttribute(u, r), 
                            Q(n, t, e));
                        }(n, t, e), function(n, t, e) {
                            var i = y(n, t.data_bg_multi), o = y(n, t.data_bg_multi_hidpi), r = a && o ? o : i;
                            r && (n.style.backgroundImage = r, K(n, t, e));
                        }(n, t, e), function(n, t, e) {
                            var i = y(n, t.data_bg_set);
                            if (i) {
                                var o = i.split("|"), a = o.map((function(n) {
                                    return "image-set(".concat(n, ")");
                                }));
                                n.style.backgroundImage = a.join(), "" === n.style.backgroundImage && (a = o.map((function(n) {
                                    return "-webkit-image-set(".concat(n, ")");
                                })), n.style.backgroundImage = a.join()), K(n, t, e);
                            }
                        }(n, t, e);
                    }(n, t, e) : function(n, t, e) {
                        cn(n, t, e), function(n, t, e) {
                            var i = Y[n.tagName];
                            i && (i(n, t), Q(n, t, e));
                        }(n, t, e);
                    }(n, t, e);
                }, un = function(n) {
                    n.removeAttribute(u), n.removeAttribute(s), n.removeAttribute(d);
                }, sn = function(n) {
                    D(n, (function(n) {
                        q(n, B);
                    })), q(n, B);
                }, dn = {
                    IMG: sn,
                    IFRAME: function(n) {
                        q(n, V);
                    },
                    VIDEO: function(n) {
                        H(n, (function(n) {
                            q(n, V);
                        })), q(n, F), n.load();
                    },
                    OBJECT: function(n) {
                        q(n, J);
                    }
                }, fn = function(n, t) {
                    (function(n) {
                        var t = dn[n.tagName];
                        t ? t(n) : function(n) {
                            if (P(n)) {
                                var t = S(n);
                                n.style.backgroundImage = t.backgroundImage;
                            }
                        }(n);
                    })(n), function(n, t) {
                        L(n) || O(n) || (M(n, t.class_entered), M(n, t.class_exited), M(n, t.class_applied), 
                        M(n, t.class_loading), M(n, t.class_loaded), M(n, t.class_error));
                    }(n, t), A(n), U(n);
                }, _n = [ "IMG", "IFRAME", "VIDEO" ], gn = function(n) {
                    return n.use_native && "loading" in HTMLImageElement.prototype;
                }, vn = function(n, t, e) {
                    n.forEach((function(n) {
                        return function(n) {
                            return n.isIntersecting || n.intersectionRatio > 0;
                        }(n) ? function(n, t, e, i) {
                            var o = function(n) {
                                return x.indexOf(k(n)) >= 0;
                            }(n);
                            w(n, "entered"), N(n, e.class_entered), M(n, e.class_exited), function(n, t, e) {
                                t.unobserve_entered && T(n, e);
                            }(n, e, i), C(e.callback_enter, n, t, i), o || ln(n, e, i);
                        }(n.target, n, t, e) : function(n, t, e, i) {
                            L(n) || (N(n, e.class_exited), function(n, t, e, i) {
                                e.cancel_on_exit && function(n) {
                                    return k(n) === v;
                                }(n) && "IMG" === n.tagName && (an(n), function(n) {
                                    D(n, (function(n) {
                                        un(n);
                                    })), un(n);
                                }(n), sn(n), M(n, e.class_loading), R(i, -1), A(n), C(e.callback_cancel, n, t, i));
                            }(n, t, e, i), C(e.callback_exit, n, t, i));
                        }(n.target, n, t, e);
                    }));
                }, bn = function(n) {
                    return Array.prototype.slice.call(n);
                }, mn = function(n) {
                    return n.container.querySelectorAll(n.elements_selector);
                }, pn = function(n) {
                    return function(n) {
                        return k(n) === p;
                    }(n);
                }, hn = function(n, t) {
                    return function(n) {
                        return bn(n).filter(L);
                    }(n || mn(t));
                }, En = function(n, e) {
                    var o = c(n);
                    this._settings = o, this.loadingCount = 0, function(n, t) {
                        i && !gn(n) && (t._observer = new IntersectionObserver((function(e) {
                            vn(e, n, t);
                        }), function(n) {
                            return {
                                root: n.container === document ? null : n.container,
                                rootMargin: n.thresholds || n.threshold + "px"
                            };
                        }(n)));
                    }(o, this), function(n, e) {
                        t && (e._onlineHandler = function() {
                            !function(n, t) {
                                var e;
                                (e = mn(n), bn(e).filter(pn)).forEach((function(t) {
                                    M(t, n.class_error), A(t);
                                })), t.update();
                            }(n, e);
                        }, window.addEventListener("online", e._onlineHandler));
                    }(o, this), this.update(e);
                };
                return En.prototype = {
                    update: function(n) {
                        var t, o, a = this._settings, r = hn(n, a);
                        G(this, r.length), !e && i ? gn(a) ? function(n, t, e) {
                            n.forEach((function(n) {
                                -1 !== _n.indexOf(n.tagName) && function(n, t, e) {
                                    n.setAttribute("loading", "lazy"), cn(n, t, e), function(n, t) {
                                        var e = Y[n.tagName];
                                        e && e(n, t);
                                    }(n, t), w(n, h);
                                }(n, t, e);
                            })), G(e, 0);
                        }(r, a, this) : (o = r, function(n) {
                            n.disconnect();
                        }(t = this._observer), function(n, t) {
                            t.forEach((function(t) {
                                n.observe(t);
                            }));
                        }(t, o)) : this.loadAll(r);
                    },
                    destroy: function() {
                        this._observer && this._observer.disconnect(), t && window.removeEventListener("online", this._onlineHandler), 
                        mn(this._settings).forEach((function(n) {
                            U(n);
                        })), delete this._observer, delete this._settings, delete this._onlineHandler, delete this.loadingCount, 
                        delete this.toLoadCount;
                    },
                    loadAll: function(n) {
                        var t = this, e = this._settings;
                        hn(n, e).forEach((function(n) {
                            T(n, t), ln(n, e, t);
                        }));
                    },
                    restoreAll: function() {
                        var n = this._settings;
                        mn(n).forEach((function(t) {
                            fn(t, n);
                        }));
                    }
                }, En.load = function(n, t) {
                    var e = c(t);
                    ln(n, e);
                }, En.resetStatus = function(n) {
                    A(n);
                }, t && function(n, t) {
                    if (t) if (t.length) for (var e, i = 0; e = t[i]; i += 1) l(n, e); else l(n, t);
                }(En, window.lazyLoadOptions), En;
            }));
        }
    };
    var __webpack_module_cache__ = {};
    function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (void 0 !== cachedModule) return cachedModule.exports;
        var module = __webpack_module_cache__[moduleId] = {
            id: moduleId,
            loaded: false,
            exports: {}
        };
        __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        module.loaded = true;
        return module.exports;
    }
    (() => {
        __webpack_require__.g = function() {
            if ("object" === typeof globalThis) return globalThis;
            try {
                return this || new Function("return this")();
            } catch (e) {
                if ("object" === typeof window) return window;
            }
        }();
    })();
    (() => {
        __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    })();
    (() => {
        __webpack_require__.nmd = module => {
            module.paths = [];
            if (!module.children) module.children = [];
            return module;
        };
    })();
    (() => {
        "use strict";
        const modules_flsModules = {};
        function isWebp() {
            function testWebP(callback) {
                let webP = new Image;
                webP.onload = webP.onerror = function() {
                    callback(2 == webP.height);
                };
                webP.src = "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA";
            }
            testWebP((function(support) {
                let className = true === support ? "webp" : "no-webp";
                document.documentElement.classList.add(className);
            }));
        }
        function getHash() {
            if (location.hash) return location.hash.replace("#", "");
        }
        let bodyLockStatus = true;
        let bodyLockToggle = (delay = 500) => {
            if (document.documentElement.classList.contains("lock")) bodyUnlock(delay); else bodyLock(delay);
        };
        let bodyUnlock = (delay = 500) => {
            let body = document.querySelector("body");
            if (bodyLockStatus) {
                let lock_padding = document.querySelectorAll("[data-lp]");
                setTimeout((() => {
                    for (let index = 0; index < lock_padding.length; index++) {
                        const el = lock_padding[index];
                        el.style.paddingRight = "0px";
                    }
                    body.style.paddingRight = "0px";
                    document.documentElement.classList.remove("lock");
                }), delay);
                bodyLockStatus = false;
                setTimeout((function() {
                    bodyLockStatus = true;
                }), delay);
            }
        };
        let bodyLock = (delay = 500) => {
            let body = document.querySelector("body");
            if (bodyLockStatus) {
                let lock_padding = document.querySelectorAll("[data-lp]");
                for (let index = 0; index < lock_padding.length; index++) {
                    const el = lock_padding[index];
                    el.style.paddingRight = window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px";
                }
                body.style.paddingRight = window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px";
                document.documentElement.classList.add("lock");
                bodyLockStatus = false;
                setTimeout((function() {
                    bodyLockStatus = true;
                }), delay);
            }
        };
        function menuInit() {
            if (document.querySelector(".icon-menu")) document.addEventListener("click", (function(e) {
                if (bodyLockStatus && e.target.closest(".icon-menu")) {
                    bodyLockToggle();
                    document.documentElement.classList.toggle("menu-open");
                }
            }));
        }
        function menuClose() {
            bodyUnlock();
            document.documentElement.classList.remove("menu-open");
        }
        function functions_FLS(message) {
            setTimeout((() => {
                if (window.FLS) console.log(message);
            }), 0);
        }
        changeMenuItems();
        function changeMenuItems() {
            const menuItems = document.querySelectorAll(".menu__link"), isMain = document.querySelector("[data-main]");
            if (isMain) menuItems.forEach((item => {
                if (item.dataset.go) addDataForMenuItem(item);
            })); else menuItems.forEach((item => {
                if (item.dataset.go) addAnchorForMenuItem(item);
            }));
        }
        function addDataForMenuItem(item) {
            item.setAttribute("href", "#");
            item.dataset.gotoSpeed = 400;
            item.dataset.goto = `.${item.dataset.go}`;
        }
        function addAnchorForMenuItem(item) {
            item.setAttribute("href", `${item.dataset.url}#${item.dataset.go}`);
            item.dataset.gotoSpeed = "";
            item.dataset.goto = "";
        }
        addDirectForInvCategories();
        function addDirectForInvCategories() {
            const categoryItems = document.querySelectorAll(".category-inv");
            categoryItems.forEach(((item, i) => {
                const prlxImage = item.querySelector(".category-inv__img img");
                i % 2 === 0 ? prlxImage.dataset.prlxDxr = true : prlxImage.dataset.prlxDyr = true;
            }));
        }
        var smooth_scroll_polyfills_min = __webpack_require__(3002);
        let gotoblock_gotoBlock = (targetBlock, noHeader = false, speed = 500, offsetTop = 0) => {
            const targetBlockElement = document.querySelector(targetBlock);
            if (targetBlockElement) {
                let headerItem = "";
                let headerItemHeight = 0;
                if (noHeader) {
                    headerItem = "header.header";
                    const headerElement = document.querySelector(headerItem);
                    if (!headerElement.classList.contains("_header-scroll")) {
                        headerElement.style.cssText = `transition-duration: 0s;`;
                        headerElement.classList.add("_header-scroll");
                        headerItemHeight = headerElement.offsetHeight;
                        headerElement.classList.remove("_header-scroll");
                        setTimeout((() => {
                            headerElement.style.cssText = ``;
                        }), 0);
                    } else headerItemHeight = headerElement.offsetHeight;
                }
                let options = {
                    speedAsDuration: true,
                    speed,
                    header: headerItem,
                    offset: offsetTop,
                    easing: "easeOutQuad"
                };
                document.documentElement.classList.contains("menu-open") ? menuClose() : null;
                if ("undefined" !== typeof smooth_scroll_polyfills_min) (new smooth_scroll_polyfills_min).animateScroll(targetBlockElement, "", options); else {
                    let targetBlockElementPosition = targetBlockElement.getBoundingClientRect().top + scrollY;
                    targetBlockElementPosition = headerItemHeight ? targetBlockElementPosition - headerItemHeight : targetBlockElementPosition;
                    targetBlockElementPosition = offsetTop ? targetBlockElementPosition - offsetTop : targetBlockElementPosition;
                    window.scrollTo({
                        top: targetBlockElementPosition,
                        behavior: "smooth"
                    });
                }
                functions_FLS(`[gotoBlock]: ...  ${targetBlock}`);
            } else functions_FLS(`[gotoBlock]:  ..    : ${targetBlock}`);
        };
        function ssr_window_esm_isObject(obj) {
            return null !== obj && "object" === typeof obj && "constructor" in obj && obj.constructor === Object;
        }
        function extend(target = {}, src = {}) {
            Object.keys(src).forEach((key => {
                if ("undefined" === typeof target[key]) target[key] = src[key]; else if (ssr_window_esm_isObject(src[key]) && ssr_window_esm_isObject(target[key]) && Object.keys(src[key]).length > 0) extend(target[key], src[key]);
            }));
        }
        const ssrDocument = {
            body: {},
            addEventListener() {},
            removeEventListener() {},
            activeElement: {
                blur() {},
                nodeName: ""
            },
            querySelector() {
                return null;
            },
            querySelectorAll() {
                return [];
            },
            getElementById() {
                return null;
            },
            createEvent() {
                return {
                    initEvent() {}
                };
            },
            createElement() {
                return {
                    children: [],
                    childNodes: [],
                    style: {},
                    setAttribute() {},
                    getElementsByTagName() {
                        return [];
                    }
                };
            },
            createElementNS() {
                return {};
            },
            importNode() {
                return null;
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            }
        };
        function ssr_window_esm_getDocument() {
            const doc = "undefined" !== typeof document ? document : {};
            extend(doc, ssrDocument);
            return doc;
        }
        const ssrWindow = {
            document: ssrDocument,
            navigator: {
                userAgent: ""
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            },
            history: {
                replaceState() {},
                pushState() {},
                go() {},
                back() {}
            },
            CustomEvent: function CustomEvent() {
                return this;
            },
            addEventListener() {},
            removeEventListener() {},
            getComputedStyle() {
                return {
                    getPropertyValue() {
                        return "";
                    }
                };
            },
            Image() {},
            Date() {},
            screen: {},
            setTimeout() {},
            clearTimeout() {},
            matchMedia() {
                return {};
            },
            requestAnimationFrame(callback) {
                if ("undefined" === typeof setTimeout) {
                    callback();
                    return null;
                }
                return setTimeout(callback, 0);
            },
            cancelAnimationFrame(id) {
                if ("undefined" === typeof setTimeout) return;
                clearTimeout(id);
            }
        };
        function ssr_window_esm_getWindow() {
            const win = "undefined" !== typeof window ? window : {};
            extend(win, ssrWindow);
            return win;
        }
        function makeReactive(obj) {
            const proto = obj.__proto__;
            Object.defineProperty(obj, "__proto__", {
                get() {
                    return proto;
                },
                set(value) {
                    proto.__proto__ = value;
                }
            });
        }
        class Dom7 extends Array {
            constructor(items) {
                if ("number" === typeof items) super(items); else {
                    super(...items || []);
                    makeReactive(this);
                }
            }
        }
        function arrayFlat(arr = []) {
            const res = [];
            arr.forEach((el => {
                if (Array.isArray(el)) res.push(...arrayFlat(el)); else res.push(el);
            }));
            return res;
        }
        function arrayFilter(arr, callback) {
            return Array.prototype.filter.call(arr, callback);
        }
        function arrayUnique(arr) {
            const uniqueArray = [];
            for (let i = 0; i < arr.length; i += 1) if (-1 === uniqueArray.indexOf(arr[i])) uniqueArray.push(arr[i]);
            return uniqueArray;
        }
        function qsa(selector, context) {
            if ("string" !== typeof selector) return [ selector ];
            const a = [];
            const res = context.querySelectorAll(selector);
            for (let i = 0; i < res.length; i += 1) a.push(res[i]);
            return a;
        }
        function dom7_esm_$(selector, context) {
            const window = ssr_window_esm_getWindow();
            const document = ssr_window_esm_getDocument();
            let arr = [];
            if (!context && selector instanceof Dom7) return selector;
            if (!selector) return new Dom7(arr);
            if ("string" === typeof selector) {
                const html = selector.trim();
                if (html.indexOf("<") >= 0 && html.indexOf(">") >= 0) {
                    let toCreate = "div";
                    if (0 === html.indexOf("<li")) toCreate = "ul";
                    if (0 === html.indexOf("<tr")) toCreate = "tbody";
                    if (0 === html.indexOf("<td") || 0 === html.indexOf("<th")) toCreate = "tr";
                    if (0 === html.indexOf("<tbody")) toCreate = "table";
                    if (0 === html.indexOf("<option")) toCreate = "select";
                    const tempParent = document.createElement(toCreate);
                    tempParent.innerHTML = html;
                    for (let i = 0; i < tempParent.childNodes.length; i += 1) arr.push(tempParent.childNodes[i]);
                } else arr = qsa(selector.trim(), context || document);
            } else if (selector.nodeType || selector === window || selector === document) arr.push(selector); else if (Array.isArray(selector)) {
                if (selector instanceof Dom7) return selector;
                arr = selector;
            }
            return new Dom7(arrayUnique(arr));
        }
        dom7_esm_$.fn = Dom7.prototype;
        function addClass(...classes) {
            const classNames = arrayFlat(classes.map((c => c.split(" "))));
            this.forEach((el => {
                el.classList.add(...classNames);
            }));
            return this;
        }
        function removeClass(...classes) {
            const classNames = arrayFlat(classes.map((c => c.split(" "))));
            this.forEach((el => {
                el.classList.remove(...classNames);
            }));
            return this;
        }
        function toggleClass(...classes) {
            const classNames = arrayFlat(classes.map((c => c.split(" "))));
            this.forEach((el => {
                classNames.forEach((className => {
                    el.classList.toggle(className);
                }));
            }));
        }
        function hasClass(...classes) {
            const classNames = arrayFlat(classes.map((c => c.split(" "))));
            return arrayFilter(this, (el => classNames.filter((className => el.classList.contains(className))).length > 0)).length > 0;
        }
        function attr(attrs, value) {
            if (1 === arguments.length && "string" === typeof attrs) {
                if (this[0]) return this[0].getAttribute(attrs);
                return;
            }
            for (let i = 0; i < this.length; i += 1) if (2 === arguments.length) this[i].setAttribute(attrs, value); else for (const attrName in attrs) {
                this[i][attrName] = attrs[attrName];
                this[i].setAttribute(attrName, attrs[attrName]);
            }
            return this;
        }
        function removeAttr(attr) {
            for (let i = 0; i < this.length; i += 1) this[i].removeAttribute(attr);
            return this;
        }
        function transform(transform) {
            for (let i = 0; i < this.length; i += 1) this[i].style.transform = transform;
            return this;
        }
        function transition(duration) {
            for (let i = 0; i < this.length; i += 1) this[i].style.transitionDuration = "string" !== typeof duration ? `${duration}ms` : duration;
            return this;
        }
        function on(...args) {
            let [eventType, targetSelector, listener, capture] = args;
            if ("function" === typeof args[1]) {
                [eventType, listener, capture] = args;
                targetSelector = void 0;
            }
            if (!capture) capture = false;
            function handleLiveEvent(e) {
                const target = e.target;
                if (!target) return;
                const eventData = e.target.dom7EventData || [];
                if (eventData.indexOf(e) < 0) eventData.unshift(e);
                if (dom7_esm_$(target).is(targetSelector)) listener.apply(target, eventData); else {
                    const parents = dom7_esm_$(target).parents();
                    for (let k = 0; k < parents.length; k += 1) if (dom7_esm_$(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
                }
            }
            function handleEvent(e) {
                const eventData = e && e.target ? e.target.dom7EventData || [] : [];
                if (eventData.indexOf(e) < 0) eventData.unshift(e);
                listener.apply(this, eventData);
            }
            const events = eventType.split(" ");
            let j;
            for (let i = 0; i < this.length; i += 1) {
                const el = this[i];
                if (!targetSelector) for (j = 0; j < events.length; j += 1) {
                    const event = events[j];
                    if (!el.dom7Listeners) el.dom7Listeners = {};
                    if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
                    el.dom7Listeners[event].push({
                        listener,
                        proxyListener: handleEvent
                    });
                    el.addEventListener(event, handleEvent, capture);
                } else for (j = 0; j < events.length; j += 1) {
                    const event = events[j];
                    if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
                    if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
                    el.dom7LiveListeners[event].push({
                        listener,
                        proxyListener: handleLiveEvent
                    });
                    el.addEventListener(event, handleLiveEvent, capture);
                }
            }
            return this;
        }
        function off(...args) {
            let [eventType, targetSelector, listener, capture] = args;
            if ("function" === typeof args[1]) {
                [eventType, listener, capture] = args;
                targetSelector = void 0;
            }
            if (!capture) capture = false;
            const events = eventType.split(" ");
            for (let i = 0; i < events.length; i += 1) {
                const event = events[i];
                for (let j = 0; j < this.length; j += 1) {
                    const el = this[j];
                    let handlers;
                    if (!targetSelector && el.dom7Listeners) handlers = el.dom7Listeners[event]; else if (targetSelector && el.dom7LiveListeners) handlers = el.dom7LiveListeners[event];
                    if (handlers && handlers.length) for (let k = handlers.length - 1; k >= 0; k -= 1) {
                        const handler = handlers[k];
                        if (listener && handler.listener === listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        } else if (!listener) {
                            el.removeEventListener(event, handler.proxyListener, capture);
                            handlers.splice(k, 1);
                        }
                    }
                }
            }
            return this;
        }
        function trigger(...args) {
            const window = ssr_window_esm_getWindow();
            const events = args[0].split(" ");
            const eventData = args[1];
            for (let i = 0; i < events.length; i += 1) {
                const event = events[i];
                for (let j = 0; j < this.length; j += 1) {
                    const el = this[j];
                    if (window.CustomEvent) {
                        const evt = new window.CustomEvent(event, {
                            detail: eventData,
                            bubbles: true,
                            cancelable: true
                        });
                        el.dom7EventData = args.filter(((data, dataIndex) => dataIndex > 0));
                        el.dispatchEvent(evt);
                        el.dom7EventData = [];
                        delete el.dom7EventData;
                    }
                }
            }
            return this;
        }
        function transitionEnd(callback) {
            const dom = this;
            function fireCallBack(e) {
                if (e.target !== this) return;
                callback.call(this, e);
                dom.off("transitionend", fireCallBack);
            }
            if (callback) dom.on("transitionend", fireCallBack);
            return this;
        }
        function dom7_esm_outerWidth(includeMargins) {
            if (this.length > 0) {
                if (includeMargins) {
                    const styles = this.styles();
                    return this[0].offsetWidth + parseFloat(styles.getPropertyValue("margin-right")) + parseFloat(styles.getPropertyValue("margin-left"));
                }
                return this[0].offsetWidth;
            }
            return null;
        }
        function dom7_esm_outerHeight(includeMargins) {
            if (this.length > 0) {
                if (includeMargins) {
                    const styles = this.styles();
                    return this[0].offsetHeight + parseFloat(styles.getPropertyValue("margin-top")) + parseFloat(styles.getPropertyValue("margin-bottom"));
                }
                return this[0].offsetHeight;
            }
            return null;
        }
        function offset() {
            if (this.length > 0) {
                const window = ssr_window_esm_getWindow();
                const document = ssr_window_esm_getDocument();
                const el = this[0];
                const box = el.getBoundingClientRect();
                const body = document.body;
                const clientTop = el.clientTop || body.clientTop || 0;
                const clientLeft = el.clientLeft || body.clientLeft || 0;
                const scrollTop = el === window ? window.scrollY : el.scrollTop;
                const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
                return {
                    top: box.top + scrollTop - clientTop,
                    left: box.left + scrollLeft - clientLeft
                };
            }
            return null;
        }
        function styles() {
            const window = ssr_window_esm_getWindow();
            if (this[0]) return window.getComputedStyle(this[0], null);
            return {};
        }
        function css(props, value) {
            const window = ssr_window_esm_getWindow();
            let i;
            if (1 === arguments.length) if ("string" === typeof props) {
                if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
            } else {
                for (i = 0; i < this.length; i += 1) for (const prop in props) this[i].style[prop] = props[prop];
                return this;
            }
            if (2 === arguments.length && "string" === typeof props) {
                for (i = 0; i < this.length; i += 1) this[i].style[props] = value;
                return this;
            }
            return this;
        }
        function each(callback) {
            if (!callback) return this;
            this.forEach(((el, index) => {
                callback.apply(el, [ el, index ]);
            }));
            return this;
        }
        function filter(callback) {
            const result = arrayFilter(this, callback);
            return dom7_esm_$(result);
        }
        function html(html) {
            if ("undefined" === typeof html) return this[0] ? this[0].innerHTML : null;
            for (let i = 0; i < this.length; i += 1) this[i].innerHTML = html;
            return this;
        }
        function dom7_esm_text(text) {
            if ("undefined" === typeof text) return this[0] ? this[0].textContent.trim() : null;
            for (let i = 0; i < this.length; i += 1) this[i].textContent = text;
            return this;
        }
        function is(selector) {
            const window = ssr_window_esm_getWindow();
            const document = ssr_window_esm_getDocument();
            const el = this[0];
            let compareWith;
            let i;
            if (!el || "undefined" === typeof selector) return false;
            if ("string" === typeof selector) {
                if (el.matches) return el.matches(selector);
                if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
                if (el.msMatchesSelector) return el.msMatchesSelector(selector);
                compareWith = dom7_esm_$(selector);
                for (i = 0; i < compareWith.length; i += 1) if (compareWith[i] === el) return true;
                return false;
            }
            if (selector === document) return el === document;
            if (selector === window) return el === window;
            if (selector.nodeType || selector instanceof Dom7) {
                compareWith = selector.nodeType ? [ selector ] : selector;
                for (i = 0; i < compareWith.length; i += 1) if (compareWith[i] === el) return true;
                return false;
            }
            return false;
        }
        function index() {
            let child = this[0];
            let i;
            if (child) {
                i = 0;
                while (null !== (child = child.previousSibling)) if (1 === child.nodeType) i += 1;
                return i;
            }
            return;
        }
        function eq(index) {
            if ("undefined" === typeof index) return this;
            const length = this.length;
            if (index > length - 1) return dom7_esm_$([]);
            if (index < 0) {
                const returnIndex = length + index;
                if (returnIndex < 0) return dom7_esm_$([]);
                return dom7_esm_$([ this[returnIndex] ]);
            }
            return dom7_esm_$([ this[index] ]);
        }
        function append(...els) {
            let newChild;
            const document = ssr_window_esm_getDocument();
            for (let k = 0; k < els.length; k += 1) {
                newChild = els[k];
                for (let i = 0; i < this.length; i += 1) if ("string" === typeof newChild) {
                    const tempDiv = document.createElement("div");
                    tempDiv.innerHTML = newChild;
                    while (tempDiv.firstChild) this[i].appendChild(tempDiv.firstChild);
                } else if (newChild instanceof Dom7) for (let j = 0; j < newChild.length; j += 1) this[i].appendChild(newChild[j]); else this[i].appendChild(newChild);
            }
            return this;
        }
        function prepend(newChild) {
            const document = ssr_window_esm_getDocument();
            let i;
            let j;
            for (i = 0; i < this.length; i += 1) if ("string" === typeof newChild) {
                const tempDiv = document.createElement("div");
                tempDiv.innerHTML = newChild;
                for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
            } else if (newChild instanceof Dom7) for (j = 0; j < newChild.length; j += 1) this[i].insertBefore(newChild[j], this[i].childNodes[0]); else this[i].insertBefore(newChild, this[i].childNodes[0]);
            return this;
        }
        function next(selector) {
            if (this.length > 0) {
                if (selector) {
                    if (this[0].nextElementSibling && dom7_esm_$(this[0].nextElementSibling).is(selector)) return dom7_esm_$([ this[0].nextElementSibling ]);
                    return dom7_esm_$([]);
                }
                if (this[0].nextElementSibling) return dom7_esm_$([ this[0].nextElementSibling ]);
                return dom7_esm_$([]);
            }
            return dom7_esm_$([]);
        }
        function nextAll(selector) {
            const nextEls = [];
            let el = this[0];
            if (!el) return dom7_esm_$([]);
            while (el.nextElementSibling) {
                const next = el.nextElementSibling;
                if (selector) {
                    if (dom7_esm_$(next).is(selector)) nextEls.push(next);
                } else nextEls.push(next);
                el = next;
            }
            return dom7_esm_$(nextEls);
        }
        function prev(selector) {
            if (this.length > 0) {
                const el = this[0];
                if (selector) {
                    if (el.previousElementSibling && dom7_esm_$(el.previousElementSibling).is(selector)) return dom7_esm_$([ el.previousElementSibling ]);
                    return dom7_esm_$([]);
                }
                if (el.previousElementSibling) return dom7_esm_$([ el.previousElementSibling ]);
                return dom7_esm_$([]);
            }
            return dom7_esm_$([]);
        }
        function prevAll(selector) {
            const prevEls = [];
            let el = this[0];
            if (!el) return dom7_esm_$([]);
            while (el.previousElementSibling) {
                const prev = el.previousElementSibling;
                if (selector) {
                    if (dom7_esm_$(prev).is(selector)) prevEls.push(prev);
                } else prevEls.push(prev);
                el = prev;
            }
            return dom7_esm_$(prevEls);
        }
        function dom7_esm_parent(selector) {
            const parents = [];
            for (let i = 0; i < this.length; i += 1) if (null !== this[i].parentNode) if (selector) {
                if (dom7_esm_$(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
            } else parents.push(this[i].parentNode);
            return dom7_esm_$(parents);
        }
        function parents(selector) {
            const parents = [];
            for (let i = 0; i < this.length; i += 1) {
                let parent = this[i].parentNode;
                while (parent) {
                    if (selector) {
                        if (dom7_esm_$(parent).is(selector)) parents.push(parent);
                    } else parents.push(parent);
                    parent = parent.parentNode;
                }
            }
            return dom7_esm_$(parents);
        }
        function closest(selector) {
            let closest = this;
            if ("undefined" === typeof selector) return dom7_esm_$([]);
            if (!closest.is(selector)) closest = closest.parents(selector).eq(0);
            return closest;
        }
        function find(selector) {
            const foundElements = [];
            for (let i = 0; i < this.length; i += 1) {
                const found = this[i].querySelectorAll(selector);
                for (let j = 0; j < found.length; j += 1) foundElements.push(found[j]);
            }
            return dom7_esm_$(foundElements);
        }
        function children(selector) {
            const children = [];
            for (let i = 0; i < this.length; i += 1) {
                const childNodes = this[i].children;
                for (let j = 0; j < childNodes.length; j += 1) if (!selector || dom7_esm_$(childNodes[j]).is(selector)) children.push(childNodes[j]);
            }
            return dom7_esm_$(children);
        }
        function remove() {
            for (let i = 0; i < this.length; i += 1) if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
            return this;
        }
        const noTrigger = "resize scroll".split(" ");
        function shortcut(name) {
            function eventHandler(...args) {
                if ("undefined" === typeof args[0]) {
                    for (let i = 0; i < this.length; i += 1) if (noTrigger.indexOf(name) < 0) if (name in this[i]) this[i][name](); else dom7_esm_$(this[i]).trigger(name);
                    return this;
                }
                return this.on(name, ...args);
            }
            return eventHandler;
        }
        shortcut("click");
        shortcut("blur");
        shortcut("focus");
        shortcut("focusin");
        shortcut("focusout");
        shortcut("keyup");
        shortcut("keydown");
        shortcut("keypress");
        shortcut("submit");
        shortcut("change");
        shortcut("mousedown");
        shortcut("mousemove");
        shortcut("mouseup");
        shortcut("mouseenter");
        shortcut("mouseleave");
        shortcut("mouseout");
        shortcut("mouseover");
        shortcut("touchstart");
        shortcut("touchend");
        shortcut("touchmove");
        shortcut("resize");
        shortcut("scroll");
        const Methods = {
            addClass,
            removeClass,
            hasClass,
            toggleClass,
            attr,
            removeAttr,
            transform,
            transition,
            on,
            off,
            trigger,
            transitionEnd,
            outerWidth: dom7_esm_outerWidth,
            outerHeight: dom7_esm_outerHeight,
            styles,
            offset,
            css,
            each,
            html,
            text: dom7_esm_text,
            is,
            index,
            eq,
            append,
            prepend,
            next,
            nextAll,
            prev,
            prevAll,
            parent: dom7_esm_parent,
            parents,
            closest,
            find,
            children,
            filter,
            remove
        };
        Object.keys(Methods).forEach((methodName => {
            Object.defineProperty(dom7_esm_$.fn, methodName, {
                value: Methods[methodName],
                writable: true
            });
        }));
        const dom = dom7_esm_$;
        function deleteProps(obj) {
            const object = obj;
            Object.keys(object).forEach((key => {
                try {
                    object[key] = null;
                } catch (e) {}
                try {
                    delete object[key];
                } catch (e) {}
            }));
        }
        function utils_nextTick(callback, delay = 0) {
            return setTimeout(callback, delay);
        }
        function utils_now() {
            return Date.now();
        }
        function utils_getComputedStyle(el) {
            const window = ssr_window_esm_getWindow();
            let style;
            if (window.getComputedStyle) style = window.getComputedStyle(el, null);
            if (!style && el.currentStyle) style = el.currentStyle;
            if (!style) style = el.style;
            return style;
        }
        function utils_getTranslate(el, axis = "x") {
            const window = ssr_window_esm_getWindow();
            let matrix;
            let curTransform;
            let transformMatrix;
            const curStyle = utils_getComputedStyle(el, null);
            if (window.WebKitCSSMatrix) {
                curTransform = curStyle.transform || curStyle.webkitTransform;
                if (curTransform.split(",").length > 6) curTransform = curTransform.split(", ").map((a => a.replace(",", "."))).join(", ");
                transformMatrix = new window.WebKitCSSMatrix("none" === curTransform ? "" : curTransform);
            } else {
                transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
                matrix = transformMatrix.toString().split(",");
            }
            if ("x" === axis) if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; else if (16 === matrix.length) curTransform = parseFloat(matrix[12]); else curTransform = parseFloat(matrix[4]);
            if ("y" === axis) if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; else if (16 === matrix.length) curTransform = parseFloat(matrix[13]); else curTransform = parseFloat(matrix[5]);
            return curTransform || 0;
        }
        function utils_isObject(o) {
            return "object" === typeof o && null !== o && o.constructor && "Object" === Object.prototype.toString.call(o).slice(8, -1);
        }
        function isNode(node) {
            if ("undefined" !== typeof window && "undefined" !== typeof window.HTMLElement) return node instanceof HTMLElement;
            return node && (1 === node.nodeType || 11 === node.nodeType);
        }
        function utils_extend(...args) {
            const to = Object(args[0]);
            const noExtend = [ "__proto__", "constructor", "prototype" ];
            for (let i = 1; i < args.length; i += 1) {
                const nextSource = args[i];
                if (void 0 !== nextSource && null !== nextSource && !isNode(nextSource)) {
                    const keysArray = Object.keys(Object(nextSource)).filter((key => noExtend.indexOf(key) < 0));
                    for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                        const nextKey = keysArray[nextIndex];
                        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                        if (void 0 !== desc && desc.enumerable) if (utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else utils_extend(to[nextKey], nextSource[nextKey]); else if (!utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {
                            to[nextKey] = {};
                            if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else utils_extend(to[nextKey], nextSource[nextKey]);
                        } else to[nextKey] = nextSource[nextKey];
                    }
                }
            }
            return to;
        }
        function utils_setCSSProperty(el, varName, varValue) {
            el.style.setProperty(varName, varValue);
        }
        function animateCSSModeScroll({swiper, targetPosition, side}) {
            const window = ssr_window_esm_getWindow();
            const startPosition = -swiper.translate;
            let startTime = null;
            let time;
            const duration = swiper.params.speed;
            swiper.wrapperEl.style.scrollSnapType = "none";
            window.cancelAnimationFrame(swiper.cssModeFrameID);
            const dir = targetPosition > startPosition ? "next" : "prev";
            const isOutOfBound = (current, target) => "next" === dir && current >= target || "prev" === dir && current <= target;
            const animate = () => {
                time = (new Date).getTime();
                if (null === startTime) startTime = time;
                const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
                const easeProgress = .5 - Math.cos(progress * Math.PI) / 2;
                let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
                if (isOutOfBound(currentPosition, targetPosition)) currentPosition = targetPosition;
                swiper.wrapperEl.scrollTo({
                    [side]: currentPosition
                });
                if (isOutOfBound(currentPosition, targetPosition)) {
                    swiper.wrapperEl.style.overflow = "hidden";
                    swiper.wrapperEl.style.scrollSnapType = "";
                    setTimeout((() => {
                        swiper.wrapperEl.style.overflow = "";
                        swiper.wrapperEl.scrollTo({
                            [side]: currentPosition
                        });
                    }));
                    window.cancelAnimationFrame(swiper.cssModeFrameID);
                    return;
                }
                swiper.cssModeFrameID = window.requestAnimationFrame(animate);
            };
            animate();
        }
        let support;
        function calcSupport() {
            const window = ssr_window_esm_getWindow();
            const document = ssr_window_esm_getDocument();
            return {
                smoothScroll: document.documentElement && "scrollBehavior" in document.documentElement.style,
                touch: !!("ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch),
                passiveListener: function checkPassiveListener() {
                    let supportsPassive = false;
                    try {
                        const opts = Object.defineProperty({}, "passive", {
                            get() {
                                supportsPassive = true;
                            }
                        });
                        window.addEventListener("testPassiveListener", null, opts);
                    } catch (e) {}
                    return supportsPassive;
                }(),
                gestures: function checkGestures() {
                    return "ongesturestart" in window;
                }()
            };
        }
        function getSupport() {
            if (!support) support = calcSupport();
            return support;
        }
        let deviceCached;
        function calcDevice({userAgent} = {}) {
            const support = getSupport();
            const window = ssr_window_esm_getWindow();
            const platform = window.navigator.platform;
            const ua = userAgent || window.navigator.userAgent;
            const device = {
                ios: false,
                android: false
            };
            const screenWidth = window.screen.width;
            const screenHeight = window.screen.height;
            const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
            let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
            const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
            const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
            const windows = "Win32" === platform;
            let macos = "MacIntel" === platform;
            const iPadScreens = [ "1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810" ];
            if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
                ipad = ua.match(/(Version)\/([\d.]+)/);
                if (!ipad) ipad = [ 0, 1, "13_0_0" ];
                macos = false;
            }
            if (android && !windows) {
                device.os = "android";
                device.android = true;
            }
            if (ipad || iphone || ipod) {
                device.os = "ios";
                device.ios = true;
            }
            return device;
        }
        function getDevice(overrides = {}) {
            if (!deviceCached) deviceCached = calcDevice(overrides);
            return deviceCached;
        }
        let browser;
        function calcBrowser() {
            const window = ssr_window_esm_getWindow();
            function isSafari() {
                const ua = window.navigator.userAgent.toLowerCase();
                return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
            }
            return {
                isSafari: isSafari(),
                isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
            };
        }
        function getBrowser() {
            if (!browser) browser = calcBrowser();
            return browser;
        }
        function Resize({swiper, on, emit}) {
            const window = ssr_window_esm_getWindow();
            let observer = null;
            let animationFrame = null;
            const resizeHandler = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                emit("beforeResize");
                emit("resize");
            };
            const createObserver = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                observer = new ResizeObserver((entries => {
                    animationFrame = window.requestAnimationFrame((() => {
                        const {width, height} = swiper;
                        let newWidth = width;
                        let newHeight = height;
                        entries.forEach((({contentBoxSize, contentRect, target}) => {
                            if (target && target !== swiper.el) return;
                            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                        }));
                        if (newWidth !== width || newHeight !== height) resizeHandler();
                    }));
                }));
                observer.observe(swiper.el);
            };
            const removeObserver = () => {
                if (animationFrame) window.cancelAnimationFrame(animationFrame);
                if (observer && observer.unobserve && swiper.el) {
                    observer.unobserve(swiper.el);
                    observer = null;
                }
            };
            const orientationChangeHandler = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                emit("orientationchange");
            };
            on("init", (() => {
                if (swiper.params.resizeObserver && "undefined" !== typeof window.ResizeObserver) {
                    createObserver();
                    return;
                }
                window.addEventListener("resize", resizeHandler);
                window.addEventListener("orientationchange", orientationChangeHandler);
            }));
            on("destroy", (() => {
                removeObserver();
                window.removeEventListener("resize", resizeHandler);
                window.removeEventListener("orientationchange", orientationChangeHandler);
            }));
        }
        function Observer({swiper, extendParams, on, emit}) {
            const observers = [];
            const window = ssr_window_esm_getWindow();
            const attach = (target, options = {}) => {
                const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
                const observer = new ObserverFunc((mutations => {
                    if (1 === mutations.length) {
                        emit("observerUpdate", mutations[0]);
                        return;
                    }
                    const observerUpdate = function observerUpdate() {
                        emit("observerUpdate", mutations[0]);
                    };
                    if (window.requestAnimationFrame) window.requestAnimationFrame(observerUpdate); else window.setTimeout(observerUpdate, 0);
                }));
                observer.observe(target, {
                    attributes: "undefined" === typeof options.attributes ? true : options.attributes,
                    childList: "undefined" === typeof options.childList ? true : options.childList,
                    characterData: "undefined" === typeof options.characterData ? true : options.characterData
                });
                observers.push(observer);
            };
            const init = () => {
                if (!swiper.params.observer) return;
                if (swiper.params.observeParents) {
                    const containerParents = swiper.$el.parents();
                    for (let i = 0; i < containerParents.length; i += 1) attach(containerParents[i]);
                }
                attach(swiper.$el[0], {
                    childList: swiper.params.observeSlideChildren
                });
                attach(swiper.$wrapperEl[0], {
                    attributes: false
                });
            };
            const destroy = () => {
                observers.forEach((observer => {
                    observer.disconnect();
                }));
                observers.splice(0, observers.length);
            };
            extendParams({
                observer: false,
                observeParents: false,
                observeSlideChildren: false
            });
            on("init", init);
            on("destroy", destroy);
        }
        const events_emitter = {
            on(events, handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if ("function" !== typeof handler) return self;
                const method = priority ? "unshift" : "push";
                events.split(" ").forEach((event => {
                    if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
                    self.eventsListeners[event][method](handler);
                }));
                return self;
            },
            once(events, handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if ("function" !== typeof handler) return self;
                function onceHandler(...args) {
                    self.off(events, onceHandler);
                    if (onceHandler.__emitterProxy) delete onceHandler.__emitterProxy;
                    handler.apply(self, args);
                }
                onceHandler.__emitterProxy = handler;
                return self.on(events, onceHandler, priority);
            },
            onAny(handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if ("function" !== typeof handler) return self;
                const method = priority ? "unshift" : "push";
                if (self.eventsAnyListeners.indexOf(handler) < 0) self.eventsAnyListeners[method](handler);
                return self;
            },
            offAny(handler) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsAnyListeners) return self;
                const index = self.eventsAnyListeners.indexOf(handler);
                if (index >= 0) self.eventsAnyListeners.splice(index, 1);
                return self;
            },
            off(events, handler) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsListeners) return self;
                events.split(" ").forEach((event => {
                    if ("undefined" === typeof handler) self.eventsListeners[event] = []; else if (self.eventsListeners[event]) self.eventsListeners[event].forEach(((eventHandler, index) => {
                        if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) self.eventsListeners[event].splice(index, 1);
                    }));
                }));
                return self;
            },
            emit(...args) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsListeners) return self;
                let events;
                let data;
                let context;
                if ("string" === typeof args[0] || Array.isArray(args[0])) {
                    events = args[0];
                    data = args.slice(1, args.length);
                    context = self;
                } else {
                    events = args[0].events;
                    data = args[0].data;
                    context = args[0].context || self;
                }
                data.unshift(context);
                const eventsArray = Array.isArray(events) ? events : events.split(" ");
                eventsArray.forEach((event => {
                    if (self.eventsAnyListeners && self.eventsAnyListeners.length) self.eventsAnyListeners.forEach((eventHandler => {
                        eventHandler.apply(context, [ event, ...data ]);
                    }));
                    if (self.eventsListeners && self.eventsListeners[event]) self.eventsListeners[event].forEach((eventHandler => {
                        eventHandler.apply(context, data);
                    }));
                }));
                return self;
            }
        };
        function updateSize() {
            const swiper = this;
            let width;
            let height;
            const $el = swiper.$el;
            if ("undefined" !== typeof swiper.params.width && null !== swiper.params.width) width = swiper.params.width; else width = $el[0].clientWidth;
            if ("undefined" !== typeof swiper.params.height && null !== swiper.params.height) height = swiper.params.height; else height = $el[0].clientHeight;
            if (0 === width && swiper.isHorizontal() || 0 === height && swiper.isVertical()) return;
            width = width - parseInt($el.css("padding-left") || 0, 10) - parseInt($el.css("padding-right") || 0, 10);
            height = height - parseInt($el.css("padding-top") || 0, 10) - parseInt($el.css("padding-bottom") || 0, 10);
            if (Number.isNaN(width)) width = 0;
            if (Number.isNaN(height)) height = 0;
            Object.assign(swiper, {
                width,
                height,
                size: swiper.isHorizontal() ? width : height
            });
        }
        function updateSlides() {
            const swiper = this;
            function getDirectionLabel(property) {
                if (swiper.isHorizontal()) return property;
                return {
                    width: "height",
                    "margin-top": "margin-left",
                    "margin-bottom ": "margin-right",
                    "margin-left": "margin-top",
                    "margin-right": "margin-bottom",
                    "padding-left": "padding-top",
                    "padding-right": "padding-bottom",
                    marginRight: "marginBottom"
                }[property];
            }
            function getDirectionPropertyValue(node, label) {
                return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
            }
            const params = swiper.params;
            const {$wrapperEl, size: swiperSize, rtlTranslate: rtl, wrongRTL} = swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
            const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
            const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
            let snapGrid = [];
            const slidesGrid = [];
            const slidesSizesGrid = [];
            let offsetBefore = params.slidesOffsetBefore;
            if ("function" === typeof offsetBefore) offsetBefore = params.slidesOffsetBefore.call(swiper);
            let offsetAfter = params.slidesOffsetAfter;
            if ("function" === typeof offsetAfter) offsetAfter = params.slidesOffsetAfter.call(swiper);
            const previousSnapGridLength = swiper.snapGrid.length;
            const previousSlidesGridLength = swiper.slidesGrid.length;
            let spaceBetween = params.spaceBetween;
            let slidePosition = -offsetBefore;
            let prevSlideSize = 0;
            let index = 0;
            if ("undefined" === typeof swiperSize) return;
            if ("string" === typeof spaceBetween && spaceBetween.indexOf("%") >= 0) spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
            swiper.virtualSize = -spaceBetween;
            if (rtl) slides.css({
                marginLeft: "",
                marginBottom: "",
                marginTop: ""
            }); else slides.css({
                marginRight: "",
                marginBottom: "",
                marginTop: ""
            });
            if (params.centeredSlides && params.cssMode) {
                utils_setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-before", "");
                utils_setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-after", "");
            }
            const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
            if (gridEnabled) swiper.grid.initSlides(slidesLength);
            let slideSize;
            const shouldResetSlideSize = "auto" === params.slidesPerView && params.breakpoints && Object.keys(params.breakpoints).filter((key => "undefined" !== typeof params.breakpoints[key].slidesPerView)).length > 0;
            for (let i = 0; i < slidesLength; i += 1) {
                slideSize = 0;
                const slide = slides.eq(i);
                if (gridEnabled) swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
                if ("none" === slide.css("display")) continue;
                if ("auto" === params.slidesPerView) {
                    if (shouldResetSlideSize) slides[i].style[getDirectionLabel("width")] = ``;
                    const slideStyles = getComputedStyle(slide[0]);
                    const currentTransform = slide[0].style.transform;
                    const currentWebKitTransform = slide[0].style.webkitTransform;
                    if (currentTransform) slide[0].style.transform = "none";
                    if (currentWebKitTransform) slide[0].style.webkitTransform = "none";
                    if (params.roundLengths) slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true); else {
                        const width = getDirectionPropertyValue(slideStyles, "width");
                        const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
                        const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
                        const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
                        const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
                        const boxSizing = slideStyles.getPropertyValue("box-sizing");
                        if (boxSizing && "border-box" === boxSizing) slideSize = width + marginLeft + marginRight; else {
                            const {clientWidth, offsetWidth} = slide[0];
                            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                        }
                    }
                    if (currentTransform) slide[0].style.transform = currentTransform;
                    if (currentWebKitTransform) slide[0].style.webkitTransform = currentWebKitTransform;
                    if (params.roundLengths) slideSize = Math.floor(slideSize);
                } else {
                    slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
                    if (params.roundLengths) slideSize = Math.floor(slideSize);
                    if (slides[i]) slides[i].style[getDirectionLabel("width")] = `${slideSize}px`;
                }
                if (slides[i]) slides[i].swiperSlideSize = slideSize;
                slidesSizesGrid.push(slideSize);
                if (params.centeredSlides) {
                    slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
                    if (0 === prevSlideSize && 0 !== i) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                    if (0 === i) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                    if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;
                    if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                    if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                    slidesGrid.push(slidePosition);
                } else {
                    if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                    if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                    slidesGrid.push(slidePosition);
                    slidePosition = slidePosition + slideSize + spaceBetween;
                }
                swiper.virtualSize += slideSize + spaceBetween;
                prevSlideSize = slideSize;
                index += 1;
            }
            swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
            if (rtl && wrongRTL && ("slide" === params.effect || "coverflow" === params.effect)) $wrapperEl.css({
                width: `${swiper.virtualSize + params.spaceBetween}px`
            });
            if (params.setWrapperSize) $wrapperEl.css({
                [getDirectionLabel("width")]: `${swiper.virtualSize + params.spaceBetween}px`
            });
            if (gridEnabled) swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
            if (!params.centeredSlides) {
                const newSlidesGrid = [];
                for (let i = 0; i < snapGrid.length; i += 1) {
                    let slidesGridItem = snapGrid[i];
                    if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                    if (snapGrid[i] <= swiper.virtualSize - swiperSize) newSlidesGrid.push(slidesGridItem);
                }
                snapGrid = newSlidesGrid;
                if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) snapGrid.push(swiper.virtualSize - swiperSize);
            }
            if (0 === snapGrid.length) snapGrid = [ 0 ];
            if (0 !== params.spaceBetween) {
                const key = swiper.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
                slides.filter(((_, slideIndex) => {
                    if (!params.cssMode) return true;
                    if (slideIndex === slides.length - 1) return false;
                    return true;
                })).css({
                    [key]: `${spaceBetween}px`
                });
            }
            if (params.centeredSlides && params.centeredSlidesBounds) {
                let allSlidesSize = 0;
                slidesSizesGrid.forEach((slideSizeValue => {
                    allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
                }));
                allSlidesSize -= params.spaceBetween;
                const maxSnap = allSlidesSize - swiperSize;
                snapGrid = snapGrid.map((snap => {
                    if (snap < 0) return -offsetBefore;
                    if (snap > maxSnap) return maxSnap + offsetAfter;
                    return snap;
                }));
            }
            if (params.centerInsufficientSlides) {
                let allSlidesSize = 0;
                slidesSizesGrid.forEach((slideSizeValue => {
                    allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
                }));
                allSlidesSize -= params.spaceBetween;
                if (allSlidesSize < swiperSize) {
                    const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
                    snapGrid.forEach(((snap, snapIndex) => {
                        snapGrid[snapIndex] = snap - allSlidesOffset;
                    }));
                    slidesGrid.forEach(((snap, snapIndex) => {
                        slidesGrid[snapIndex] = snap + allSlidesOffset;
                    }));
                }
            }
            Object.assign(swiper, {
                slides,
                snapGrid,
                slidesGrid,
                slidesSizesGrid
            });
            if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
                utils_setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
                utils_setCSSProperty(swiper.wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
                const addToSnapGrid = -swiper.snapGrid[0];
                const addToSlidesGrid = -swiper.slidesGrid[0];
                swiper.snapGrid = swiper.snapGrid.map((v => v + addToSnapGrid));
                swiper.slidesGrid = swiper.slidesGrid.map((v => v + addToSlidesGrid));
            }
            if (slidesLength !== previousSlidesLength) swiper.emit("slidesLengthChange");
            if (snapGrid.length !== previousSnapGridLength) {
                if (swiper.params.watchOverflow) swiper.checkOverflow();
                swiper.emit("snapGridLengthChange");
            }
            if (slidesGrid.length !== previousSlidesGridLength) swiper.emit("slidesGridLengthChange");
            if (params.watchSlidesProgress) swiper.updateSlidesOffset();
            if (!isVirtual && !params.cssMode && ("slide" === params.effect || "fade" === params.effect)) {
                const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
                const hasClassBackfaceClassAdded = swiper.$el.hasClass(backFaceHiddenClass);
                if (slidesLength <= params.maxBackfaceHiddenSlides) {
                    if (!hasClassBackfaceClassAdded) swiper.$el.addClass(backFaceHiddenClass);
                } else if (hasClassBackfaceClassAdded) swiper.$el.removeClass(backFaceHiddenClass);
            }
        }
        function updateAutoHeight(speed) {
            const swiper = this;
            const activeSlides = [];
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            let newHeight = 0;
            let i;
            if ("number" === typeof speed) swiper.setTransition(speed); else if (true === speed) swiper.setTransition(swiper.params.speed);
            const getSlideByIndex = index => {
                if (isVirtual) return swiper.slides.filter((el => parseInt(el.getAttribute("data-swiper-slide-index"), 10) === index))[0];
                return swiper.slides.eq(index)[0];
            };
            if ("auto" !== swiper.params.slidesPerView && swiper.params.slidesPerView > 1) if (swiper.params.centeredSlides) (swiper.visibleSlides || dom([])).each((slide => {
                activeSlides.push(slide);
            })); else for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                const index = swiper.activeIndex + i;
                if (index > swiper.slides.length && !isVirtual) break;
                activeSlides.push(getSlideByIndex(index));
            } else activeSlides.push(getSlideByIndex(swiper.activeIndex));
            for (i = 0; i < activeSlides.length; i += 1) if ("undefined" !== typeof activeSlides[i]) {
                const height = activeSlides[i].offsetHeight;
                newHeight = height > newHeight ? height : newHeight;
            }
            if (newHeight || 0 === newHeight) swiper.$wrapperEl.css("height", `${newHeight}px`);
        }
        function updateSlidesOffset() {
            const swiper = this;
            const slides = swiper.slides;
            for (let i = 0; i < slides.length; i += 1) slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
        }
        function updateSlidesProgress(translate = this && this.translate || 0) {
            const swiper = this;
            const params = swiper.params;
            const {slides, rtlTranslate: rtl, snapGrid} = swiper;
            if (0 === slides.length) return;
            if ("undefined" === typeof slides[0].swiperSlideOffset) swiper.updateSlidesOffset();
            let offsetCenter = -translate;
            if (rtl) offsetCenter = translate;
            slides.removeClass(params.slideVisibleClass);
            swiper.visibleSlidesIndexes = [];
            swiper.visibleSlides = [];
            for (let i = 0; i < slides.length; i += 1) {
                const slide = slides[i];
                let slideOffset = slide.swiperSlideOffset;
                if (params.cssMode && params.centeredSlides) slideOffset -= slides[0].swiperSlideOffset;
                const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
                const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + params.spaceBetween);
                const slideBefore = -(offsetCenter - slideOffset);
                const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
                const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
                if (isVisible) {
                    swiper.visibleSlides.push(slide);
                    swiper.visibleSlidesIndexes.push(i);
                    slides.eq(i).addClass(params.slideVisibleClass);
                }
                slide.progress = rtl ? -slideProgress : slideProgress;
                slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
            }
            swiper.visibleSlides = dom(swiper.visibleSlides);
        }
        function updateProgress(translate) {
            const swiper = this;
            if ("undefined" === typeof translate) {
                const multiplier = swiper.rtlTranslate ? -1 : 1;
                translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
            }
            const params = swiper.params;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            let {progress, isBeginning, isEnd} = swiper;
            const wasBeginning = isBeginning;
            const wasEnd = isEnd;
            if (0 === translatesDiff) {
                progress = 0;
                isBeginning = true;
                isEnd = true;
            } else {
                progress = (translate - swiper.minTranslate()) / translatesDiff;
                isBeginning = progress <= 0;
                isEnd = progress >= 1;
            }
            Object.assign(swiper, {
                progress,
                isBeginning,
                isEnd
            });
            if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
            if (isBeginning && !wasBeginning) swiper.emit("reachBeginning toEdge");
            if (isEnd && !wasEnd) swiper.emit("reachEnd toEdge");
            if (wasBeginning && !isBeginning || wasEnd && !isEnd) swiper.emit("fromEdge");
            swiper.emit("progress", progress);
        }
        function updateSlidesClasses() {
            const swiper = this;
            const {slides, params, $wrapperEl, activeIndex, realIndex} = swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);
            let activeSlide;
            if (isVirtual) activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`); else activeSlide = slides.eq(activeIndex);
            activeSlide.addClass(params.slideActiveClass);
            if (params.loop) if (activeSlide.hasClass(params.slideDuplicateClass)) $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass); else $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
            let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
            if (params.loop && 0 === nextSlide.length) {
                nextSlide = slides.eq(0);
                nextSlide.addClass(params.slideNextClass);
            }
            let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
            if (params.loop && 0 === prevSlide.length) {
                prevSlide = slides.eq(-1);
                prevSlide.addClass(params.slidePrevClass);
            }
            if (params.loop) {
                if (nextSlide.hasClass(params.slideDuplicateClass)) $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass); else $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicateNextClass);
                if (prevSlide.hasClass(params.slideDuplicateClass)) $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass); else $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr("data-swiper-slide-index")}"]`).addClass(params.slideDuplicatePrevClass);
            }
            swiper.emitSlidesClasses();
        }
        function updateActiveIndex(newActiveIndex) {
            const swiper = this;
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            const {slidesGrid, snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex} = swiper;
            let activeIndex = newActiveIndex;
            let snapIndex;
            if ("undefined" === typeof activeIndex) {
                for (let i = 0; i < slidesGrid.length; i += 1) if ("undefined" !== typeof slidesGrid[i + 1]) {
                    if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) activeIndex = i; else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) activeIndex = i + 1;
                } else if (translate >= slidesGrid[i]) activeIndex = i;
                if (params.normalizeSlideIndex) if (activeIndex < 0 || "undefined" === typeof activeIndex) activeIndex = 0;
            }
            if (snapGrid.indexOf(translate) >= 0) snapIndex = snapGrid.indexOf(translate); else {
                const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
                snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
            }
            if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
            if (activeIndex === previousIndex) {
                if (snapIndex !== previousSnapIndex) {
                    swiper.snapIndex = snapIndex;
                    swiper.emit("snapIndexChange");
                }
                return;
            }
            const realIndex = parseInt(swiper.slides.eq(activeIndex).attr("data-swiper-slide-index") || activeIndex, 10);
            Object.assign(swiper, {
                snapIndex,
                realIndex,
                previousIndex,
                activeIndex
            });
            swiper.emit("activeIndexChange");
            swiper.emit("snapIndexChange");
            if (previousRealIndex !== realIndex) swiper.emit("realIndexChange");
            if (swiper.initialized || swiper.params.runCallbacksOnInit) swiper.emit("slideChange");
        }
        function updateClickedSlide(e) {
            const swiper = this;
            const params = swiper.params;
            const slide = dom(e).closest(`.${params.slideClass}`)[0];
            let slideFound = false;
            let slideIndex;
            if (slide) for (let i = 0; i < swiper.slides.length; i += 1) if (swiper.slides[i] === slide) {
                slideFound = true;
                slideIndex = i;
                break;
            }
            if (slide && slideFound) {
                swiper.clickedSlide = slide;
                if (swiper.virtual && swiper.params.virtual.enabled) swiper.clickedIndex = parseInt(dom(slide).attr("data-swiper-slide-index"), 10); else swiper.clickedIndex = slideIndex;
            } else {
                swiper.clickedSlide = void 0;
                swiper.clickedIndex = void 0;
                return;
            }
            if (params.slideToClickedSlide && void 0 !== swiper.clickedIndex && swiper.clickedIndex !== swiper.activeIndex) swiper.slideToClickedSlide();
        }
        const update = {
            updateSize,
            updateSlides,
            updateAutoHeight,
            updateSlidesOffset,
            updateSlidesProgress,
            updateProgress,
            updateSlidesClasses,
            updateActiveIndex,
            updateClickedSlide
        };
        function getSwiperTranslate(axis = (this.isHorizontal() ? "x" : "y")) {
            const swiper = this;
            const {params, rtlTranslate: rtl, translate, $wrapperEl} = swiper;
            if (params.virtualTranslate) return rtl ? -translate : translate;
            if (params.cssMode) return translate;
            let currentTranslate = utils_getTranslate($wrapperEl[0], axis);
            if (rtl) currentTranslate = -currentTranslate;
            return currentTranslate || 0;
        }
        function setTranslate(translate, byController) {
            const swiper = this;
            const {rtlTranslate: rtl, params, $wrapperEl, wrapperEl, progress} = swiper;
            let x = 0;
            let y = 0;
            const z = 0;
            if (swiper.isHorizontal()) x = rtl ? -translate : translate; else y = translate;
            if (params.roundLengths) {
                x = Math.floor(x);
                y = Math.floor(y);
            }
            if (params.cssMode) wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y; else if (!params.virtualTranslate) $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
            swiper.previousTranslate = swiper.translate;
            swiper.translate = swiper.isHorizontal() ? x : y;
            let newProgress;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            if (0 === translatesDiff) newProgress = 0; else newProgress = (translate - swiper.minTranslate()) / translatesDiff;
            if (newProgress !== progress) swiper.updateProgress(translate);
            swiper.emit("setTranslate", swiper.translate, byController);
        }
        function minTranslate() {
            return -this.snapGrid[0];
        }
        function maxTranslate() {
            return -this.snapGrid[this.snapGrid.length - 1];
        }
        function translateTo(translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
            const swiper = this;
            const {params, wrapperEl} = swiper;
            if (swiper.animating && params.preventInteractionOnTransition) return false;
            const minTranslate = swiper.minTranslate();
            const maxTranslate = swiper.maxTranslate();
            let newTranslate;
            if (translateBounds && translate > minTranslate) newTranslate = minTranslate; else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate; else newTranslate = translate;
            swiper.updateProgress(newTranslate);
            if (params.cssMode) {
                const isH = swiper.isHorizontal();
                if (0 === speed) wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate; else {
                    if (!swiper.support.smoothScroll) {
                        animateCSSModeScroll({
                            swiper,
                            targetPosition: -newTranslate,
                            side: isH ? "left" : "top"
                        });
                        return true;
                    }
                    wrapperEl.scrollTo({
                        [isH ? "left" : "top"]: -newTranslate,
                        behavior: "smooth"
                    });
                }
                return true;
            }
            if (0 === speed) {
                swiper.setTransition(0);
                swiper.setTranslate(newTranslate);
                if (runCallbacks) {
                    swiper.emit("beforeTransitionStart", speed, internal);
                    swiper.emit("transitionEnd");
                }
            } else {
                swiper.setTransition(speed);
                swiper.setTranslate(newTranslate);
                if (runCallbacks) {
                    swiper.emit("beforeTransitionStart", speed, internal);
                    swiper.emit("transitionStart");
                }
                if (!swiper.animating) {
                    swiper.animating = true;
                    if (!swiper.onTranslateToWrapperTransitionEnd) swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
                        if (!swiper || swiper.destroyed) return;
                        if (e.target !== this) return;
                        swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                        swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
                        swiper.onTranslateToWrapperTransitionEnd = null;
                        delete swiper.onTranslateToWrapperTransitionEnd;
                        if (runCallbacks) swiper.emit("transitionEnd");
                    };
                    swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                    swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
                }
            }
            return true;
        }
        const translate = {
            getTranslate: getSwiperTranslate,
            setTranslate,
            minTranslate,
            maxTranslate,
            translateTo
        };
        function setTransition(duration, byController) {
            const swiper = this;
            if (!swiper.params.cssMode) swiper.$wrapperEl.transition(duration);
            swiper.emit("setTransition", duration, byController);
        }
        function transitionEmit({swiper, runCallbacks, direction, step}) {
            const {activeIndex, previousIndex} = swiper;
            let dir = direction;
            if (!dir) if (activeIndex > previousIndex) dir = "next"; else if (activeIndex < previousIndex) dir = "prev"; else dir = "reset";
            swiper.emit(`transition${step}`);
            if (runCallbacks && activeIndex !== previousIndex) {
                if ("reset" === dir) {
                    swiper.emit(`slideResetTransition${step}`);
                    return;
                }
                swiper.emit(`slideChangeTransition${step}`);
                if ("next" === dir) swiper.emit(`slideNextTransition${step}`); else swiper.emit(`slidePrevTransition${step}`);
            }
        }
        function transitionStart(runCallbacks = true, direction) {
            const swiper = this;
            const {params} = swiper;
            if (params.cssMode) return;
            if (params.autoHeight) swiper.updateAutoHeight();
            transitionEmit({
                swiper,
                runCallbacks,
                direction,
                step: "Start"
            });
        }
        function transitionEnd_transitionEnd(runCallbacks = true, direction) {
            const swiper = this;
            const {params} = swiper;
            swiper.animating = false;
            if (params.cssMode) return;
            swiper.setTransition(0);
            transitionEmit({
                swiper,
                runCallbacks,
                direction,
                step: "End"
            });
        }
        const core_transition = {
            setTransition,
            transitionStart,
            transitionEnd: transitionEnd_transitionEnd
        };
        function slideTo(index = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {
            if ("number" !== typeof index && "string" !== typeof index) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof index}] given.`);
            if ("string" === typeof index) {
                const indexAsNumber = parseInt(index, 10);
                const isValidNumber = isFinite(indexAsNumber);
                if (!isValidNumber) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
                index = indexAsNumber;
            }
            const swiper = this;
            let slideIndex = index;
            if (slideIndex < 0) slideIndex = 0;
            const {params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl, enabled} = swiper;
            if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) return false;
            const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
            let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
            if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
            const translate = -snapGrid[snapIndex];
            if (params.normalizeSlideIndex) for (let i = 0; i < slidesGrid.length; i += 1) {
                const normalizedTranslate = -Math.floor(100 * translate);
                const normalizedGrid = Math.floor(100 * slidesGrid[i]);
                const normalizedGridNext = Math.floor(100 * slidesGrid[i + 1]);
                if ("undefined" !== typeof slidesGrid[i + 1]) {
                    if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) slideIndex = i; else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) slideIndex = i + 1;
                } else if (normalizedTranslate >= normalizedGrid) slideIndex = i;
            }
            if (swiper.initialized && slideIndex !== activeIndex) {
                if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) return false;
                if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) if ((activeIndex || 0) !== slideIndex) return false;
            }
            if (slideIndex !== (previousIndex || 0) && runCallbacks) swiper.emit("beforeSlideChangeStart");
            swiper.updateProgress(translate);
            let direction;
            if (slideIndex > activeIndex) direction = "next"; else if (slideIndex < activeIndex) direction = "prev"; else direction = "reset";
            if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
                swiper.updateActiveIndex(slideIndex);
                if (params.autoHeight) swiper.updateAutoHeight();
                swiper.updateSlidesClasses();
                if ("slide" !== params.effect) swiper.setTranslate(translate);
                if ("reset" !== direction) {
                    swiper.transitionStart(runCallbacks, direction);
                    swiper.transitionEnd(runCallbacks, direction);
                }
                return false;
            }
            if (params.cssMode) {
                const isH = swiper.isHorizontal();
                const t = rtl ? translate : -translate;
                if (0 === speed) {
                    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
                    if (isVirtual) {
                        swiper.wrapperEl.style.scrollSnapType = "none";
                        swiper._immediateVirtual = true;
                    }
                    wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
                    if (isVirtual) requestAnimationFrame((() => {
                        swiper.wrapperEl.style.scrollSnapType = "";
                        swiper._swiperImmediateVirtual = false;
                    }));
                } else {
                    if (!swiper.support.smoothScroll) {
                        animateCSSModeScroll({
                            swiper,
                            targetPosition: t,
                            side: isH ? "left" : "top"
                        });
                        return true;
                    }
                    wrapperEl.scrollTo({
                        [isH ? "left" : "top"]: t,
                        behavior: "smooth"
                    });
                }
                return true;
            }
            swiper.setTransition(speed);
            swiper.setTranslate(translate);
            swiper.updateActiveIndex(slideIndex);
            swiper.updateSlidesClasses();
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.transitionStart(runCallbacks, direction);
            if (0 === speed) swiper.transitionEnd(runCallbacks, direction); else if (!swiper.animating) {
                swiper.animating = true;
                if (!swiper.onSlideToWrapperTransitionEnd) swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                    if (!swiper || swiper.destroyed) return;
                    if (e.target !== this) return;
                    swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
                    swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
                    swiper.onSlideToWrapperTransitionEnd = null;
                    delete swiper.onSlideToWrapperTransitionEnd;
                    swiper.transitionEnd(runCallbacks, direction);
                };
                swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
                swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
            }
            return true;
        }
        function slideToLoop(index = 0, speed = this.params.speed, runCallbacks = true, internal) {
            if ("string" === typeof index) {
                const indexAsNumber = parseInt(index, 10);
                const isValidNumber = isFinite(indexAsNumber);
                if (!isValidNumber) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${index}] given.`);
                index = indexAsNumber;
            }
            const swiper = this;
            let newIndex = index;
            if (swiper.params.loop) newIndex += swiper.loopedSlides;
            return swiper.slideTo(newIndex, speed, runCallbacks, internal);
        }
        function slideNext(speed = this.params.speed, runCallbacks = true, internal) {
            const swiper = this;
            const {animating, enabled, params} = swiper;
            if (!enabled) return swiper;
            let perGroup = params.slidesPerGroup;
            if ("auto" === params.slidesPerView && 1 === params.slidesPerGroup && params.slidesPerGroupAuto) perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
            const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
            if (params.loop) {
                if (animating && params.loopPreventsSlide) return false;
                swiper.loopFix();
                swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
            }
            if (params.rewind && swiper.isEnd) return swiper.slideTo(0, speed, runCallbacks, internal);
            return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
        }
        function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
            const swiper = this;
            const {params, animating, snapGrid, slidesGrid, rtlTranslate, enabled} = swiper;
            if (!enabled) return swiper;
            if (params.loop) {
                if (animating && params.loopPreventsSlide) return false;
                swiper.loopFix();
                swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
            }
            const translate = rtlTranslate ? swiper.translate : -swiper.translate;
            function normalize(val) {
                if (val < 0) return -Math.floor(Math.abs(val));
                return Math.floor(val);
            }
            const normalizedTranslate = normalize(translate);
            const normalizedSnapGrid = snapGrid.map((val => normalize(val)));
            let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
            if ("undefined" === typeof prevSnap && params.cssMode) {
                let prevSnapIndex;
                snapGrid.forEach(((snap, snapIndex) => {
                    if (normalizedTranslate >= snap) prevSnapIndex = snapIndex;
                }));
                if ("undefined" !== typeof prevSnapIndex) prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
            }
            let prevIndex = 0;
            if ("undefined" !== typeof prevSnap) {
                prevIndex = slidesGrid.indexOf(prevSnap);
                if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
                if ("auto" === params.slidesPerView && 1 === params.slidesPerGroup && params.slidesPerGroupAuto) {
                    prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
                    prevIndex = Math.max(prevIndex, 0);
                }
            }
            if (params.rewind && swiper.isBeginning) {
                const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
                return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
            }
            return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
        }
        function slideReset(speed = this.params.speed, runCallbacks = true, internal) {
            const swiper = this;
            return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
        }
        function slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = .5) {
            const swiper = this;
            let index = swiper.activeIndex;
            const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
            const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            if (translate >= swiper.snapGrid[snapIndex]) {
                const currentSnap = swiper.snapGrid[snapIndex];
                const nextSnap = swiper.snapGrid[snapIndex + 1];
                if (translate - currentSnap > (nextSnap - currentSnap) * threshold) index += swiper.params.slidesPerGroup;
            } else {
                const prevSnap = swiper.snapGrid[snapIndex - 1];
                const currentSnap = swiper.snapGrid[snapIndex];
                if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) index -= swiper.params.slidesPerGroup;
            }
            index = Math.max(index, 0);
            index = Math.min(index, swiper.slidesGrid.length - 1);
            return swiper.slideTo(index, speed, runCallbacks, internal);
        }
        function slideToClickedSlide() {
            const swiper = this;
            const {params, $wrapperEl} = swiper;
            const slidesPerView = "auto" === params.slidesPerView ? swiper.slidesPerViewDynamic() : params.slidesPerView;
            let slideToIndex = swiper.clickedIndex;
            let realIndex;
            if (params.loop) {
                if (swiper.animating) return;
                realIndex = parseInt(dom(swiper.clickedSlide).attr("data-swiper-slide-index"), 10);
                if (params.centeredSlides) if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
                    swiper.loopFix();
                    slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
                    utils_nextTick((() => {
                        swiper.slideTo(slideToIndex);
                    }));
                } else swiper.slideTo(slideToIndex); else if (slideToIndex > swiper.slides.length - slidesPerView) {
                    swiper.loopFix();
                    slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();
                    utils_nextTick((() => {
                        swiper.slideTo(slideToIndex);
                    }));
                } else swiper.slideTo(slideToIndex);
            } else swiper.slideTo(slideToIndex);
        }
        const slide = {
            slideTo,
            slideToLoop,
            slideNext,
            slidePrev,
            slideReset,
            slideToClosest,
            slideToClickedSlide
        };
        function loopCreate() {
            const swiper = this;
            const document = ssr_window_esm_getDocument();
            const {params, $wrapperEl} = swiper;
            const $selector = $wrapperEl.children().length > 0 ? dom($wrapperEl.children()[0].parentNode) : $wrapperEl;
            $selector.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();
            let slides = $selector.children(`.${params.slideClass}`);
            if (params.loopFillGroupWithBlank) {
                const blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
                if (blankSlidesNum !== params.slidesPerGroup) {
                    for (let i = 0; i < blankSlidesNum; i += 1) {
                        const blankNode = dom(document.createElement("div")).addClass(`${params.slideClass} ${params.slideBlankClass}`);
                        $selector.append(blankNode);
                    }
                    slides = $selector.children(`.${params.slideClass}`);
                }
            }
            if ("auto" === params.slidesPerView && !params.loopedSlides) params.loopedSlides = slides.length;
            swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
            swiper.loopedSlides += params.loopAdditionalSlides;
            if (swiper.loopedSlides > slides.length && swiper.params.loopedSlidesLimit) swiper.loopedSlides = slides.length;
            const prependSlides = [];
            const appendSlides = [];
            slides.each(((el, index) => {
                const slide = dom(el);
                slide.attr("data-swiper-slide-index", index);
            }));
            for (let i = 0; i < swiper.loopedSlides; i += 1) {
                const index = i - Math.floor(i / slides.length) * slides.length;
                appendSlides.push(slides.eq(index)[0]);
                prependSlides.unshift(slides.eq(slides.length - index - 1)[0]);
            }
            for (let i = 0; i < appendSlides.length; i += 1) $selector.append(dom(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
            for (let i = prependSlides.length - 1; i >= 0; i -= 1) $selector.prepend(dom(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
        }
        function loopFix() {
            const swiper = this;
            swiper.emit("beforeLoopFix");
            const {activeIndex, slides, loopedSlides, allowSlidePrev, allowSlideNext, snapGrid, rtlTranslate: rtl} = swiper;
            let newIndex;
            swiper.allowSlidePrev = true;
            swiper.allowSlideNext = true;
            const snapTranslate = -snapGrid[activeIndex];
            const diff = snapTranslate - swiper.getTranslate();
            if (activeIndex < loopedSlides) {
                newIndex = slides.length - 3 * loopedSlides + activeIndex;
                newIndex += loopedSlides;
                const slideChanged = swiper.slideTo(newIndex, 0, false, true);
                if (slideChanged && 0 !== diff) swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
            } else if (activeIndex >= slides.length - loopedSlides) {
                newIndex = -slides.length + activeIndex + loopedSlides;
                newIndex += loopedSlides;
                const slideChanged = swiper.slideTo(newIndex, 0, false, true);
                if (slideChanged && 0 !== diff) swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
            }
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;
            swiper.emit("loopFix");
        }
        function loopDestroy() {
            const swiper = this;
            const {$wrapperEl, params, slides} = swiper;
            $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
            slides.removeAttr("data-swiper-slide-index");
        }
        const loop = {
            loopCreate,
            loopFix,
            loopDestroy
        };
        function setGrabCursor(moving) {
            const swiper = this;
            if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
            const el = "container" === swiper.params.touchEventsTarget ? swiper.el : swiper.wrapperEl;
            el.style.cursor = "move";
            el.style.cursor = moving ? "grabbing" : "grab";
        }
        function unsetGrabCursor() {
            const swiper = this;
            if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
            swiper["container" === swiper.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "";
        }
        const grab_cursor = {
            setGrabCursor,
            unsetGrabCursor
        };
        function closestElement(selector, base = this) {
            function __closestFrom(el) {
                if (!el || el === ssr_window_esm_getDocument() || el === ssr_window_esm_getWindow()) return null;
                if (el.assignedSlot) el = el.assignedSlot;
                const found = el.closest(selector);
                if (!found && !el.getRootNode) return null;
                return found || __closestFrom(el.getRootNode().host);
            }
            return __closestFrom(base);
        }
        function onTouchStart(event) {
            const swiper = this;
            const document = ssr_window_esm_getDocument();
            const window = ssr_window_esm_getWindow();
            const data = swiper.touchEventsData;
            const {params, touches, enabled} = swiper;
            if (!enabled) return;
            if (swiper.animating && params.preventInteractionOnTransition) return;
            if (!swiper.animating && params.cssMode && params.loop) swiper.loopFix();
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            let $targetEl = dom(e.target);
            if ("wrapper" === params.touchEventsTarget) if (!$targetEl.closest(swiper.wrapperEl).length) return;
            data.isTouchEvent = "touchstart" === e.type;
            if (!data.isTouchEvent && "which" in e && 3 === e.which) return;
            if (!data.isTouchEvent && "button" in e && e.button > 0) return;
            if (data.isTouched && data.isMoved) return;
            const swipingClassHasValue = !!params.noSwipingClass && "" !== params.noSwipingClass;
            const eventPath = event.composedPath ? event.composedPath() : event.path;
            if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) $targetEl = dom(eventPath[0]);
            const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
            const isTargetShadow = !!(e.target && e.target.shadowRoot);
            if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, $targetEl[0]) : $targetEl.closest(noSwipingSelector)[0])) {
                swiper.allowClick = true;
                return;
            }
            if (params.swipeHandler) if (!$targetEl.closest(params.swipeHandler)[0]) return;
            touches.currentX = "touchstart" === e.type ? e.targetTouches[0].pageX : e.pageX;
            touches.currentY = "touchstart" === e.type ? e.targetTouches[0].pageY : e.pageY;
            const startX = touches.currentX;
            const startY = touches.currentY;
            const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
            const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
            if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) if ("prevent" === edgeSwipeDetection) event.preventDefault(); else return;
            Object.assign(data, {
                isTouched: true,
                isMoved: false,
                allowTouchCallbacks: true,
                isScrolling: void 0,
                startMoving: void 0
            });
            touches.startX = startX;
            touches.startY = startY;
            data.touchStartTime = utils_now();
            swiper.allowClick = true;
            swiper.updateSize();
            swiper.swipeDirection = void 0;
            if (params.threshold > 0) data.allowThresholdMove = false;
            if ("touchstart" !== e.type) {
                let preventDefault = true;
                if ($targetEl.is(data.focusableElements)) {
                    preventDefault = false;
                    if ("SELECT" === $targetEl[0].nodeName) data.isTouched = false;
                }
                if (document.activeElement && dom(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) document.activeElement.blur();
                const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
                if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) e.preventDefault();
            }
            if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) swiper.freeMode.onTouchStart();
            swiper.emit("touchStart", e);
        }
        function onTouchMove(event) {
            const document = ssr_window_esm_getDocument();
            const swiper = this;
            const data = swiper.touchEventsData;
            const {params, touches, rtlTranslate: rtl, enabled} = swiper;
            if (!enabled) return;
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            if (!data.isTouched) {
                if (data.startMoving && data.isScrolling) swiper.emit("touchMoveOpposite", e);
                return;
            }
            if (data.isTouchEvent && "touchmove" !== e.type) return;
            const targetTouch = "touchmove" === e.type && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
            const pageX = "touchmove" === e.type ? targetTouch.pageX : e.pageX;
            const pageY = "touchmove" === e.type ? targetTouch.pageY : e.pageY;
            if (e.preventedByNestedSwiper) {
                touches.startX = pageX;
                touches.startY = pageY;
                return;
            }
            if (!swiper.allowTouchMove) {
                if (!dom(e.target).is(data.focusableElements)) swiper.allowClick = false;
                if (data.isTouched) {
                    Object.assign(touches, {
                        startX: pageX,
                        startY: pageY,
                        currentX: pageX,
                        currentY: pageY
                    });
                    data.touchStartTime = utils_now();
                }
                return;
            }
            if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) if (swiper.isVertical()) {
                if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
                    data.isTouched = false;
                    data.isMoved = false;
                    return;
                }
            } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) return;
            if (data.isTouchEvent && document.activeElement) if (e.target === document.activeElement && dom(e.target).is(data.focusableElements)) {
                data.isMoved = true;
                swiper.allowClick = false;
                return;
            }
            if (data.allowTouchCallbacks) swiper.emit("touchMove", e);
            if (e.targetTouches && e.targetTouches.length > 1) return;
            touches.currentX = pageX;
            touches.currentY = pageY;
            const diffX = touches.currentX - touches.startX;
            const diffY = touches.currentY - touches.startY;
            if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
            if ("undefined" === typeof data.isScrolling) {
                let touchAngle;
                if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) data.isScrolling = false; else if (diffX * diffX + diffY * diffY >= 25) {
                    touchAngle = 180 * Math.atan2(Math.abs(diffY), Math.abs(diffX)) / Math.PI;
                    data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
                }
            }
            if (data.isScrolling) swiper.emit("touchMoveOpposite", e);
            if ("undefined" === typeof data.startMoving) if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) data.startMoving = true;
            if (data.isScrolling) {
                data.isTouched = false;
                return;
            }
            if (!data.startMoving) return;
            swiper.allowClick = false;
            if (!params.cssMode && e.cancelable) e.preventDefault();
            if (params.touchMoveStopPropagation && !params.nested) e.stopPropagation();
            if (!data.isMoved) {
                if (params.loop && !params.cssMode) swiper.loopFix();
                data.startTranslate = swiper.getTranslate();
                swiper.setTransition(0);
                if (swiper.animating) swiper.$wrapperEl.trigger("webkitTransitionEnd transitionend");
                data.allowMomentumBounce = false;
                if (params.grabCursor && (true === swiper.allowSlideNext || true === swiper.allowSlidePrev)) swiper.setGrabCursor(true);
                swiper.emit("sliderFirstMove", e);
            }
            swiper.emit("sliderMove", e);
            data.isMoved = true;
            let diff = swiper.isHorizontal() ? diffX : diffY;
            touches.diff = diff;
            diff *= params.touchRatio;
            if (rtl) diff = -diff;
            swiper.swipeDirection = diff > 0 ? "prev" : "next";
            data.currentTranslate = diff + data.startTranslate;
            let disableParentSwiper = true;
            let resistanceRatio = params.resistanceRatio;
            if (params.touchReleaseOnEdges) resistanceRatio = 0;
            if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
                disableParentSwiper = false;
                if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
            } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
                disableParentSwiper = false;
                if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
            }
            if (disableParentSwiper) e.preventedByNestedSwiper = true;
            if (!swiper.allowSlideNext && "next" === swiper.swipeDirection && data.currentTranslate < data.startTranslate) data.currentTranslate = data.startTranslate;
            if (!swiper.allowSlidePrev && "prev" === swiper.swipeDirection && data.currentTranslate > data.startTranslate) data.currentTranslate = data.startTranslate;
            if (!swiper.allowSlidePrev && !swiper.allowSlideNext) data.currentTranslate = data.startTranslate;
            if (params.threshold > 0) if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
                if (!data.allowThresholdMove) {
                    data.allowThresholdMove = true;
                    touches.startX = touches.currentX;
                    touches.startY = touches.currentY;
                    data.currentTranslate = data.startTranslate;
                    touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                    return;
                }
            } else {
                data.currentTranslate = data.startTranslate;
                return;
            }
            if (!params.followFinger || params.cssMode) return;
            if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) swiper.freeMode.onTouchMove();
            swiper.updateProgress(data.currentTranslate);
            swiper.setTranslate(data.currentTranslate);
        }
        function onTouchEnd(event) {
            const swiper = this;
            const data = swiper.touchEventsData;
            const {params, touches, rtlTranslate: rtl, slidesGrid, enabled} = swiper;
            if (!enabled) return;
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            if (data.allowTouchCallbacks) swiper.emit("touchEnd", e);
            data.allowTouchCallbacks = false;
            if (!data.isTouched) {
                if (data.isMoved && params.grabCursor) swiper.setGrabCursor(false);
                data.isMoved = false;
                data.startMoving = false;
                return;
            }
            if (params.grabCursor && data.isMoved && data.isTouched && (true === swiper.allowSlideNext || true === swiper.allowSlidePrev)) swiper.setGrabCursor(false);
            const touchEndTime = utils_now();
            const timeDiff = touchEndTime - data.touchStartTime;
            if (swiper.allowClick) {
                const pathTree = e.path || e.composedPath && e.composedPath();
                swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
                swiper.emit("tap click", e);
                if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) swiper.emit("doubleTap doubleClick", e);
            }
            data.lastClickTime = utils_now();
            utils_nextTick((() => {
                if (!swiper.destroyed) swiper.allowClick = true;
            }));
            if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || 0 === touches.diff || data.currentTranslate === data.startTranslate) {
                data.isTouched = false;
                data.isMoved = false;
                data.startMoving = false;
                return;
            }
            data.isTouched = false;
            data.isMoved = false;
            data.startMoving = false;
            let currentPos;
            if (params.followFinger) currentPos = rtl ? swiper.translate : -swiper.translate; else currentPos = -data.currentTranslate;
            if (params.cssMode) return;
            if (swiper.params.freeMode && params.freeMode.enabled) {
                swiper.freeMode.onTouchEnd({
                    currentPos
                });
                return;
            }
            let stopIndex = 0;
            let groupSize = swiper.slidesSizesGrid[0];
            for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
                const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
                if ("undefined" !== typeof slidesGrid[i + increment]) {
                    if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
                        stopIndex = i;
                        groupSize = slidesGrid[i + increment] - slidesGrid[i];
                    }
                } else if (currentPos >= slidesGrid[i]) {
                    stopIndex = i;
                    groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
                }
            }
            let rewindFirstIndex = null;
            let rewindLastIndex = null;
            if (params.rewind) if (swiper.isBeginning) rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1; else if (swiper.isEnd) rewindFirstIndex = 0;
            const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
            const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
            if (timeDiff > params.longSwipesMs) {
                if (!params.longSwipes) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                if ("next" === swiper.swipeDirection) if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment); else swiper.slideTo(stopIndex);
                if ("prev" === swiper.swipeDirection) if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment); else if (null !== rewindLastIndex && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) swiper.slideTo(rewindLastIndex); else swiper.slideTo(stopIndex);
            } else {
                if (!params.shortSwipes) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
                if (!isNavButtonTarget) {
                    if ("next" === swiper.swipeDirection) swiper.slideTo(null !== rewindFirstIndex ? rewindFirstIndex : stopIndex + increment);
                    if ("prev" === swiper.swipeDirection) swiper.slideTo(null !== rewindLastIndex ? rewindLastIndex : stopIndex);
                } else if (e.target === swiper.navigation.nextEl) swiper.slideTo(stopIndex + increment); else swiper.slideTo(stopIndex);
            }
        }
        function onResize() {
            const swiper = this;
            const {params, el} = swiper;
            if (el && 0 === el.offsetWidth) return;
            if (params.breakpoints) swiper.setBreakpoint();
            const {allowSlideNext, allowSlidePrev, snapGrid} = swiper;
            swiper.allowSlideNext = true;
            swiper.allowSlidePrev = true;
            swiper.updateSize();
            swiper.updateSlides();
            swiper.updateSlidesClasses();
            if (("auto" === params.slidesPerView || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) swiper.slideTo(swiper.slides.length - 1, 0, false, true); else swiper.slideTo(swiper.activeIndex, 0, false, true);
            if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) swiper.autoplay.run();
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;
            if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
        }
        function onClick(e) {
            const swiper = this;
            if (!swiper.enabled) return;
            if (!swiper.allowClick) {
                if (swiper.params.preventClicks) e.preventDefault();
                if (swiper.params.preventClicksPropagation && swiper.animating) {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
            }
        }
        function onScroll() {
            const swiper = this;
            const {wrapperEl, rtlTranslate, enabled} = swiper;
            if (!enabled) return;
            swiper.previousTranslate = swiper.translate;
            if (swiper.isHorizontal()) swiper.translate = -wrapperEl.scrollLeft; else swiper.translate = -wrapperEl.scrollTop;
            if (0 === swiper.translate) swiper.translate = 0;
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
            let newProgress;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            if (0 === translatesDiff) newProgress = 0; else newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
            if (newProgress !== swiper.progress) swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
            swiper.emit("setTranslate", swiper.translate, false);
        }
        let dummyEventAttached = false;
        function dummyEventListener() {}
        const events = (swiper, method) => {
            const document = ssr_window_esm_getDocument();
            const {params, touchEvents, el, wrapperEl, device, support} = swiper;
            const capture = !!params.nested;
            const domMethod = "on" === method ? "addEventListener" : "removeEventListener";
            const swiperMethod = method;
            if (!support.touch) {
                el[domMethod](touchEvents.start, swiper.onTouchStart, false);
                document[domMethod](touchEvents.move, swiper.onTouchMove, capture);
                document[domMethod](touchEvents.end, swiper.onTouchEnd, false);
            } else {
                const passiveListener = "touchstart" === touchEvents.start && support.passiveListener && params.passiveListeners ? {
                    passive: true,
                    capture: false
                } : false;
                el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);
                el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
                    passive: false,
                    capture
                } : capture);
                el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);
                if (touchEvents.cancel) el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);
            }
            if (params.preventClicks || params.preventClicksPropagation) el[domMethod]("click", swiper.onClick, true);
            if (params.cssMode) wrapperEl[domMethod]("scroll", swiper.onScroll);
            if (params.updateOnWindowResize) swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true); else swiper[swiperMethod]("observerUpdate", onResize, true);
        };
        function attachEvents() {
            const swiper = this;
            const document = ssr_window_esm_getDocument();
            const {params, support} = swiper;
            swiper.onTouchStart = onTouchStart.bind(swiper);
            swiper.onTouchMove = onTouchMove.bind(swiper);
            swiper.onTouchEnd = onTouchEnd.bind(swiper);
            if (params.cssMode) swiper.onScroll = onScroll.bind(swiper);
            swiper.onClick = onClick.bind(swiper);
            if (support.touch && !dummyEventAttached) {
                document.addEventListener("touchstart", dummyEventListener);
                dummyEventAttached = true;
            }
            events(swiper, "on");
        }
        function detachEvents() {
            const swiper = this;
            events(swiper, "off");
        }
        const core_events = {
            attachEvents,
            detachEvents
        };
        const isGridEnabled = (swiper, params) => swiper.grid && params.grid && params.grid.rows > 1;
        function setBreakpoint() {
            const swiper = this;
            const {activeIndex, initialized, loopedSlides = 0, params, $el} = swiper;
            const breakpoints = params.breakpoints;
            if (!breakpoints || breakpoints && 0 === Object.keys(breakpoints).length) return;
            const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
            if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
            const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : void 0;
            const breakpointParams = breakpointOnlyParams || swiper.originalParams;
            const wasMultiRow = isGridEnabled(swiper, params);
            const isMultiRow = isGridEnabled(swiper, breakpointParams);
            const wasEnabled = params.enabled;
            if (wasMultiRow && !isMultiRow) {
                $el.removeClass(`${params.containerModifierClass}grid ${params.containerModifierClass}grid-column`);
                swiper.emitContainerClasses();
            } else if (!wasMultiRow && isMultiRow) {
                $el.addClass(`${params.containerModifierClass}grid`);
                if (breakpointParams.grid.fill && "column" === breakpointParams.grid.fill || !breakpointParams.grid.fill && "column" === params.grid.fill) $el.addClass(`${params.containerModifierClass}grid-column`);
                swiper.emitContainerClasses();
            }
            [ "navigation", "pagination", "scrollbar" ].forEach((prop => {
                const wasModuleEnabled = params[prop] && params[prop].enabled;
                const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
                if (wasModuleEnabled && !isModuleEnabled) swiper[prop].disable();
                if (!wasModuleEnabled && isModuleEnabled) swiper[prop].enable();
            }));
            const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
            const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
            if (directionChanged && initialized) swiper.changeDirection();
            utils_extend(swiper.params, breakpointParams);
            const isEnabled = swiper.params.enabled;
            Object.assign(swiper, {
                allowTouchMove: swiper.params.allowTouchMove,
                allowSlideNext: swiper.params.allowSlideNext,
                allowSlidePrev: swiper.params.allowSlidePrev
            });
            if (wasEnabled && !isEnabled) swiper.disable(); else if (!wasEnabled && isEnabled) swiper.enable();
            swiper.currentBreakpoint = breakpoint;
            swiper.emit("_beforeBreakpoint", breakpointParams);
            if (needsReLoop && initialized) {
                swiper.loopDestroy();
                swiper.loopCreate();
                swiper.updateSlides();
                swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
            }
            swiper.emit("breakpoint", breakpointParams);
        }
        function getBreakpoint(breakpoints, base = "window", containerEl) {
            if (!breakpoints || "container" === base && !containerEl) return;
            let breakpoint = false;
            const window = ssr_window_esm_getWindow();
            const currentHeight = "window" === base ? window.innerHeight : containerEl.clientHeight;
            const points = Object.keys(breakpoints).map((point => {
                if ("string" === typeof point && 0 === point.indexOf("@")) {
                    const minRatio = parseFloat(point.substr(1));
                    const value = currentHeight * minRatio;
                    return {
                        value,
                        point
                    };
                }
                return {
                    value: point,
                    point
                };
            }));
            points.sort(((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10)));
            for (let i = 0; i < points.length; i += 1) {
                const {point, value} = points[i];
                if ("window" === base) {
                    if (window.matchMedia(`(min-width: ${value}px)`).matches) breakpoint = point;
                } else if (value <= containerEl.clientWidth) breakpoint = point;
            }
            return breakpoint || "max";
        }
        const breakpoints = {
            setBreakpoint,
            getBreakpoint
        };
        function prepareClasses(entries, prefix) {
            const resultClasses = [];
            entries.forEach((item => {
                if ("object" === typeof item) Object.keys(item).forEach((classNames => {
                    if (item[classNames]) resultClasses.push(prefix + classNames);
                })); else if ("string" === typeof item) resultClasses.push(prefix + item);
            }));
            return resultClasses;
        }
        function addClasses() {
            const swiper = this;
            const {classNames, params, rtl, $el, device, support} = swiper;
            const suffixes = prepareClasses([ "initialized", params.direction, {
                "pointer-events": !support.touch
            }, {
                "free-mode": swiper.params.freeMode && params.freeMode.enabled
            }, {
                autoheight: params.autoHeight
            }, {
                rtl
            }, {
                grid: params.grid && params.grid.rows > 1
            }, {
                "grid-column": params.grid && params.grid.rows > 1 && "column" === params.grid.fill
            }, {
                android: device.android
            }, {
                ios: device.ios
            }, {
                "css-mode": params.cssMode
            }, {
                centered: params.cssMode && params.centeredSlides
            }, {
                "watch-progress": params.watchSlidesProgress
            } ], params.containerModifierClass);
            classNames.push(...suffixes);
            $el.addClass([ ...classNames ].join(" "));
            swiper.emitContainerClasses();
        }
        function removeClasses_removeClasses() {
            const swiper = this;
            const {$el, classNames} = swiper;
            $el.removeClass(classNames.join(" "));
            swiper.emitContainerClasses();
        }
        const classes = {
            addClasses,
            removeClasses: removeClasses_removeClasses
        };
        function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
            const window = ssr_window_esm_getWindow();
            let image;
            function onReady() {
                if (callback) callback();
            }
            const isPicture = dom(imageEl).parent("picture")[0];
            if (!isPicture && (!imageEl.complete || !checkForComplete)) if (src) {
                image = new window.Image;
                image.onload = onReady;
                image.onerror = onReady;
                if (sizes) image.sizes = sizes;
                if (srcset) image.srcset = srcset;
                if (src) image.src = src;
            } else onReady(); else onReady();
        }
        function preloadImages() {
            const swiper = this;
            swiper.imagesToLoad = swiper.$el.find("img");
            function onReady() {
                if ("undefined" === typeof swiper || null === swiper || !swiper || swiper.destroyed) return;
                if (void 0 !== swiper.imagesLoaded) swiper.imagesLoaded += 1;
                if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
                    if (swiper.params.updateOnImagesReady) swiper.update();
                    swiper.emit("imagesReady");
                }
            }
            for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
                const imageEl = swiper.imagesToLoad[i];
                swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute("src"), imageEl.srcset || imageEl.getAttribute("srcset"), imageEl.sizes || imageEl.getAttribute("sizes"), true, onReady);
            }
        }
        const core_images = {
            loadImage,
            preloadImages
        };
        function checkOverflow() {
            const swiper = this;
            const {isLocked: wasLocked, params} = swiper;
            const {slidesOffsetBefore} = params;
            if (slidesOffsetBefore) {
                const lastSlideIndex = swiper.slides.length - 1;
                const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + 2 * slidesOffsetBefore;
                swiper.isLocked = swiper.size > lastSlideRightEdge;
            } else swiper.isLocked = 1 === swiper.snapGrid.length;
            if (true === params.allowSlideNext) swiper.allowSlideNext = !swiper.isLocked;
            if (true === params.allowSlidePrev) swiper.allowSlidePrev = !swiper.isLocked;
            if (wasLocked && wasLocked !== swiper.isLocked) swiper.isEnd = false;
            if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? "lock" : "unlock");
        }
        const check_overflow = {
            checkOverflow
        };
        const defaults = {
            init: true,
            direction: "horizontal",
            touchEventsTarget: "wrapper",
            initialSlide: 0,
            speed: 300,
            cssMode: false,
            updateOnWindowResize: true,
            resizeObserver: true,
            nested: false,
            createElements: false,
            enabled: true,
            focusableElements: "input, select, option, textarea, button, video, label",
            width: null,
            height: null,
            preventInteractionOnTransition: false,
            userAgent: null,
            url: null,
            edgeSwipeDetection: false,
            edgeSwipeThreshold: 20,
            autoHeight: false,
            setWrapperSize: false,
            virtualTranslate: false,
            effect: "slide",
            breakpoints: void 0,
            breakpointsBase: "window",
            spaceBetween: 0,
            slidesPerView: 1,
            slidesPerGroup: 1,
            slidesPerGroupSkip: 0,
            slidesPerGroupAuto: false,
            centeredSlides: false,
            centeredSlidesBounds: false,
            slidesOffsetBefore: 0,
            slidesOffsetAfter: 0,
            normalizeSlideIndex: true,
            centerInsufficientSlides: false,
            watchOverflow: true,
            roundLengths: false,
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: true,
            shortSwipes: true,
            longSwipes: true,
            longSwipesRatio: .5,
            longSwipesMs: 300,
            followFinger: true,
            allowTouchMove: true,
            threshold: 0,
            touchMoveStopPropagation: false,
            touchStartPreventDefault: true,
            touchStartForcePreventDefault: false,
            touchReleaseOnEdges: false,
            uniqueNavElements: true,
            resistance: true,
            resistanceRatio: .85,
            watchSlidesProgress: false,
            grabCursor: false,
            preventClicks: true,
            preventClicksPropagation: true,
            slideToClickedSlide: false,
            preloadImages: true,
            updateOnImagesReady: true,
            loop: false,
            loopAdditionalSlides: 0,
            loopedSlides: null,
            loopedSlidesLimit: true,
            loopFillGroupWithBlank: false,
            loopPreventsSlide: true,
            rewind: false,
            allowSlidePrev: true,
            allowSlideNext: true,
            swipeHandler: null,
            noSwiping: true,
            noSwipingClass: "swiper-no-swiping",
            noSwipingSelector: null,
            passiveListeners: true,
            maxBackfaceHiddenSlides: 10,
            containerModifierClass: "swiper-",
            slideClass: "swiper-slide",
            slideBlankClass: "swiper-slide-invisible-blank",
            slideActiveClass: "swiper-slide-active",
            slideDuplicateActiveClass: "swiper-slide-duplicate-active",
            slideVisibleClass: "swiper-slide-visible",
            slideDuplicateClass: "swiper-slide-duplicate",
            slideNextClass: "swiper-slide-next",
            slideDuplicateNextClass: "swiper-slide-duplicate-next",
            slidePrevClass: "swiper-slide-prev",
            slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
            wrapperClass: "swiper-wrapper",
            runCallbacksOnInit: true,
            _emitClasses: false
        };
        function moduleExtendParams(params, allModulesParams) {
            return function extendParams(obj = {}) {
                const moduleParamName = Object.keys(obj)[0];
                const moduleParams = obj[moduleParamName];
                if ("object" !== typeof moduleParams || null === moduleParams) {
                    utils_extend(allModulesParams, obj);
                    return;
                }
                if ([ "navigation", "pagination", "scrollbar" ].indexOf(moduleParamName) >= 0 && true === params[moduleParamName]) params[moduleParamName] = {
                    auto: true
                };
                if (!(moduleParamName in params && "enabled" in moduleParams)) {
                    utils_extend(allModulesParams, obj);
                    return;
                }
                if (true === params[moduleParamName]) params[moduleParamName] = {
                    enabled: true
                };
                if ("object" === typeof params[moduleParamName] && !("enabled" in params[moduleParamName])) params[moduleParamName].enabled = true;
                if (!params[moduleParamName]) params[moduleParamName] = {
                    enabled: false
                };
                utils_extend(allModulesParams, obj);
            };
        }
        const prototypes = {
            eventsEmitter: events_emitter,
            update,
            translate,
            transition: core_transition,
            slide,
            loop,
            grabCursor: grab_cursor,
            events: core_events,
            breakpoints,
            checkOverflow: check_overflow,
            classes,
            images: core_images
        };
        const extendedDefaults = {};
        class core_Swiper {
            constructor(...args) {
                let el;
                let params;
                if (1 === args.length && args[0].constructor && "Object" === Object.prototype.toString.call(args[0]).slice(8, -1)) params = args[0]; else [el, params] = args;
                if (!params) params = {};
                params = utils_extend({}, params);
                if (el && !params.el) params.el = el;
                if (params.el && dom(params.el).length > 1) {
                    const swipers = [];
                    dom(params.el).each((containerEl => {
                        const newParams = utils_extend({}, params, {
                            el: containerEl
                        });
                        swipers.push(new core_Swiper(newParams));
                    }));
                    return swipers;
                }
                const swiper = this;
                swiper.__swiper__ = true;
                swiper.support = getSupport();
                swiper.device = getDevice({
                    userAgent: params.userAgent
                });
                swiper.browser = getBrowser();
                swiper.eventsListeners = {};
                swiper.eventsAnyListeners = [];
                swiper.modules = [ ...swiper.__modules__ ];
                if (params.modules && Array.isArray(params.modules)) swiper.modules.push(...params.modules);
                const allModulesParams = {};
                swiper.modules.forEach((mod => {
                    mod({
                        swiper,
                        extendParams: moduleExtendParams(params, allModulesParams),
                        on: swiper.on.bind(swiper),
                        once: swiper.once.bind(swiper),
                        off: swiper.off.bind(swiper),
                        emit: swiper.emit.bind(swiper)
                    });
                }));
                const swiperParams = utils_extend({}, defaults, allModulesParams);
                swiper.params = utils_extend({}, swiperParams, extendedDefaults, params);
                swiper.originalParams = utils_extend({}, swiper.params);
                swiper.passedParams = utils_extend({}, params);
                if (swiper.params && swiper.params.on) Object.keys(swiper.params.on).forEach((eventName => {
                    swiper.on(eventName, swiper.params.on[eventName]);
                }));
                if (swiper.params && swiper.params.onAny) swiper.onAny(swiper.params.onAny);
                swiper.$ = dom;
                Object.assign(swiper, {
                    enabled: swiper.params.enabled,
                    el,
                    classNames: [],
                    slides: dom(),
                    slidesGrid: [],
                    snapGrid: [],
                    slidesSizesGrid: [],
                    isHorizontal() {
                        return "horizontal" === swiper.params.direction;
                    },
                    isVertical() {
                        return "vertical" === swiper.params.direction;
                    },
                    activeIndex: 0,
                    realIndex: 0,
                    isBeginning: true,
                    isEnd: false,
                    translate: 0,
                    previousTranslate: 0,
                    progress: 0,
                    velocity: 0,
                    animating: false,
                    allowSlideNext: swiper.params.allowSlideNext,
                    allowSlidePrev: swiper.params.allowSlidePrev,
                    touchEvents: function touchEvents() {
                        const touch = [ "touchstart", "touchmove", "touchend", "touchcancel" ];
                        const desktop = [ "pointerdown", "pointermove", "pointerup" ];
                        swiper.touchEventsTouch = {
                            start: touch[0],
                            move: touch[1],
                            end: touch[2],
                            cancel: touch[3]
                        };
                        swiper.touchEventsDesktop = {
                            start: desktop[0],
                            move: desktop[1],
                            end: desktop[2]
                        };
                        return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
                    }(),
                    touchEventsData: {
                        isTouched: void 0,
                        isMoved: void 0,
                        allowTouchCallbacks: void 0,
                        touchStartTime: void 0,
                        isScrolling: void 0,
                        currentTranslate: void 0,
                        startTranslate: void 0,
                        allowThresholdMove: void 0,
                        focusableElements: swiper.params.focusableElements,
                        lastClickTime: utils_now(),
                        clickTimeout: void 0,
                        velocities: [],
                        allowMomentumBounce: void 0,
                        isTouchEvent: void 0,
                        startMoving: void 0
                    },
                    allowClick: true,
                    allowTouchMove: swiper.params.allowTouchMove,
                    touches: {
                        startX: 0,
                        startY: 0,
                        currentX: 0,
                        currentY: 0,
                        diff: 0
                    },
                    imagesToLoad: [],
                    imagesLoaded: 0
                });
                swiper.emit("_swiper");
                if (swiper.params.init) swiper.init();
                return swiper;
            }
            enable() {
                const swiper = this;
                if (swiper.enabled) return;
                swiper.enabled = true;
                if (swiper.params.grabCursor) swiper.setGrabCursor();
                swiper.emit("enable");
            }
            disable() {
                const swiper = this;
                if (!swiper.enabled) return;
                swiper.enabled = false;
                if (swiper.params.grabCursor) swiper.unsetGrabCursor();
                swiper.emit("disable");
            }
            setProgress(progress, speed) {
                const swiper = this;
                progress = Math.min(Math.max(progress, 0), 1);
                const min = swiper.minTranslate();
                const max = swiper.maxTranslate();
                const current = (max - min) * progress + min;
                swiper.translateTo(current, "undefined" === typeof speed ? 0 : speed);
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            emitContainerClasses() {
                const swiper = this;
                if (!swiper.params._emitClasses || !swiper.el) return;
                const cls = swiper.el.className.split(" ").filter((className => 0 === className.indexOf("swiper") || 0 === className.indexOf(swiper.params.containerModifierClass)));
                swiper.emit("_containerClasses", cls.join(" "));
            }
            getSlideClasses(slideEl) {
                const swiper = this;
                if (swiper.destroyed) return "";
                return slideEl.className.split(" ").filter((className => 0 === className.indexOf("swiper-slide") || 0 === className.indexOf(swiper.params.slideClass))).join(" ");
            }
            emitSlidesClasses() {
                const swiper = this;
                if (!swiper.params._emitClasses || !swiper.el) return;
                const updates = [];
                swiper.slides.each((slideEl => {
                    const classNames = swiper.getSlideClasses(slideEl);
                    updates.push({
                        slideEl,
                        classNames
                    });
                    swiper.emit("_slideClass", slideEl, classNames);
                }));
                swiper.emit("_slideClasses", updates);
            }
            slidesPerViewDynamic(view = "current", exact = false) {
                const swiper = this;
                const {params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex} = swiper;
                let spv = 1;
                if (params.centeredSlides) {
                    let slideSize = slides[activeIndex].swiperSlideSize;
                    let breakLoop;
                    for (let i = activeIndex + 1; i < slides.length; i += 1) if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                    for (let i = activeIndex - 1; i >= 0; i -= 1) if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                } else if ("current" === view) for (let i = activeIndex + 1; i < slides.length; i += 1) {
                    const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
                    if (slideInView) spv += 1;
                } else for (let i = activeIndex - 1; i >= 0; i -= 1) {
                    const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
                    if (slideInView) spv += 1;
                }
                return spv;
            }
            update() {
                const swiper = this;
                if (!swiper || swiper.destroyed) return;
                const {snapGrid, params} = swiper;
                if (params.breakpoints) swiper.setBreakpoint();
                swiper.updateSize();
                swiper.updateSlides();
                swiper.updateProgress();
                swiper.updateSlidesClasses();
                function setTranslate() {
                    const translateValue = swiper.rtlTranslate ? -1 * swiper.translate : swiper.translate;
                    const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
                    swiper.setTranslate(newTranslate);
                    swiper.updateActiveIndex();
                    swiper.updateSlidesClasses();
                }
                let translated;
                if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
                    setTranslate();
                    if (swiper.params.autoHeight) swiper.updateAutoHeight();
                } else {
                    if (("auto" === swiper.params.slidesPerView || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true); else translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
                    if (!translated) setTranslate();
                }
                if (params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
                swiper.emit("update");
            }
            changeDirection(newDirection, needUpdate = true) {
                const swiper = this;
                const currentDirection = swiper.params.direction;
                if (!newDirection) newDirection = "horizontal" === currentDirection ? "vertical" : "horizontal";
                if (newDirection === currentDirection || "horizontal" !== newDirection && "vertical" !== newDirection) return swiper;
                swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);
                swiper.emitContainerClasses();
                swiper.params.direction = newDirection;
                swiper.slides.each((slideEl => {
                    if ("vertical" === newDirection) slideEl.style.width = ""; else slideEl.style.height = "";
                }));
                swiper.emit("changeDirection");
                if (needUpdate) swiper.update();
                return swiper;
            }
            changeLanguageDirection(direction) {
                const swiper = this;
                if (swiper.rtl && "rtl" === direction || !swiper.rtl && "ltr" === direction) return;
                swiper.rtl = "rtl" === direction;
                swiper.rtlTranslate = "horizontal" === swiper.params.direction && swiper.rtl;
                if (swiper.rtl) {
                    swiper.$el.addClass(`${swiper.params.containerModifierClass}rtl`);
                    swiper.el.dir = "rtl";
                } else {
                    swiper.$el.removeClass(`${swiper.params.containerModifierClass}rtl`);
                    swiper.el.dir = "ltr";
                }
                swiper.update();
            }
            mount(el) {
                const swiper = this;
                if (swiper.mounted) return true;
                const $el = dom(el || swiper.params.el);
                el = $el[0];
                if (!el) return false;
                el.swiper = swiper;
                const getWrapperSelector = () => `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
                const getWrapper = () => {
                    if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                        const res = dom(el.shadowRoot.querySelector(getWrapperSelector()));
                        res.children = options => $el.children(options);
                        return res;
                    }
                    if (!$el.children) return dom($el).children(getWrapperSelector());
                    return $el.children(getWrapperSelector());
                };
                let $wrapperEl = getWrapper();
                if (0 === $wrapperEl.length && swiper.params.createElements) {
                    const document = ssr_window_esm_getDocument();
                    const wrapper = document.createElement("div");
                    $wrapperEl = dom(wrapper);
                    wrapper.className = swiper.params.wrapperClass;
                    $el.append(wrapper);
                    $el.children(`.${swiper.params.slideClass}`).each((slideEl => {
                        $wrapperEl.append(slideEl);
                    }));
                }
                Object.assign(swiper, {
                    $el,
                    el,
                    $wrapperEl,
                    wrapperEl: $wrapperEl[0],
                    mounted: true,
                    rtl: "rtl" === el.dir.toLowerCase() || "rtl" === $el.css("direction"),
                    rtlTranslate: "horizontal" === swiper.params.direction && ("rtl" === el.dir.toLowerCase() || "rtl" === $el.css("direction")),
                    wrongRTL: "-webkit-box" === $wrapperEl.css("display")
                });
                return true;
            }
            init(el) {
                const swiper = this;
                if (swiper.initialized) return swiper;
                const mounted = swiper.mount(el);
                if (false === mounted) return swiper;
                swiper.emit("beforeInit");
                if (swiper.params.breakpoints) swiper.setBreakpoint();
                swiper.addClasses();
                if (swiper.params.loop) swiper.loopCreate();
                swiper.updateSize();
                swiper.updateSlides();
                if (swiper.params.watchOverflow) swiper.checkOverflow();
                if (swiper.params.grabCursor && swiper.enabled) swiper.setGrabCursor();
                if (swiper.params.preloadImages) swiper.preloadImages();
                if (swiper.params.loop) swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true); else swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
                swiper.attachEvents();
                swiper.initialized = true;
                swiper.emit("init");
                swiper.emit("afterInit");
                return swiper;
            }
            destroy(deleteInstance = true, cleanStyles = true) {
                const swiper = this;
                const {params, $el, $wrapperEl, slides} = swiper;
                if ("undefined" === typeof swiper.params || swiper.destroyed) return null;
                swiper.emit("beforeDestroy");
                swiper.initialized = false;
                swiper.detachEvents();
                if (params.loop) swiper.loopDestroy();
                if (cleanStyles) {
                    swiper.removeClasses();
                    $el.removeAttr("style");
                    $wrapperEl.removeAttr("style");
                    if (slides && slides.length) slides.removeClass([ params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass ].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index");
                }
                swiper.emit("destroy");
                Object.keys(swiper.eventsListeners).forEach((eventName => {
                    swiper.off(eventName);
                }));
                if (false !== deleteInstance) {
                    swiper.$el[0].swiper = null;
                    deleteProps(swiper);
                }
                swiper.destroyed = true;
                return null;
            }
            static extendDefaults(newDefaults) {
                utils_extend(extendedDefaults, newDefaults);
            }
            static get extendedDefaults() {
                return extendedDefaults;
            }
            static get defaults() {
                return defaults;
            }
            static installModule(mod) {
                if (!core_Swiper.prototype.__modules__) core_Swiper.prototype.__modules__ = [];
                const modules = core_Swiper.prototype.__modules__;
                if ("function" === typeof mod && modules.indexOf(mod) < 0) modules.push(mod);
            }
            static use(module) {
                if (Array.isArray(module)) {
                    module.forEach((m => core_Swiper.installModule(m)));
                    return core_Swiper;
                }
                core_Swiper.installModule(module);
                return core_Swiper;
            }
        }
        Object.keys(prototypes).forEach((prototypeGroup => {
            Object.keys(prototypes[prototypeGroup]).forEach((protoMethod => {
                core_Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
            }));
        }));
        core_Swiper.use([ Resize, Observer ]);
        const core = core_Swiper;
        function create_element_if_not_defined_createElementIfNotDefined(swiper, originalParams, params, checkProps) {
            const document = ssr_window_esm_getDocument();
            if (swiper.params.createElements) Object.keys(checkProps).forEach((key => {
                if (!params[key] && true === params.auto) {
                    let element = swiper.$el.children(`.${checkProps[key]}`)[0];
                    if (!element) {
                        element = document.createElement("div");
                        element.className = checkProps[key];
                        swiper.$el.append(element);
                    }
                    params[key] = element;
                    originalParams[key] = element;
                }
            }));
            return params;
        }
        function Navigation({swiper, extendParams, on, emit}) {
            extendParams({
                navigation: {
                    nextEl: null,
                    prevEl: null,
                    hideOnClick: false,
                    disabledClass: "swiper-button-disabled",
                    hiddenClass: "swiper-button-hidden",
                    lockClass: "swiper-button-lock",
                    navigationDisabledClass: "swiper-navigation-disabled"
                }
            });
            swiper.navigation = {
                nextEl: null,
                $nextEl: null,
                prevEl: null,
                $prevEl: null
            };
            function getEl(el) {
                let $el;
                if (el) {
                    $el = dom(el);
                    if (swiper.params.uniqueNavElements && "string" === typeof el && $el.length > 1 && 1 === swiper.$el.find(el).length) $el = swiper.$el.find(el);
                }
                return $el;
            }
            function toggleEl($el, disabled) {
                const params = swiper.params.navigation;
                if ($el && $el.length > 0) {
                    $el[disabled ? "addClass" : "removeClass"](params.disabledClass);
                    if ($el[0] && "BUTTON" === $el[0].tagName) $el[0].disabled = disabled;
                    if (swiper.params.watchOverflow && swiper.enabled) $el[swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
                }
            }
            function update() {
                if (swiper.params.loop) return;
                const {$nextEl, $prevEl} = swiper.navigation;
                toggleEl($prevEl, swiper.isBeginning && !swiper.params.rewind);
                toggleEl($nextEl, swiper.isEnd && !swiper.params.rewind);
            }
            function onPrevClick(e) {
                e.preventDefault();
                if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
                swiper.slidePrev();
                emit("navigationPrev");
            }
            function onNextClick(e) {
                e.preventDefault();
                if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
                swiper.slideNext();
                emit("navigationNext");
            }
            function init() {
                const params = swiper.params.navigation;
                swiper.params.navigation = create_element_if_not_defined_createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
                    nextEl: "swiper-button-next",
                    prevEl: "swiper-button-prev"
                });
                if (!(params.nextEl || params.prevEl)) return;
                const $nextEl = getEl(params.nextEl);
                const $prevEl = getEl(params.prevEl);
                if ($nextEl && $nextEl.length > 0) $nextEl.on("click", onNextClick);
                if ($prevEl && $prevEl.length > 0) $prevEl.on("click", onPrevClick);
                Object.assign(swiper.navigation, {
                    $nextEl,
                    nextEl: $nextEl && $nextEl[0],
                    $prevEl,
                    prevEl: $prevEl && $prevEl[0]
                });
                if (!swiper.enabled) {
                    if ($nextEl) $nextEl.addClass(params.lockClass);
                    if ($prevEl) $prevEl.addClass(params.lockClass);
                }
            }
            function destroy() {
                const {$nextEl, $prevEl} = swiper.navigation;
                if ($nextEl && $nextEl.length) {
                    $nextEl.off("click", onNextClick);
                    $nextEl.removeClass(swiper.params.navigation.disabledClass);
                }
                if ($prevEl && $prevEl.length) {
                    $prevEl.off("click", onPrevClick);
                    $prevEl.removeClass(swiper.params.navigation.disabledClass);
                }
            }
            on("init", (() => {
                if (false === swiper.params.navigation.enabled) disable(); else {
                    init();
                    update();
                }
            }));
            on("toEdge fromEdge lock unlock", (() => {
                update();
            }));
            on("destroy", (() => {
                destroy();
            }));
            on("enable disable", (() => {
                const {$nextEl, $prevEl} = swiper.navigation;
                if ($nextEl) $nextEl[swiper.enabled ? "removeClass" : "addClass"](swiper.params.navigation.lockClass);
                if ($prevEl) $prevEl[swiper.enabled ? "removeClass" : "addClass"](swiper.params.navigation.lockClass);
            }));
            on("click", ((_s, e) => {
                const {$nextEl, $prevEl} = swiper.navigation;
                const targetEl = e.target;
                if (swiper.params.navigation.hideOnClick && !dom(targetEl).is($prevEl) && !dom(targetEl).is($nextEl)) {
                    if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
                    let isHidden;
                    if ($nextEl) isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass); else if ($prevEl) isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
                    if (true === isHidden) emit("navigationShow"); else emit("navigationHide");
                    if ($nextEl) $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
                    if ($prevEl) $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
                }
            }));
            const enable = () => {
                swiper.$el.removeClass(swiper.params.navigation.navigationDisabledClass);
                init();
                update();
            };
            const disable = () => {
                swiper.$el.addClass(swiper.params.navigation.navigationDisabledClass);
                destroy();
            };
            Object.assign(swiper.navigation, {
                enable,
                disable,
                update,
                init,
                destroy
            });
        }
        function classes_to_selector_classesToSelector(classes = "") {
            return `.${classes.trim().replace(/([\.:!\/])/g, "\\$1").replace(/ /g, ".")}`;
        }
        function Pagination({swiper, extendParams, on, emit}) {
            const pfx = "swiper-pagination";
            extendParams({
                pagination: {
                    el: null,
                    bulletElement: "span",
                    clickable: false,
                    hideOnClick: false,
                    renderBullet: null,
                    renderProgressbar: null,
                    renderFraction: null,
                    renderCustom: null,
                    progressbarOpposite: false,
                    type: "bullets",
                    dynamicBullets: false,
                    dynamicMainBullets: 1,
                    formatFractionCurrent: number => number,
                    formatFractionTotal: number => number,
                    bulletClass: `${pfx}-bullet`,
                    bulletActiveClass: `${pfx}-bullet-active`,
                    modifierClass: `${pfx}-`,
                    currentClass: `${pfx}-current`,
                    totalClass: `${pfx}-total`,
                    hiddenClass: `${pfx}-hidden`,
                    progressbarFillClass: `${pfx}-progressbar-fill`,
                    progressbarOppositeClass: `${pfx}-progressbar-opposite`,
                    clickableClass: `${pfx}-clickable`,
                    lockClass: `${pfx}-lock`,
                    horizontalClass: `${pfx}-horizontal`,
                    verticalClass: `${pfx}-vertical`,
                    paginationDisabledClass: `${pfx}-disabled`
                }
            });
            swiper.pagination = {
                el: null,
                $el: null,
                bullets: []
            };
            let bulletSize;
            let dynamicBulletIndex = 0;
            function isPaginationDisabled() {
                return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || 0 === swiper.pagination.$el.length;
            }
            function setSideBullets($bulletEl, position) {
                const {bulletActiveClass} = swiper.params.pagination;
                $bulletEl[position]().addClass(`${bulletActiveClass}-${position}`)[position]().addClass(`${bulletActiveClass}-${position}-${position}`);
            }
            function update() {
                const rtl = swiper.rtl;
                const params = swiper.params.pagination;
                if (isPaginationDisabled()) return;
                const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
                const $el = swiper.pagination.$el;
                let current;
                const total = swiper.params.loop ? Math.ceil((slidesLength - 2 * swiper.loopedSlides) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                if (swiper.params.loop) {
                    current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
                    if (current > slidesLength - 1 - 2 * swiper.loopedSlides) current -= slidesLength - 2 * swiper.loopedSlides;
                    if (current > total - 1) current -= total;
                    if (current < 0 && "bullets" !== swiper.params.paginationType) current = total + current;
                } else if ("undefined" !== typeof swiper.snapIndex) current = swiper.snapIndex; else current = swiper.activeIndex || 0;
                if ("bullets" === params.type && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
                    const bullets = swiper.pagination.bullets;
                    let firstIndex;
                    let lastIndex;
                    let midIndex;
                    if (params.dynamicBullets) {
                        bulletSize = bullets.eq(0)[swiper.isHorizontal() ? "outerWidth" : "outerHeight"](true);
                        $el.css(swiper.isHorizontal() ? "width" : "height", `${bulletSize * (params.dynamicMainBullets + 4)}px`);
                        if (params.dynamicMainBullets > 1 && void 0 !== swiper.previousIndex) {
                            dynamicBulletIndex += current - (swiper.previousIndex - swiper.loopedSlides || 0);
                            if (dynamicBulletIndex > params.dynamicMainBullets - 1) dynamicBulletIndex = params.dynamicMainBullets - 1; else if (dynamicBulletIndex < 0) dynamicBulletIndex = 0;
                        }
                        firstIndex = Math.max(current - dynamicBulletIndex, 0);
                        lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                        midIndex = (lastIndex + firstIndex) / 2;
                    }
                    bullets.removeClass([ "", "-next", "-next-next", "-prev", "-prev-prev", "-main" ].map((suffix => `${params.bulletActiveClass}${suffix}`)).join(" "));
                    if ($el.length > 1) bullets.each((bullet => {
                        const $bullet = dom(bullet);
                        const bulletIndex = $bullet.index();
                        if (bulletIndex === current) $bullet.addClass(params.bulletActiveClass);
                        if (params.dynamicBullets) {
                            if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) $bullet.addClass(`${params.bulletActiveClass}-main`);
                            if (bulletIndex === firstIndex) setSideBullets($bullet, "prev");
                            if (bulletIndex === lastIndex) setSideBullets($bullet, "next");
                        }
                    })); else {
                        const $bullet = bullets.eq(current);
                        const bulletIndex = $bullet.index();
                        $bullet.addClass(params.bulletActiveClass);
                        if (params.dynamicBullets) {
                            const $firstDisplayedBullet = bullets.eq(firstIndex);
                            const $lastDisplayedBullet = bullets.eq(lastIndex);
                            for (let i = firstIndex; i <= lastIndex; i += 1) bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
                            if (swiper.params.loop) if (bulletIndex >= bullets.length) {
                                for (let i = params.dynamicMainBullets; i >= 0; i -= 1) bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
                                bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
                            } else {
                                setSideBullets($firstDisplayedBullet, "prev");
                                setSideBullets($lastDisplayedBullet, "next");
                            } else {
                                setSideBullets($firstDisplayedBullet, "prev");
                                setSideBullets($lastDisplayedBullet, "next");
                            }
                        }
                    }
                    if (params.dynamicBullets) {
                        const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
                        const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
                        const offsetProp = rtl ? "right" : "left";
                        bullets.css(swiper.isHorizontal() ? offsetProp : "top", `${bulletsOffset}px`);
                    }
                }
                if ("fraction" === params.type) {
                    $el.find(classes_to_selector_classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
                    $el.find(classes_to_selector_classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
                }
                if ("progressbar" === params.type) {
                    let progressbarDirection;
                    if (params.progressbarOpposite) progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal"; else progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical";
                    const scale = (current + 1) / total;
                    let scaleX = 1;
                    let scaleY = 1;
                    if ("horizontal" === progressbarDirection) scaleX = scale; else scaleY = scale;
                    $el.find(classes_to_selector_classesToSelector(params.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
                }
                if ("custom" === params.type && params.renderCustom) {
                    $el.html(params.renderCustom(swiper, current + 1, total));
                    emit("paginationRender", $el[0]);
                } else emit("paginationUpdate", $el[0]);
                if (swiper.params.watchOverflow && swiper.enabled) $el[swiper.isLocked ? "addClass" : "removeClass"](params.lockClass);
            }
            function render() {
                const params = swiper.params.pagination;
                if (isPaginationDisabled()) return;
                const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
                const $el = swiper.pagination.$el;
                let paginationHTML = "";
                if ("bullets" === params.type) {
                    let numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - 2 * swiper.loopedSlides) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
                    if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) numberOfBullets = slidesLength;
                    for (let i = 0; i < numberOfBullets; i += 1) if (params.renderBullet) paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass); else paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
                    $el.html(paginationHTML);
                    swiper.pagination.bullets = $el.find(classes_to_selector_classesToSelector(params.bulletClass));
                }
                if ("fraction" === params.type) {
                    if (params.renderFraction) paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass); else paginationHTML = `<span class="${params.currentClass}"></span>` + " / " + `<span class="${params.totalClass}"></span>`;
                    $el.html(paginationHTML);
                }
                if ("progressbar" === params.type) {
                    if (params.renderProgressbar) paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass); else paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
                    $el.html(paginationHTML);
                }
                if ("custom" !== params.type) emit("paginationRender", swiper.pagination.$el[0]);
            }
            function init() {
                swiper.params.pagination = create_element_if_not_defined_createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
                    el: "swiper-pagination"
                });
                const params = swiper.params.pagination;
                if (!params.el) return;
                let $el = dom(params.el);
                if (0 === $el.length) return;
                if (swiper.params.uniqueNavElements && "string" === typeof params.el && $el.length > 1) {
                    $el = swiper.$el.find(params.el);
                    if ($el.length > 1) $el = $el.filter((el => {
                        if (dom(el).parents(".swiper")[0] !== swiper.el) return false;
                        return true;
                    }));
                }
                if ("bullets" === params.type && params.clickable) $el.addClass(params.clickableClass);
                $el.addClass(params.modifierClass + params.type);
                $el.addClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                if ("bullets" === params.type && params.dynamicBullets) {
                    $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
                    dynamicBulletIndex = 0;
                    if (params.dynamicMainBullets < 1) params.dynamicMainBullets = 1;
                }
                if ("progressbar" === params.type && params.progressbarOpposite) $el.addClass(params.progressbarOppositeClass);
                if (params.clickable) $el.on("click", classes_to_selector_classesToSelector(params.bulletClass), (function onClick(e) {
                    e.preventDefault();
                    let index = dom(this).index() * swiper.params.slidesPerGroup;
                    if (swiper.params.loop) index += swiper.loopedSlides;
                    swiper.slideTo(index);
                }));
                Object.assign(swiper.pagination, {
                    $el,
                    el: $el[0]
                });
                if (!swiper.enabled) $el.addClass(params.lockClass);
            }
            function destroy() {
                const params = swiper.params.pagination;
                if (isPaginationDisabled()) return;
                const $el = swiper.pagination.$el;
                $el.removeClass(params.hiddenClass);
                $el.removeClass(params.modifierClass + params.type);
                $el.removeClass(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
                if (params.clickable) $el.off("click", classes_to_selector_classesToSelector(params.bulletClass));
            }
            on("init", (() => {
                if (false === swiper.params.pagination.enabled) disable(); else {
                    init();
                    render();
                    update();
                }
            }));
            on("activeIndexChange", (() => {
                if (swiper.params.loop) update(); else if ("undefined" === typeof swiper.snapIndex) update();
            }));
            on("snapIndexChange", (() => {
                if (!swiper.params.loop) update();
            }));
            on("slidesLengthChange", (() => {
                if (swiper.params.loop) {
                    render();
                    update();
                }
            }));
            on("snapGridLengthChange", (() => {
                if (!swiper.params.loop) {
                    render();
                    update();
                }
            }));
            on("destroy", (() => {
                destroy();
            }));
            on("enable disable", (() => {
                const {$el} = swiper.pagination;
                if ($el) $el[swiper.enabled ? "removeClass" : "addClass"](swiper.params.pagination.lockClass);
            }));
            on("lock unlock", (() => {
                update();
            }));
            on("click", ((_s, e) => {
                const targetEl = e.target;
                const {$el} = swiper.pagination;
                if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el && $el.length > 0 && !dom(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
                    if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
                    const isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);
                    if (true === isHidden) emit("paginationShow"); else emit("paginationHide");
                    $el.toggleClass(swiper.params.pagination.hiddenClass);
                }
            }));
            const enable = () => {
                swiper.$el.removeClass(swiper.params.pagination.paginationDisabledClass);
                if (swiper.pagination.$el) swiper.pagination.$el.removeClass(swiper.params.pagination.paginationDisabledClass);
                init();
                render();
                update();
            };
            const disable = () => {
                swiper.$el.addClass(swiper.params.pagination.paginationDisabledClass);
                if (swiper.pagination.$el) swiper.pagination.$el.addClass(swiper.params.pagination.paginationDisabledClass);
                destroy();
            };
            Object.assign(swiper.pagination, {
                enable,
                disable,
                render,
                update,
                init,
                destroy
            });
        }
        function effect_init_effectInit(params) {
            const {effect, swiper, on, setTranslate, setTransition, overwriteParams, perspective, recreateShadows, getEffectParams} = params;
            on("beforeInit", (() => {
                if (swiper.params.effect !== effect) return;
                swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
                if (perspective && perspective()) swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
                const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
                Object.assign(swiper.params, overwriteParamsResult);
                Object.assign(swiper.originalParams, overwriteParamsResult);
            }));
            on("setTranslate", (() => {
                if (swiper.params.effect !== effect) return;
                setTranslate();
            }));
            on("setTransition", ((_s, duration) => {
                if (swiper.params.effect !== effect) return;
                setTransition(duration);
            }));
            on("transitionEnd", (() => {
                if (swiper.params.effect !== effect) return;
                if (recreateShadows) {
                    if (!getEffectParams || !getEffectParams().slideShadows) return;
                    swiper.slides.each((slideEl => {
                        const $slideEl = swiper.$(slideEl);
                        $slideEl.find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").remove();
                    }));
                    recreateShadows();
                }
            }));
            let requireUpdateOnVirtual;
            on("virtualUpdate", (() => {
                if (swiper.params.effect !== effect) return;
                if (!swiper.slides.length) requireUpdateOnVirtual = true;
                requestAnimationFrame((() => {
                    if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
                        setTranslate();
                        requireUpdateOnVirtual = false;
                    }
                }));
            }));
        }
        function effect_target_effectTarget(effectParams, $slideEl) {
            if (effectParams.transformEl) return $slideEl.find(effectParams.transformEl).css({
                "backface-visibility": "hidden",
                "-webkit-backface-visibility": "hidden"
            });
            return $slideEl;
        }
        function effect_virtual_transition_end_effectVirtualTransitionEnd({swiper, duration, transformEl, allSlides}) {
            const {slides, activeIndex, $wrapperEl} = swiper;
            if (swiper.params.virtualTranslate && 0 !== duration) {
                let eventTriggered = false;
                let $transitionEndTarget;
                if (allSlides) $transitionEndTarget = transformEl ? slides.find(transformEl) : slides; else $transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);
                $transitionEndTarget.transitionEnd((() => {
                    if (eventTriggered) return;
                    if (!swiper || swiper.destroyed) return;
                    eventTriggered = true;
                    swiper.animating = false;
                    const triggerEvents = [ "webkitTransitionEnd", "transitionend" ];
                    for (let i = 0; i < triggerEvents.length; i += 1) $wrapperEl.trigger(triggerEvents[i]);
                }));
            }
        }
        function EffectFade({swiper, extendParams, on}) {
            extendParams({
                fadeEffect: {
                    crossFade: false,
                    transformEl: null
                }
            });
            const setTranslate = () => {
                const {slides} = swiper;
                const params = swiper.params.fadeEffect;
                for (let i = 0; i < slides.length; i += 1) {
                    const $slideEl = swiper.slides.eq(i);
                    const offset = $slideEl[0].swiperSlideOffset;
                    let tx = -offset;
                    if (!swiper.params.virtualTranslate) tx -= swiper.translate;
                    let ty = 0;
                    if (!swiper.isHorizontal()) {
                        ty = tx;
                        tx = 0;
                    }
                    const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
                    const $targetEl = effect_target_effectTarget(params, $slideEl);
                    $targetEl.css({
                        opacity: slideOpacity
                    }).transform(`translate3d(${tx}px, ${ty}px, 0px)`);
                }
            };
            const setTransition = duration => {
                const {transformEl} = swiper.params.fadeEffect;
                const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
                $transitionElements.transition(duration);
                effect_virtual_transition_end_effectVirtualTransitionEnd({
                    swiper,
                    duration,
                    transformEl,
                    allSlides: true
                });
            };
            effect_init_effectInit({
                effect: "fade",
                swiper,
                on,
                setTranslate,
                setTransition,
                overwriteParams: () => ({
                    slidesPerView: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: true,
                    spaceBetween: 0,
                    virtualTranslate: !swiper.params.cssMode
                })
            });
        }
        function create_shadow_createShadow(params, $slideEl, side) {
            const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ""}`;
            const $shadowContainer = params.transformEl ? $slideEl.find(params.transformEl) : $slideEl;
            let $shadowEl = $shadowContainer.children(`.${shadowClass}`);
            if (!$shadowEl.length) {
                $shadowEl = dom(`<div class="swiper-slide-shadow${side ? `-${side}` : ""}"></div>`);
                $shadowContainer.append($shadowEl);
            }
            return $shadowEl;
        }
        function EffectCreative({swiper, extendParams, on}) {
            extendParams({
                creativeEffect: {
                    transformEl: null,
                    limitProgress: 1,
                    shadowPerProgress: false,
                    progressMultiplier: 1,
                    perspective: true,
                    prev: {
                        translate: [ 0, 0, 0 ],
                        rotate: [ 0, 0, 0 ],
                        opacity: 1,
                        scale: 1
                    },
                    next: {
                        translate: [ 0, 0, 0 ],
                        rotate: [ 0, 0, 0 ],
                        opacity: 1,
                        scale: 1
                    }
                }
            });
            const getTranslateValue = value => {
                if ("string" === typeof value) return value;
                return `${value}px`;
            };
            const setTranslate = () => {
                const {slides, $wrapperEl, slidesSizesGrid} = swiper;
                const params = swiper.params.creativeEffect;
                const {progressMultiplier: multiplier} = params;
                const isCenteredSlides = swiper.params.centeredSlides;
                if (isCenteredSlides) {
                    const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
                    $wrapperEl.transform(`translateX(calc(50% - ${margin}px))`);
                }
                for (let i = 0; i < slides.length; i += 1) {
                    const $slideEl = slides.eq(i);
                    const slideProgress = $slideEl[0].progress;
                    const progress = Math.min(Math.max($slideEl[0].progress, -params.limitProgress), params.limitProgress);
                    let originalProgress = progress;
                    if (!isCenteredSlides) originalProgress = Math.min(Math.max($slideEl[0].originalProgress, -params.limitProgress), params.limitProgress);
                    const offset = $slideEl[0].swiperSlideOffset;
                    const t = [ swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0 ];
                    const r = [ 0, 0, 0 ];
                    let custom = false;
                    if (!swiper.isHorizontal()) {
                        t[1] = t[0];
                        t[0] = 0;
                    }
                    let data = {
                        translate: [ 0, 0, 0 ],
                        rotate: [ 0, 0, 0 ],
                        scale: 1,
                        opacity: 1
                    };
                    if (progress < 0) {
                        data = params.next;
                        custom = true;
                    } else if (progress > 0) {
                        data = params.prev;
                        custom = true;
                    }
                    t.forEach(((value, index) => {
                        t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;
                    }));
                    r.forEach(((value, index) => {
                        r[index] = data.rotate[index] * Math.abs(progress * multiplier);
                    }));
                    $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
                    const translateString = t.join(", ");
                    const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;
                    const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;
                    const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
                    const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;
                    if (custom && data.shadow || !custom) {
                        let $shadowEl = $slideEl.children(".swiper-slide-shadow");
                        if (0 === $shadowEl.length && data.shadow) $shadowEl = create_shadow_createShadow(params, $slideEl);
                        if ($shadowEl.length) {
                            const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
                            $shadowEl[0].style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
                        }
                    }
                    const $targetEl = effect_target_effectTarget(params, $slideEl);
                    $targetEl.transform(transform).css({
                        opacity: opacityString
                    });
                    if (data.origin) $targetEl.css("transform-origin", data.origin);
                }
            };
            const setTransition = duration => {
                const {transformEl} = swiper.params.creativeEffect;
                const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;
                $transitionElements.transition(duration).find(".swiper-slide-shadow").transition(duration);
                effect_virtual_transition_end_effectVirtualTransitionEnd({
                    swiper,
                    duration,
                    transformEl,
                    allSlides: true
                });
            };
            effect_init_effectInit({
                effect: "creative",
                swiper,
                on,
                setTranslate,
                setTransition,
                perspective: () => swiper.params.creativeEffect.perspective,
                overwriteParams: () => ({
                    watchSlidesProgress: true,
                    virtualTranslate: !swiper.params.cssMode
                })
            });
        }
        function initSliders() {
            if (document.querySelector(".card-who__slider")) new core(".card-who__slider", {
                modules: [ Navigation ],
                slidesPerView: 1,
                spaceBetween: 10,
                speed: 400,
                navigation: {
                    prevEl: ".card-who__slider .swiper-button-prev",
                    nextEl: ".card-who__slider .swiper-button-next"
                },
                on: {}
            });
            if (window.innerWidth <= 767.98) if (document.querySelector(".plans__slider")) new core(".plans__slider", {
                modules: [ Pagination, Navigation, EffectFade ],
                effect: "fade",
                pagination: {
                    el: ".plans__slider .swiper-pagination",
                    clickable: true,
                    renderBullet: function(index, className) {
                        return '<button class="' + className + '"><span>' + (index + 1) + "</span></button>";
                    }
                }
            });
            if (document.querySelector(".descr-roadmap__slider")) {
                new core(".descr-roadmap__slider", {
                    modules: [ Navigation, Pagination, EffectCreative ],
                    observer: true,
                    observeParents: true,
                    slidesPerView: 1,
                    spaceBetween: 25,
                    speed: 600,
                    effect: "creative",
                    creativeEffect: {
                        prev: {
                            shadow: true,
                            translate: [ "-100%", 0, -1 ]
                        },
                        next: {
                            translate: [ "100%", 0, 0 ]
                        }
                    },
                    pagination: {
                        el: ".descr-roadmap .swiper-pagination",
                        clickable: true
                    },
                    navigation: {
                        prevEl: ".descr-roadmap__slider .swiper-button-prev",
                        nextEl: ".descr-roadmap__slider .swiper-button-next"
                    }
                });
                const sliderContainer = document.querySelector(".descr-roadmap");
                sliderContainer.addEventListener("click", (e => {
                    const target = e.target;
                    if (target.closest(".swiper-pagination-bullet")) sliderContainer.classList.add("_show"); else if (!target.closest(".swiper-buttons") || target.closest("[data-exit]")) sliderContainer.classList.remove("_show");
                }));
                const addDots = () => {
                    const currSlider = document.querySelector(".descr-roadmap"), btns = currSlider.querySelectorAll(".swiper-pagination-bullet"), year = currSlider.querySelectorAll(".descr-roadmap__num"), label = currSlider.querySelectorAll(".descr-roadmap__label");
                    btns.forEach(((btn, i) => {
                        btn.innerHTML = `\n\t\t\t\t\t<div class="roadmap-pagination__body">\n\t\t\t\t\t\t<div class="roadmap-pagination__content">\n\t\t\t\t\t\t\t<div class="roadmap-pagination__num roadmap__num">${year[i].innerHTML}</div>\n\t\t\t\t\t\t\t<div class="roadmap-pagination__label roadmap__label">${label[i].innerHTML}</div>\t\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<button class="roadmap-pagination__btn btn-arrow _icon-check" type="button"></button>\n\t\t\t\t\t</div>\n\t\t\t\t`;
                    }));
                };
                addDots();
                const addPaddingForSlide = () => {
                    if (window.innerWidth > 767.98) {
                        const slides = document.querySelectorAll(".descr-roadmap__slide");
                        let count = 0;
                        slides.forEach(((slide, i) => {
                            if (i < 3) count += 8; else count += 14;
                            slide.style.paddingLeft = `${count}%`;
                        }));
                    }
                };
                addPaddingForSlide();
            }
        }
        window.addEventListener("load", (function(e) {
            initSliders();
        }));
        var lazyload_min = __webpack_require__(2732);
        new lazyload_min({
            elements_selector: "[data-src],[data-srcset]",
            class_loaded: "_lazy-loaded",
            use_native: true
        });
        class parallax_Parallax {
            constructor(elements) {
                if (elements.length) this.elements = Array.from(elements).map((el => new parallax_Parallax.Each(el, this.options)));
            }
            destroyEvents() {
                this.elements.forEach((el => {
                    el.destroyEvents();
                }));
            }
            setEvents() {
                this.elements.forEach((el => {
                    el.setEvents();
                }));
            }
        }
        parallax_Parallax.Each = class {
            constructor(parent) {
                this.parent = parent;
                this.elements = this.parent.querySelectorAll("[data-prlx]");
                this.animation = this.animationFrame.bind(this);
                this.offset = 0;
                this.value = 0;
                this.smooth = parent.dataset.smooth ? Number(parent.dataset.smooth) : 15;
                this.setEvents();
            }
            setEvents() {
                this.animationID = window.requestAnimationFrame(this.animation);
            }
            destroyEvents() {
                window.cancelAnimationFrame(this.animationID);
            }
            animationFrame() {
                const topToWindow = this.parent.getBoundingClientRect().top;
                const heightParent = this.parent.offsetHeight;
                const heightWindow = window.innerHeight;
                const positionParent = {
                    top: topToWindow - heightWindow,
                    bottom: topToWindow + heightParent
                };
                const centerPoint = this.parent.dataset.center ? this.parent.dataset.center : "center";
                if (positionParent.top < 30 && positionParent.bottom > -30) switch (centerPoint) {
                  case "top":
                    this.offset = -1 * topToWindow;
                    break;

                  case "center":
                    this.offset = heightWindow / 2 - (topToWindow + heightParent / 2);
                    break;

                  case "bottom":
                    this.offset = heightWindow - (topToWindow + heightParent);
                    break;
                }
                this.value += (this.offset - this.value) / this.smooth;
                this.animationID = window.requestAnimationFrame(this.animation);
                this.elements.forEach((el => {
                    const parameters = {
                        axis: el.dataset.axis ? el.dataset.axis : "v",
                        direction: el.dataset.direction ? el.dataset.direction + "1" : "-1",
                        coefficient: el.dataset.coefficient ? Number(el.dataset.coefficient) : 5,
                        additionalProperties: el.dataset.properties ? el.dataset.properties : ""
                    };
                    this.parameters(el, parameters);
                }));
            }
            parameters(el, parameters) {
                if ("v" == parameters.axis) el.style.transform = `translate3D(0, ${(parameters.direction * (this.value / parameters.coefficient)).toFixed(2)}px,0) ${parameters.additionalProperties}`; else if ("h" == parameters.axis) el.style.transform = `translate3D(${(parameters.direction * (this.value / parameters.coefficient)).toFixed(2)}px,0,0) ${parameters.additionalProperties}`;
            }
        };
        if (document.querySelectorAll("[data-prlx-parent]")) modules_flsModules.parallax = new parallax_Parallax(document.querySelectorAll("[data-prlx-parent]"));
        class MousePRLX {
            constructor(props, data = null) {
                let defaultConfig = {
                    init: true,
                    logging: true
                };
                this.config = Object.assign(defaultConfig, props);
                if (this.config.init) {
                    const paralaxMouse = document.querySelectorAll("[data-prlx-mouse]");
                    if (paralaxMouse.length) {
                        this.paralaxMouseInit(paralaxMouse);
                        this.setLogging(`,   : (${paralaxMouse.length})`);
                    } else this.setLogging("   . ...zzZZZzZZz...");
                }
            }
            paralaxMouseInit(paralaxMouse) {
                paralaxMouse.forEach((el => {
                    const paralaxMouseWrapper = el.closest("[data-prlx-mouse-wrapper]");
                    const paramoefficientX = el.dataset.prlxCx ? +el.dataset.prlxCx : 100;
                    const paramoefficientY = el.dataset.prlxCy ? +el.dataset.prlxCy : 100;
                    const directionX = el.hasAttribute("data-prlx-dxr") ? -1 : 1;
                    const directionY = el.hasAttribute("data-prlx-dyr") ? -1 : 1;
                    const paramAnimation = el.dataset.prlxA ? +el.dataset.prlxA : 50;
                    let positionX = 0, positionY = 0;
                    let coordXprocent = 0, coordYprocent = 0;
                    setMouseParallaxStyle();
                    if (paralaxMouseWrapper) mouseMoveParalax(paralaxMouseWrapper); else mouseMoveParalax();
                    function setMouseParallaxStyle() {
                        const distX = coordXprocent - positionX;
                        const distY = coordYprocent - positionY;
                        positionX += distX * paramAnimation / 1e3;
                        positionY += distY * paramAnimation / 1e3;
                        el.style.cssText = `transform: translate3D(${directionX * positionX / (paramoefficientX / 10)}%,${directionY * positionY / (paramoefficientY / 10)}%,0);`;
                        requestAnimationFrame(setMouseParallaxStyle);
                    }
                    function mouseMoveParalax(wrapper = window) {
                        wrapper.addEventListener("mousemove", (function(e) {
                            const offsetTop = el.getBoundingClientRect().top + window.scrollY;
                            if (offsetTop >= window.scrollY || offsetTop + el.offsetHeight >= window.scrollY) {
                                const parallaxWidth = window.innerWidth;
                                const parallaxHeight = window.innerHeight;
                                const coordX = e.clientX - parallaxWidth / 2;
                                const coordY = e.clientY - parallaxHeight / 2;
                                coordXprocent = coordX / parallaxWidth * 100;
                                coordYprocent = coordY / parallaxHeight * 100;
                            }
                        }));
                    }
                }));
            }
            setLogging(message) {
                this.config.logging ? functions_FLS(`[PRLX Mouse]: ${message}`) : null;
            }
        }
        modules_flsModules.mousePrlx = new MousePRLX({});
        let addWindowScrollEvent = false;
        function pageNavigation() {
            document.addEventListener("click", pageNavigationAction);
            document.addEventListener("watcherCallback", pageNavigationAction);
            function pageNavigationAction(e) {
                if ("click" === e.type) {
                    const targetElement = e.target;
                    if (targetElement.closest("[data-goto]")) {
                        const gotoLink = targetElement.closest("[data-goto]");
                        const gotoLinkSelector = gotoLink.dataset.goto ? gotoLink.dataset.goto : "";
                        const noHeader = gotoLink.hasAttribute("data-goto-header") ? true : false;
                        const gotoSpeed = gotoLink.dataset.gotoSpeed ? gotoLink.dataset.gotoSpeed : 500;
                        const offsetTop = gotoLink.dataset.gotoTop ? parseInt(gotoLink.dataset.gotoTop) : 0;
                        if (modules_flsModules.fullpage) {
                            const fullpageSectionId = +document.querySelector(`${gotoLinkSelector}`).closest("[data-fp-section]").dataset.fpId;
                            fullpageSectionId ? modules_flsModules.fullpage.switchingSection(fullpageSectionId) : null;
                            document.documentElement.classList.contains("menu-open") ? menuClose() : null;
                        } else gotoblock_gotoBlock(gotoLinkSelector, noHeader, gotoSpeed, offsetTop);
                        e.preventDefault();
                    }
                } else if ("watcherCallback" === e.type && e.detail) {
                    const entry = e.detail.entry;
                    const targetElement = entry.target;
                    if ("navigator" === targetElement.dataset.watch) {
                        document.querySelector(`[data-goto]._navigator-active`);
                        let navigatorCurrentItem;
                        if (targetElement.id && document.querySelector(`[data-goto="#${targetElement.id}"]`)) navigatorCurrentItem = document.querySelector(`[data-goto="#${targetElement.id}"]`); else if (targetElement.classList.length) for (let index = 0; index < targetElement.classList.length; index++) {
                            const element = targetElement.classList[index];
                            if (document.querySelector(`[data-goto=".${element}"]`)) {
                                navigatorCurrentItem = document.querySelector(`[data-goto=".${element}"]`);
                                break;
                            }
                        }
                        if (entry.isIntersecting) navigatorCurrentItem ? navigatorCurrentItem.classList.add("_navigator-active") : null; else navigatorCurrentItem ? navigatorCurrentItem.classList.remove("_navigator-active") : null;
                    }
                }
            }
            if (getHash()) {
                let goToHash;
                if (document.querySelector(`#${getHash()}`)) goToHash = `#${getHash()}`; else if (document.querySelector(`.${getHash()}`)) goToHash = `.${getHash()}`;
                goToHash ? gotoblock_gotoBlock(goToHash, true, 500, 20) : null;
            }
        }
        setTimeout((() => {
            if (addWindowScrollEvent) {
                let windowScroll = new Event("windowScroll");
                window.addEventListener("scroll", (function(e) {
                    document.dispatchEvent(windowScroll);
                }));
            }
        }), 0);
        var Chart = __webpack_require__(7757);
        const labels = [ "1/18", "3/18", "5/18", "7/18", "9/18", "11/18", "1/19", "3/19", "5/19", "7/19", "9/19", "11/19", "1/20", "3/20", "5/20", "7/20", "9/20", "11/20", "1/21", "3/21", "5/21", "7/21", "9/21", "11/21", "1/22", "3/22", "5/22", "7/22", "9/22", "11/22" ];
        const chart_data = {
            labels,
            datasets: [ {
                label: "",
                backgroundColor: "transparent",
                borderColor: "#2DFFD9",
                pointBorderColor: "#2DFFD9",
                data: [ 100, 150, 171, 190, 179, 196, 240, 290, 280, 301, 310, 324, 315, 340, 323, 380, 440, 423, 460, 560, 550, 570, 610, 604, 640, 690, 740, 733, 756, 765, 780 ]
            } ]
        };
        const config = {
            type: "line",
            data: chart_data,
            options: {}
        };
        if (document.getElementById("myChart")) {
            new Chart.Chart(document.getElementById("myChart").getContext("2d"), config);
        }
        class DynamicAdapt {
            constructor(type) {
                this.type = type;
            }
            init() {
                this.bjects = [];
                this.daClassname = "_dynamic_adapt_";
                this.nodes = [ ...document.querySelectorAll("[data-da]") ];
                this.nodes.forEach((node => {
                    const data = node.dataset.da.trim();
                    const dataArray = data.split(",");
                    const bject = {};
                    bject.element = node;
                    bject.parent = node.parentNode;
                    bject.destination = document.querySelector(`${dataArray[0].trim()}`);
                    bject.breakpoint = dataArray[1] ? dataArray[1].trim() : "767";
                    bject.place = dataArray[2] ? dataArray[2].trim() : "last";
                    bject.index = this.indexInParent(bject.parent, bject.element);
                    this.bjects.push(bject);
                }));
                this.arraySort(this.bjects);
                this.mediaQueries = this.bjects.map((({breakpoint}) => `(${this.type}-width: ${breakpoint}px),${breakpoint}`)).filter(((item, index, self) => self.indexOf(item) === index));
                this.mediaQueries.forEach((media => {
                    const mediaSplit = media.split(",");
                    const matchMedia = window.matchMedia(mediaSplit[0]);
                    const mediaBreakpoint = mediaSplit[1];
                    const bjectsFilter = this.bjects.filter((({breakpoint}) => breakpoint === mediaBreakpoint));
                    matchMedia.addEventListener("change", (() => {
                        this.mediaHandler(matchMedia, bjectsFilter);
                    }));
                    this.mediaHandler(matchMedia, bjectsFilter);
                }));
            }
            mediaHandler(matchMedia, bjects) {
                if (matchMedia.matches) bjects.forEach((bject => {
                    this.moveTo(bject.place, bject.element, bject.destination);
                })); else bjects.forEach((({parent, element, index}) => {
                    if (element.classList.contains(this.daClassname)) this.moveBack(parent, element, index);
                }));
            }
            moveTo(place, element, destination) {
                element.classList.add(this.daClassname);
                if ("last" === place || place >= destination.children.length) {
                    destination.append(element);
                    return;
                }
                if ("first" === place) {
                    destination.prepend(element);
                    return;
                }
                destination.children[place].before(element);
            }
            moveBack(parent, element, index) {
                element.classList.remove(this.daClassname);
                if (void 0 !== parent.children[index]) parent.children[index].before(element); else parent.append(element);
            }
            indexInParent(parent, element) {
                return [ ...parent.children ].indexOf(element);
            }
            arraySort(arr) {
                if ("min" === this.type) arr.sort(((a, b) => {
                    if (a.breakpoint === b.breakpoint) {
                        if (a.place === b.place) return 0;
                        if ("first" === a.place || "last" === b.place) return -1;
                        if ("last" === a.place || "first" === b.place) return 1;
                        return 0;
                    }
                    return a.breakpoint - b.breakpoint;
                })); else {
                    arr.sort(((a, b) => {
                        if (a.breakpoint === b.breakpoint) {
                            if (a.place === b.place) return 0;
                            if ("first" === a.place || "last" === b.place) return 1;
                            if ("last" === a.place || "first" === b.place) return -1;
                            return 0;
                        }
                        return b.breakpoint - a.breakpoint;
                    }));
                    return;
                }
            }
        }
        const da = new DynamicAdapt("max");
        da.init();
        window["FLS"] = true;
        isWebp();
        menuInit();
        pageNavigation();
    })();
})();